var r6=Object.defineProperty;var i6=(n,e,t)=>e in n?r6(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var Mt=(n,e,t)=>(i6(n,typeof e!="symbol"?e+"":e,t),t);function a6(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function XI(n){const e=Object.create(null);for(const t of n.split(","))e[t]=1;return t=>t in e}const bn={},Jl=[],mi=()=>{},o6=()=>!1,yf=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&(n.charCodeAt(2)>122||n.charCodeAt(2)<97),ZI=n=>n.startsWith("onUpdate:"),gs=Object.assign,QI=(n,e)=>{const t=n.indexOf(e);t>-1&&n.splice(t,1)},l6=Object.prototype.hasOwnProperty,un=(n,e)=>l6.call(n,e),Rt=Array.isArray,eu=n=>bf(n)==="[object Map]",BD=n=>bf(n)==="[object Set]",Pt=n=>typeof n=="function",Qn=n=>typeof n=="string",to=n=>typeof n=="symbol",Dn=n=>n!==null&&typeof n=="object",HD=n=>(Dn(n)||Pt(n))&&Pt(n.then)&&Pt(n.catch),UD=Object.prototype.toString,bf=n=>UD.call(n),u6=n=>bf(n).slice(8,-1),GD=n=>bf(n)==="[object Object]",JI=n=>Qn(n)&&n!=="NaN"&&n[0]!=="-"&&""+parseInt(n,10)===n,Sc=XI(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),xf=n=>{const e=Object.create(null);return t=>e[t]||(e[t]=n(t))},c6=/-(\w)/g,Xr=xf(n=>n.replace(c6,(e,t)=>t?t.toUpperCase():"")),d6=/\B([A-Z])/g,gl=xf(n=>n.replace(d6,"-$1").toLowerCase()),Nf=xf(n=>n.charAt(0).toUpperCase()+n.slice(1)),Z0=xf(n=>n?`on${Nf(n)}`:""),Ma=(n,e)=>!Object.is(n,e),Q0=(n,...e)=>{for(let t=0;t<n.length;t++)n[t](...e)},qD=(n,e,t,s=!1)=>{Object.defineProperty(n,e,{configurable:!0,enumerable:!1,writable:s,value:t})},h6=n=>{const e=parseFloat(n);return isNaN(e)?n:e};let D$;const wf=()=>D$||(D$=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function ey(n){if(Rt(n)){const e={};for(let t=0;t<n.length;t++){const s=n[t],r=Qn(s)?g6(s):ey(s);if(r)for(const i in r)e[i]=r[i]}return e}else if(Qn(n)||Dn(n))return n}const p6=/;(?![^(]*\))/g,f6=/:([^]+)/,m6=/\/\*[^]*?\*\//g;function g6(n){const e={};return n.replace(m6,"").split(p6).forEach(t=>{if(t){const s=t.split(f6);s.length>1&&(e[s[0].trim()]=s[1].trim())}}),e}function Du(n){let e="";if(Qn(n))e=n;else if(Rt(n))for(let t=0;t<n.length;t++){const s=Du(n[t]);s&&(e+=s+" ")}else if(Dn(n))for(const t in n)n[t]&&(e+=t+" ");return e.trim()}const I6="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",y6=XI(I6);function KD(n){return!!n||n===""}const jD=n=>!!(n&&n.__v_isRef===!0),YD=n=>Qn(n)?n:n==null?"":Rt(n)||Dn(n)&&(n.toString===UD||!Pt(n.toString))?jD(n)?YD(n.value):JSON.stringify(n,XD,2):String(n),XD=(n,e)=>jD(e)?XD(n,e.value):eu(e)?{[`Map(${e.size})`]:[...e.entries()].reduce((t,[s,r],i)=>(t[J0(s,i)+" =>"]=r,t),{})}:BD(e)?{[`Set(${e.size})`]:[...e.values()].map(t=>J0(t))}:to(e)?J0(e):Dn(e)&&!Rt(e)&&!GD(e)?String(e):e,J0=(n,e="")=>{var t;return to(n)?`Symbol(${(t=n.description)!=null?t:e})`:n};/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let Tr;class b6{constructor(e=!1){this.detached=e,this._active=!0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=Tr,!e&&Tr&&(this.index=(Tr.scopes||(Tr.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let e,t;if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].pause();for(e=0,t=this.effects.length;e<t;e++)this.effects[e].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let e,t;if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].resume();for(e=0,t=this.effects.length;e<t;e++)this.effects[e].resume()}}run(e){if(this._active){const t=Tr;try{return Tr=this,e()}finally{Tr=t}}}on(){Tr=this}off(){Tr=this.parent}stop(e){if(this._active){this._active=!1;let t,s;for(t=0,s=this.effects.length;t<s;t++)this.effects[t].stop();for(this.effects.length=0,t=0,s=this.cleanups.length;t<s;t++)this.cleanups[t]();if(this.cleanups.length=0,this.scopes){for(t=0,s=this.scopes.length;t<s;t++)this.scopes[t].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!e){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function x6(){return Tr}let yn;const e1=new WeakSet;class ZD{constructor(e){this.fn=e,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,Tr&&Tr.active&&Tr.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,e1.has(this)&&(e1.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||JD(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,E$(this),eE(this);const e=yn,t=gi;yn=this,gi=!0;try{return this.fn()}finally{tE(this),yn=e,gi=t,this.flags&=-3}}stop(){if(this.flags&1){for(let e=this.deps;e;e=e.nextDep)sy(e);this.deps=this.depsTail=void 0,E$(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?e1.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){O1(this)&&this.run()}get dirty(){return O1(this)}}let QD=0,vc,$c;function JD(n,e=!1){if(n.flags|=8,e){n.next=$c,$c=n;return}n.next=vc,vc=n}function ty(){QD++}function ny(){if(--QD>0)return;if($c){let e=$c;for($c=void 0;e;){const t=e.next;e.next=void 0,e.flags&=-9,e=t}}let n;for(;vc;){let e=vc;for(vc=void 0;e;){const t=e.next;if(e.next=void 0,e.flags&=-9,e.flags&1)try{e.trigger()}catch(s){n||(n=s)}e=t}}if(n)throw n}function eE(n){for(let e=n.deps;e;e=e.nextDep)e.version=-1,e.prevActiveLink=e.dep.activeLink,e.dep.activeLink=e}function tE(n){let e,t=n.depsTail,s=t;for(;s;){const r=s.prevDep;s.version===-1?(s===t&&(t=r),sy(s),N6(s)):e=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}n.deps=e,n.depsTail=t}function O1(n){for(let e=n.deps;e;e=e.nextDep)if(e.dep.version!==e.version||e.dep.computed&&(nE(e.dep.computed)||e.dep.version!==e.version))return!0;return!!n._dirty}function nE(n){if(n.flags&4&&!(n.flags&16)||(n.flags&=-17,n.globalVersion===Pc))return;n.globalVersion=Pc;const e=n.dep;if(n.flags|=2,e.version>0&&!n.isSSR&&n.deps&&!O1(n)){n.flags&=-3;return}const t=yn,s=gi;yn=n,gi=!0;try{eE(n);const r=n.fn(n._value);(e.version===0||Ma(r,n._value))&&(n._value=r,e.version++)}catch(r){throw e.version++,r}finally{yn=t,gi=s,tE(n),n.flags&=-3}}function sy(n,e=!1){const{dep:t,prevSub:s,nextSub:r}=n;if(s&&(s.nextSub=r,n.prevSub=void 0),r&&(r.prevSub=s,n.nextSub=void 0),t.subs===n&&(t.subs=s,!s&&t.computed)){t.computed.flags&=-5;for(let i=t.computed.deps;i;i=i.nextDep)sy(i,!0)}!e&&!--t.sc&&t.map&&t.map.delete(t.key)}function N6(n){const{prevDep:e,nextDep:t}=n;e&&(e.nextDep=t,n.prevDep=void 0),t&&(t.prevDep=e,n.nextDep=void 0)}let gi=!0;const sE=[];function no(){sE.push(gi),gi=!1}function so(){const n=sE.pop();gi=n===void 0?!0:n}function E$(n){const{cleanup:e}=n;if(n.cleanup=void 0,e){const t=yn;yn=void 0;try{e()}finally{yn=t}}}let Pc=0;class w6{constructor(e,t){this.sub=e,this.dep=t,this.version=t.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class ry{constructor(e){this.computed=e,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0}track(e){if(!yn||!gi||yn===this.computed)return;let t=this.activeLink;if(t===void 0||t.sub!==yn)t=this.activeLink=new w6(yn,this),yn.deps?(t.prevDep=yn.depsTail,yn.depsTail.nextDep=t,yn.depsTail=t):yn.deps=yn.depsTail=t,rE(t);else if(t.version===-1&&(t.version=this.version,t.nextDep)){const s=t.nextDep;s.prevDep=t.prevDep,t.prevDep&&(t.prevDep.nextDep=s),t.prevDep=yn.depsTail,t.nextDep=void 0,yn.depsTail.nextDep=t,yn.depsTail=t,yn.deps===t&&(yn.deps=s)}return t}trigger(e){this.version++,Pc++,this.notify(e)}notify(e){ty();try{for(let t=this.subs;t;t=t.prevSub)t.sub.notify()&&t.sub.dep.notify()}finally{ny()}}}function rE(n){if(n.dep.sc++,n.sub.flags&4){const e=n.dep.computed;if(e&&!n.dep.subs){e.flags|=20;for(let s=e.deps;s;s=s.nextDep)rE(s)}const t=n.dep.subs;t!==n&&(n.prevSub=t,t&&(t.nextSub=n)),n.dep.subs=n}}const R1=new WeakMap,Ko=Symbol(""),V1=Symbol(""),Fc=Symbol("");function Os(n,e,t){if(gi&&yn){let s=R1.get(n);s||R1.set(n,s=new Map);let r=s.get(t);r||(s.set(t,r=new ry),r.map=s,r.key=t),r.track()}}function oa(n,e,t,s,r,i){const o=R1.get(n);if(!o){Pc++;return}const l=u=>{u&&u.trigger()};if(ty(),e==="clear")o.forEach(l);else{const u=Rt(n),d=u&&JI(t);if(u&&t==="length"){const h=Number(s);o.forEach((f,m)=>{(m==="length"||m===Fc||!to(m)&&m>=h)&&l(f)})}else switch((t!==void 0||o.has(void 0))&&l(o.get(t)),d&&l(o.get(Fc)),e){case"add":u?d&&l(o.get("length")):(l(o.get(Ko)),eu(n)&&l(o.get(V1)));break;case"delete":u||(l(o.get(Ko)),eu(n)&&l(o.get(V1)));break;case"set":eu(n)&&l(o.get(Ko));break}}ny()}function zl(n){const e=on(n);return e===n?e:(Os(e,"iterate",Fc),Kr(n)?e:e.map(Rs))}function Af(n){return Os(n=on(n),"iterate",Fc),n}const A6={__proto__:null,[Symbol.iterator](){return t1(this,Symbol.iterator,Rs)},concat(...n){return zl(this).concat(...n.map(e=>Rt(e)?zl(e):e))},entries(){return t1(this,"entries",n=>(n[1]=Rs(n[1]),n))},every(n,e){return ea(this,"every",n,e,void 0,arguments)},filter(n,e){return ea(this,"filter",n,e,t=>t.map(Rs),arguments)},find(n,e){return ea(this,"find",n,e,Rs,arguments)},findIndex(n,e){return ea(this,"findIndex",n,e,void 0,arguments)},findLast(n,e){return ea(this,"findLast",n,e,Rs,arguments)},findLastIndex(n,e){return ea(this,"findLastIndex",n,e,void 0,arguments)},forEach(n,e){return ea(this,"forEach",n,e,void 0,arguments)},includes(...n){return n1(this,"includes",n)},indexOf(...n){return n1(this,"indexOf",n)},join(n){return zl(this).join(n)},lastIndexOf(...n){return n1(this,"lastIndexOf",n)},map(n,e){return ea(this,"map",n,e,void 0,arguments)},pop(){return lc(this,"pop")},push(...n){return lc(this,"push",n)},reduce(n,...e){return k$(this,"reduce",n,e)},reduceRight(n,...e){return k$(this,"reduceRight",n,e)},shift(){return lc(this,"shift")},some(n,e){return ea(this,"some",n,e,void 0,arguments)},splice(...n){return lc(this,"splice",n)},toReversed(){return zl(this).toReversed()},toSorted(n){return zl(this).toSorted(n)},toSpliced(...n){return zl(this).toSpliced(...n)},unshift(...n){return lc(this,"unshift",n)},values(){return t1(this,"values",Rs)}};function t1(n,e,t){const s=Af(n),r=s[e]();return s!==n&&!Kr(n)&&(r._next=r.next,r.next=()=>{const i=r._next();return i.value&&(i.value=t(i.value)),i}),r}const T6=Array.prototype;function ea(n,e,t,s,r,i){const o=Af(n),l=o!==n&&!Kr(n),u=o[e];if(u!==T6[e]){const f=u.apply(n,i);return l?Rs(f):f}let d=t;o!==n&&(l?d=function(f,m){return t.call(this,Rs(f),m,n)}:t.length>2&&(d=function(f,m){return t.call(this,f,m,n)}));const h=u.call(o,d,s);return l&&r?r(h):h}function k$(n,e,t,s){const r=Af(n);let i=t;return r!==n&&(Kr(n)?t.length>3&&(i=function(o,l,u){return t.call(this,o,l,u,n)}):i=function(o,l,u){return t.call(this,o,Rs(l),u,n)}),r[e](i,...s)}function n1(n,e,t){const s=on(n);Os(s,"iterate",Fc);const r=s[e](...t);return(r===-1||r===!1)&&oy(t[0])?(t[0]=on(t[0]),s[e](...t)):r}function lc(n,e,t=[]){no(),ty();const s=on(n)[e].apply(n,t);return ny(),so(),s}const S6=XI("__proto__,__v_isRef,__isVue"),iE=new Set(Object.getOwnPropertyNames(Symbol).filter(n=>n!=="arguments"&&n!=="caller").map(n=>Symbol[n]).filter(to));function v6(n){to(n)||(n=String(n));const e=on(this);return Os(e,"has",n),e.hasOwnProperty(n)}class aE{constructor(e=!1,t=!1){this._isReadonly=e,this._isShallow=t}get(e,t,s){if(t==="__v_skip")return e.__v_skip;const r=this._isReadonly,i=this._isShallow;if(t==="__v_isReactive")return!r;if(t==="__v_isReadonly")return r;if(t==="__v_isShallow")return i;if(t==="__v_raw")return s===(r?i?V6:cE:i?uE:lE).get(e)||Object.getPrototypeOf(e)===Object.getPrototypeOf(s)?e:void 0;const o=Rt(e);if(!r){let u;if(o&&(u=A6[t]))return u;if(t==="hasOwnProperty")return v6}const l=Reflect.get(e,t,Ss(e)?e:s);return(to(t)?iE.has(t):S6(t))||(r||Os(e,"get",t),i)?l:Ss(l)?o&&JI(t)?l:l.value:Dn(l)?r?hE(l):hu(l):l}}class oE extends aE{constructor(e=!1){super(!1,e)}set(e,t,s,r){let i=e[t];if(!this._isShallow){const u=Zo(i);if(!Kr(s)&&!Zo(s)&&(i=on(i),s=on(s)),!Rt(e)&&Ss(i)&&!Ss(s))return u?!1:(i.value=s,!0)}const o=Rt(e)&&JI(t)?Number(t)<e.length:un(e,t),l=Reflect.set(e,t,s,Ss(e)?e:r);return e===on(r)&&(o?Ma(s,i)&&oa(e,"set",t,s):oa(e,"add",t,s)),l}deleteProperty(e,t){const s=un(e,t);e[t];const r=Reflect.deleteProperty(e,t);return r&&s&&oa(e,"delete",t,void 0),r}has(e,t){const s=Reflect.has(e,t);return(!to(t)||!iE.has(t))&&Os(e,"has",t),s}ownKeys(e){return Os(e,"iterate",Rt(e)?"length":Ko),Reflect.ownKeys(e)}}class $6 extends aE{constructor(e=!1){super(!0,e)}set(e,t){return!0}deleteProperty(e,t){return!0}}const _6=new oE,D6=new $6,E6=new oE(!0);const P1=n=>n,Qh=n=>Reflect.getPrototypeOf(n);function k6(n,e,t){return function(...s){const r=this.__v_raw,i=on(r),o=eu(i),l=n==="entries"||n===Symbol.iterator&&o,u=n==="keys"&&o,d=r[n](...s),h=t?P1:e?F1:Rs;return!e&&Os(i,"iterate",u?V1:Ko),{next(){const{value:f,done:m}=d.next();return m?{value:f,done:m}:{value:l?[h(f[0]),h(f[1])]:h(f),done:m}},[Symbol.iterator](){return this}}}}function Jh(n){return function(...e){return n==="delete"?!1:n==="clear"?void 0:this}}function C6(n,e){const t={get(r){const i=this.__v_raw,o=on(i),l=on(r);n||(Ma(r,l)&&Os(o,"get",r),Os(o,"get",l));const{has:u}=Qh(o),d=e?P1:n?F1:Rs;if(u.call(o,r))return d(i.get(r));if(u.call(o,l))return d(i.get(l));i!==o&&i.get(r)},get size(){const r=this.__v_raw;return!n&&Os(on(r),"iterate",Ko),Reflect.get(r,"size",r)},has(r){const i=this.__v_raw,o=on(i),l=on(r);return n||(Ma(r,l)&&Os(o,"has",r),Os(o,"has",l)),r===l?i.has(r):i.has(r)||i.has(l)},forEach(r,i){const o=this,l=o.__v_raw,u=on(l),d=e?P1:n?F1:Rs;return!n&&Os(u,"iterate",Ko),l.forEach((h,f)=>r.call(i,d(h),d(f),o))}};return gs(t,n?{add:Jh("add"),set:Jh("set"),delete:Jh("delete"),clear:Jh("clear")}:{add(r){!e&&!Kr(r)&&!Zo(r)&&(r=on(r));const i=on(this);return Qh(i).has.call(i,r)||(i.add(r),oa(i,"add",r,r)),this},set(r,i){!e&&!Kr(i)&&!Zo(i)&&(i=on(i));const o=on(this),{has:l,get:u}=Qh(o);let d=l.call(o,r);d||(r=on(r),d=l.call(o,r));const h=u.call(o,r);return o.set(r,i),d?Ma(i,h)&&oa(o,"set",r,i):oa(o,"add",r,i),this},delete(r){const i=on(this),{has:o,get:l}=Qh(i);let u=o.call(i,r);u||(r=on(r),u=o.call(i,r)),l&&l.call(i,r);const d=i.delete(r);return u&&oa(i,"delete",r,void 0),d},clear(){const r=on(this),i=r.size!==0,o=r.clear();return i&&oa(r,"clear",void 0,void 0),o}}),["keys","values","entries",Symbol.iterator].forEach(r=>{t[r]=k6(r,n,e)}),t}function iy(n,e){const t=C6(n,e);return(s,r,i)=>r==="__v_isReactive"?!n:r==="__v_isReadonly"?n:r==="__v_raw"?s:Reflect.get(un(t,r)&&r in s?t:s,r,i)}const L6={get:iy(!1,!1)},O6={get:iy(!1,!0)},R6={get:iy(!0,!1)};const lE=new WeakMap,uE=new WeakMap,cE=new WeakMap,V6=new WeakMap;function P6(n){switch(n){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function F6(n){return n.__v_skip||!Object.isExtensible(n)?0:P6(u6(n))}function hu(n){return Zo(n)?n:ay(n,!1,_6,L6,lE)}function dE(n){return ay(n,!1,E6,O6,uE)}function hE(n){return ay(n,!0,D6,R6,cE)}function ay(n,e,t,s,r){if(!Dn(n)||n.__v_raw&&!(e&&n.__v_isReactive))return n;const i=r.get(n);if(i)return i;const o=F6(n);if(o===0)return n;const l=new Proxy(n,o===2?s:t);return r.set(n,l),l}function tu(n){return Zo(n)?tu(n.__v_raw):!!(n&&n.__v_isReactive)}function Zo(n){return!!(n&&n.__v_isReadonly)}function Kr(n){return!!(n&&n.__v_isShallow)}function oy(n){return n?!!n.__v_raw:!1}function on(n){const e=n&&n.__v_raw;return e?on(e):n}function z6(n){return!un(n,"__v_skip")&&Object.isExtensible(n)&&qD(n,"__v_skip",!0),n}const Rs=n=>Dn(n)?hu(n):n,F1=n=>Dn(n)?hE(n):n;function Ss(n){return n?n.__v_isRef===!0:!1}function zc(n){return pE(n,!1)}function M6(n){return pE(n,!0)}function pE(n,e){return Ss(n)?n:new W6(n,e)}class W6{constructor(e,t){this.dep=new ry,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=t?e:on(e),this._value=t?e:Rs(e),this.__v_isShallow=t}get value(){return this.dep.track(),this._value}set value(e){const t=this._rawValue,s=this.__v_isShallow||Kr(e)||Zo(e);e=s?e:on(e),Ma(e,t)&&(this._rawValue=e,this._value=s?e:Rs(e),this.dep.trigger())}}function ca(n){return Ss(n)?n.value:n}const B6={get:(n,e,t)=>e==="__v_raw"?n:ca(Reflect.get(n,e,t)),set:(n,e,t,s)=>{const r=n[e];return Ss(r)&&!Ss(t)?(r.value=t,!0):Reflect.set(n,e,t,s)}};function fE(n){return tu(n)?n:new Proxy(n,B6)}class H6{constructor(e,t,s){this.fn=e,this.setter=t,this._value=void 0,this.dep=new ry(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=Pc-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!t,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&yn!==this)return JD(this,!0),!0}get value(){const e=this.dep.track();return nE(this),e&&(e.version=this.dep.version),this._value}set value(e){this.setter&&this.setter(e)}}function U6(n,e,t=!1){let s,r;return Pt(n)?s=n:(s=n.get,r=n.set),new H6(s,r,t)}const ep={},$p=new WeakMap;let Vo;function G6(n,e=!1,t=Vo){if(t){let s=$p.get(t);s||$p.set(t,s=[]),s.push(n)}}function q6(n,e,t=bn){const{immediate:s,deep:r,once:i,scheduler:o,augmentJob:l,call:u}=t,d=_=>r?_:Kr(_)||r===!1||r===0?Ra(_,1):Ra(_);let h,f,m,I,y=!1,N=!1;if(Ss(n)?(f=()=>n.value,y=Kr(n)):tu(n)?(f=()=>d(n),y=!0):Rt(n)?(N=!0,y=n.some(_=>tu(_)||Kr(_)),f=()=>n.map(_=>{if(Ss(_))return _.value;if(tu(_))return d(_);if(Pt(_))return u?u(_,2):_()})):Pt(n)?e?f=u?()=>u(n,2):n:f=()=>{if(m){no();try{m()}finally{so()}}const _=Vo;Vo=h;try{return u?u(n,3,[I]):n(I)}finally{Vo=_}}:f=mi,e&&r){const _=f,L=r===!0?1/0:r;f=()=>Ra(_(),L)}const w=x6(),T=()=>{h.stop(),w&&w.active&&QI(w.effects,h)};if(i&&e){const _=e;e=(...L)=>{_(...L),T()}}let v=N?new Array(n.length).fill(ep):ep;const E=_=>{if(!(!(h.flags&1)||!h.dirty&&!_))if(e){const L=h.run();if(r||y||(N?L.some((P,B)=>Ma(P,v[B])):Ma(L,v))){m&&m();const P=Vo;Vo=h;try{const B=[L,v===ep?void 0:N&&v[0]===ep?[]:v,I];u?u(e,3,B):e(...B),v=L}finally{Vo=P}}}else h.run()};return l&&l(E),h=new ZD(f),h.scheduler=o?()=>o(E,!1):E,I=_=>G6(_,!1,h),m=h.onStop=()=>{const _=$p.get(h);if(_){if(u)u(_,4);else for(const L of _)L();$p.delete(h)}},e?s?E(!0):v=h.run():o?o(E.bind(null,!0),!0):h.run(),T.pause=h.pause.bind(h),T.resume=h.resume.bind(h),T.stop=T,T}function Ra(n,e=1/0,t){if(e<=0||!Dn(n)||n.__v_skip||(t=t||new Set,t.has(n)))return n;if(t.add(n),e--,Ss(n))Ra(n.value,e,t);else if(Rt(n))for(let s=0;s<n.length;s++)Ra(n[s],e,t);else if(BD(n)||eu(n))n.forEach(s=>{Ra(s,e,t)});else if(GD(n)){for(const s in n)Ra(n[s],e,t);for(const s of Object.getOwnPropertySymbols(n))Object.prototype.propertyIsEnumerable.call(n,s)&&Ra(n[s],e,t)}return n}/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function ld(n,e,t,s){try{return s?n(...s):n()}catch(r){Tf(r,e,t)}}function Gi(n,e,t,s){if(Pt(n)){const r=ld(n,e,t,s);return r&&HD(r)&&r.catch(i=>{Tf(i,e,t)}),r}if(Rt(n)){const r=[];for(let i=0;i<n.length;i++)r.push(Gi(n[i],e,t,s));return r}}function Tf(n,e,t,s=!0){const r=e?e.vnode:null,{errorHandler:i,throwUnhandledErrorInProduction:o}=e&&e.appContext.config||bn;if(e){let l=e.parent;const u=e.proxy,d=`https://vuejs.org/error-reference/#runtime-${t}`;for(;l;){const h=l.ec;if(h){for(let f=0;f<h.length;f++)if(h[f](n,u,d)===!1)return}l=l.parent}if(i){no(),ld(i,null,10,[n,u,d]),so();return}}K6(n,t,r,s,o)}function K6(n,e,t,s=!0,r=!1){if(r)throw n;console.error(n)}const Ys=[];let Di=-1;const nu=[];let Ea=null,Ul=0;const mE=Promise.resolve();let _p=null;function gE(n){const e=_p||mE;return n?e.then(this?n.bind(this):n):e}function j6(n){let e=Di+1,t=Ys.length;for(;e<t;){const s=e+t>>>1,r=Ys[s],i=Mc(r);i<n||i===n&&r.flags&2?e=s+1:t=s}return e}function ly(n){if(!(n.flags&1)){const e=Mc(n),t=Ys[Ys.length-1];!t||!(n.flags&2)&&e>=Mc(t)?Ys.push(n):Ys.splice(j6(e),0,n),n.flags|=1,IE()}}function IE(){_p||(_p=mE.then(bE))}function Y6(n){Rt(n)?nu.push(...n):Ea&&n.id===-1?Ea.splice(Ul+1,0,n):n.flags&1||(nu.push(n),n.flags|=1),IE()}function C$(n,e,t=Di+1){for(;t<Ys.length;t++){const s=Ys[t];if(s&&s.flags&2){if(n&&s.id!==n.uid)continue;Ys.splice(t,1),t--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function yE(n){if(nu.length){const e=[...new Set(nu)].sort((t,s)=>Mc(t)-Mc(s));if(nu.length=0,Ea){Ea.push(...e);return}for(Ea=e,Ul=0;Ul<Ea.length;Ul++){const t=Ea[Ul];t.flags&4&&(t.flags&=-2),t.flags&8||t(),t.flags&=-2}Ea=null,Ul=0}}const Mc=n=>n.id==null?n.flags&2?-1:1/0:n.id;function bE(n){const e=mi;try{for(Di=0;Di<Ys.length;Di++){const t=Ys[Di];t&&!(t.flags&8)&&(t.flags&4&&(t.flags&=-2),ld(t,t.i,t.i?15:14),t.flags&4||(t.flags&=-2))}}finally{for(;Di<Ys.length;Di++){const t=Ys[Di];t&&(t.flags&=-2)}Di=-1,Ys.length=0,yE(),_p=null,(Ys.length||nu.length)&&bE()}}let fi=null,xE=null;function Dp(n){const e=fi;return fi=n,xE=n&&n.type.__scopeId||null,e}function gp(n,e=fi,t){if(!e||n._n)return n;const s=(...r)=>{s._d&&W$(-1);const i=Dp(e);let o;try{o=n(...r)}finally{Dp(i),s._d&&W$(1)}return o};return s._n=!0,s._c=!0,s._d=!0,s}function Co(n,e,t,s){const r=n.dirs,i=e&&e.dirs;for(let o=0;o<r.length;o++){const l=r[o];i&&(l.oldValue=i[o].value);let u=l.dir[s];u&&(no(),Gi(u,t,8,[n.el,l,n,e]),so())}}const X6=Symbol("_vte"),Z6=n=>n.__isTeleport;function uy(n,e){n.shapeFlag&6&&n.component?(n.transition=e,uy(n.component.subTree,e)):n.shapeFlag&128?(n.ssContent.transition=e.clone(n.ssContent),n.ssFallback.transition=e.clone(n.ssFallback)):n.transition=e}/*! #__NO_SIDE_EFFECTS__ */function Il(n,e){return Pt(n)?(()=>gs({name:n.name},e,{setup:n}))():n}function NE(n){n.ids=[n.ids[0]+n.ids[2]+++"-",0,0]}function Ep(n,e,t,s,r=!1){if(Rt(n)){n.forEach((y,N)=>Ep(y,e&&(Rt(e)?e[N]:e),t,s,r));return}if(_c(s)&&!r){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&Ep(n,e,t,s.component.subTree);return}const i=s.shapeFlag&4?fy(s.component):s.el,o=r?null:i,{i:l,r:u}=n,d=e&&e.r,h=l.refs===bn?l.refs={}:l.refs,f=l.setupState,m=on(f),I=f===bn?()=>!1:y=>un(m,y);if(d!=null&&d!==u&&(Qn(d)?(h[d]=null,I(d)&&(f[d]=null)):Ss(d)&&(d.value=null)),Pt(u))ld(u,l,12,[o,h]);else{const y=Qn(u),N=Ss(u);if(y||N){const w=()=>{if(n.f){const T=y?I(u)?f[u]:h[u]:u.value;r?Rt(T)&&QI(T,i):Rt(T)?T.includes(i)||T.push(i):y?(h[u]=[i],I(u)&&(f[u]=h[u])):(u.value=[i],n.k&&(h[n.k]=u.value))}else y?(h[u]=o,I(u)&&(f[u]=o)):N&&(u.value=o,n.k&&(h[n.k]=o))};o?(w.id=-1,Ar(w,t)):w()}}}wf().requestIdleCallback;wf().cancelIdleCallback;const _c=n=>!!n.type.__asyncLoader,wE=n=>n.type.__isKeepAlive;function Q6(n,e){AE(n,"a",e)}function J6(n,e){AE(n,"da",e)}function AE(n,e,t=Fs){const s=n.__wdc||(n.__wdc=()=>{let r=t;for(;r;){if(r.isDeactivated)return;r=r.parent}return n()});if(Sf(e,s,t),t){let r=t.parent;for(;r&&r.parent;)wE(r.parent.vnode)&&eF(s,e,t,r),r=r.parent}}function eF(n,e,t,s){const r=Sf(e,n,s,!0);SE(()=>{QI(s[e],r)},t)}function Sf(n,e,t=Fs,s=!1){if(t){const r=t[n]||(t[n]=[]),i=e.__weh||(e.__weh=(...o)=>{no();const l=ud(t),u=Gi(e,t,n,o);return l(),so(),u});return s?r.unshift(i):r.push(i),i}}const ya=n=>(e,t=Fs)=>{(!Bc||n==="sp")&&Sf(n,(...s)=>e(...s),t)},tF=ya("bm"),TE=ya("m"),nF=ya("bu"),sF=ya("u"),rF=ya("bum"),SE=ya("um"),iF=ya("sp"),aF=ya("rtg"),oF=ya("rtc");function lF(n,e=Fs){Sf("ec",n,e)}const vE="components";function $E(n,e){return cF(vE,n,!0,e)||n}const uF=Symbol.for("v-ndc");function cF(n,e,t=!0,s=!1){const r=fi||Fs;if(r){const i=r.type;if(n===vE){const l=JF(i,!1);if(l&&(l===e||l===Xr(e)||l===Nf(Xr(e))))return i}const o=L$(r[n]||i[n],e)||L$(r.appContext[n],e);return!o&&s?i:o}}function L$(n,e){return n&&(n[e]||n[Xr(e)]||n[Nf(Xr(e))])}function dF(n,e,t,s){let r;const i=t&&t[s],o=Rt(n);if(o||Qn(n)){const l=o&&tu(n);let u=!1;l&&(u=!Kr(n),n=Af(n)),r=new Array(n.length);for(let d=0,h=n.length;d<h;d++)r[d]=e(u?Rs(n[d]):n[d],d,void 0,i&&i[d])}else if(typeof n=="number"){r=new Array(n);for(let l=0;l<n;l++)r[l]=e(l+1,l,void 0,i&&i[l])}else if(Dn(n))if(n[Symbol.iterator])r=Array.from(n,(l,u)=>e(l,u,void 0,i&&i[u]));else{const l=Object.keys(n);r=new Array(l.length);for(let u=0,d=l.length;u<d;u++){const h=l[u];r[u]=e(n[h],h,u,i&&i[u])}}else r=[];return t&&(t[s]=r),r}const z1=n=>n?KE(n)?fy(n):z1(n.parent):null,Dc=gs(Object.create(null),{$:n=>n,$el:n=>n.vnode.el,$data:n=>n.data,$props:n=>n.props,$attrs:n=>n.attrs,$slots:n=>n.slots,$refs:n=>n.refs,$parent:n=>z1(n.parent),$root:n=>z1(n.root),$host:n=>n.ce,$emit:n=>n.emit,$options:n=>cy(n),$forceUpdate:n=>n.f||(n.f=()=>{ly(n.update)}),$nextTick:n=>n.n||(n.n=gE.bind(n.proxy)),$watch:n=>CF.bind(n)}),s1=(n,e)=>n!==bn&&!n.__isScriptSetup&&un(n,e),hF={get({_:n},e){if(e==="__v_skip")return!0;const{ctx:t,setupState:s,data:r,props:i,accessCache:o,type:l,appContext:u}=n;let d;if(e[0]!=="$"){const I=o[e];if(I!==void 0)switch(I){case 1:return s[e];case 2:return r[e];case 4:return t[e];case 3:return i[e]}else{if(s1(s,e))return o[e]=1,s[e];if(r!==bn&&un(r,e))return o[e]=2,r[e];if((d=n.propsOptions[0])&&un(d,e))return o[e]=3,i[e];if(t!==bn&&un(t,e))return o[e]=4,t[e];M1&&(o[e]=0)}}const h=Dc[e];let f,m;if(h)return e==="$attrs"&&Os(n.attrs,"get",""),h(n);if((f=l.__cssModules)&&(f=f[e]))return f;if(t!==bn&&un(t,e))return o[e]=4,t[e];if(m=u.config.globalProperties,un(m,e))return m[e]},set({_:n},e,t){const{data:s,setupState:r,ctx:i}=n;return s1(r,e)?(r[e]=t,!0):s!==bn&&un(s,e)?(s[e]=t,!0):un(n.props,e)||e[0]==="$"&&e.slice(1)in n?!1:(i[e]=t,!0)},has({_:{data:n,setupState:e,accessCache:t,ctx:s,appContext:r,propsOptions:i}},o){let l;return!!t[o]||n!==bn&&un(n,o)||s1(e,o)||(l=i[0])&&un(l,o)||un(s,o)||un(Dc,o)||un(r.config.globalProperties,o)},defineProperty(n,e,t){return t.get!=null?n._.accessCache[e]=0:un(t,"value")&&this.set(n,e,t.value,null),Reflect.defineProperty(n,e,t)}};function O$(n){return Rt(n)?n.reduce((e,t)=>(e[t]=null,e),{}):n}let M1=!0;function pF(n){const e=cy(n),t=n.proxy,s=n.ctx;M1=!1,e.beforeCreate&&R$(e.beforeCreate,n,"bc");const{data:r,computed:i,methods:o,watch:l,provide:u,inject:d,created:h,beforeMount:f,mounted:m,beforeUpdate:I,updated:y,activated:N,deactivated:w,beforeDestroy:T,beforeUnmount:v,destroyed:E,unmounted:_,render:L,renderTracked:P,renderTriggered:B,errorCaptured:U,serverPrefetch:Z,expose:Y,inheritAttrs:ae,components:de,directives:ce,filters:Ie}=e;if(d&&fF(d,s,null),o)for(const we in o){const fe=o[we];Pt(fe)&&(s[we]=fe.bind(t))}if(r){const we=r.call(t,t);Dn(we)&&(n.data=hu(we))}if(M1=!0,i)for(const we in i){const fe=i[we],De=Pt(fe)?fe.bind(t,t):Pt(fe.get)?fe.get.bind(t,t):mi,Pe=!Pt(fe)&&Pt(fe.set)?fe.set.bind(t):mi,Fe=pi({get:De,set:Pe});Object.defineProperty(s,we,{enumerable:!0,configurable:!0,get:()=>Fe.value,set:Ue=>Fe.value=Ue})}if(l)for(const we in l)_E(l[we],s,t,we);if(u){const we=Pt(u)?u.call(t):u;Reflect.ownKeys(we).forEach(fe=>{Ip(fe,we[fe])})}h&&R$(h,n,"c");function ye(we,fe){Rt(fe)?fe.forEach(De=>we(De.bind(t))):fe&&we(fe.bind(t))}if(ye(tF,f),ye(TE,m),ye(nF,I),ye(sF,y),ye(Q6,N),ye(J6,w),ye(lF,U),ye(oF,P),ye(aF,B),ye(rF,v),ye(SE,_),ye(iF,Z),Rt(Y))if(Y.length){const we=n.exposed||(n.exposed={});Y.forEach(fe=>{Object.defineProperty(we,fe,{get:()=>t[fe],set:De=>t[fe]=De})})}else n.exposed||(n.exposed={});L&&n.render===mi&&(n.render=L),ae!=null&&(n.inheritAttrs=ae),de&&(n.components=de),ce&&(n.directives=ce),Z&&NE(n)}function fF(n,e,t=mi){Rt(n)&&(n=W1(n));for(const s in n){const r=n[s];let i;Dn(r)?"default"in r?i=da(r.from||s,r.default,!0):i=da(r.from||s):i=da(r),Ss(i)?Object.defineProperty(e,s,{enumerable:!0,configurable:!0,get:()=>i.value,set:o=>i.value=o}):e[s]=i}}function R$(n,e,t){Gi(Rt(n)?n.map(s=>s.bind(e.proxy)):n.bind(e.proxy),e,t)}function _E(n,e,t,s){let r=s.includes(".")?BE(t,s):()=>t[s];if(Qn(n)){const i=e[n];Pt(i)&&ru(r,i)}else if(Pt(n))ru(r,n.bind(t));else if(Dn(n))if(Rt(n))n.forEach(i=>_E(i,e,t,s));else{const i=Pt(n.handler)?n.handler.bind(t):e[n.handler];Pt(i)&&ru(r,i,n)}}function cy(n){const e=n.type,{mixins:t,extends:s}=e,{mixins:r,optionsCache:i,config:{optionMergeStrategies:o}}=n.appContext,l=i.get(e);let u;return l?u=l:!r.length&&!t&&!s?u=e:(u={},r.length&&r.forEach(d=>kp(u,d,o,!0)),kp(u,e,o)),Dn(e)&&i.set(e,u),u}function kp(n,e,t,s=!1){const{mixins:r,extends:i}=e;i&&kp(n,i,t,!0),r&&r.forEach(o=>kp(n,o,t,!0));for(const o in e)if(!(s&&o==="expose")){const l=mF[o]||t&&t[o];n[o]=l?l(n[o],e[o]):e[o]}return n}const mF={data:V$,props:P$,emits:P$,methods:Ic,computed:Ic,beforeCreate:Ks,created:Ks,beforeMount:Ks,mounted:Ks,beforeUpdate:Ks,updated:Ks,beforeDestroy:Ks,beforeUnmount:Ks,destroyed:Ks,unmounted:Ks,activated:Ks,deactivated:Ks,errorCaptured:Ks,serverPrefetch:Ks,components:Ic,directives:Ic,watch:IF,provide:V$,inject:gF};function V$(n,e){return e?n?function(){return gs(Pt(n)?n.call(this,this):n,Pt(e)?e.call(this,this):e)}:e:n}function gF(n,e){return Ic(W1(n),W1(e))}function W1(n){if(Rt(n)){const e={};for(let t=0;t<n.length;t++)e[n[t]]=n[t];return e}return n}function Ks(n,e){return n?[...new Set([].concat(n,e))]:e}function Ic(n,e){return n?gs(Object.create(null),n,e):e}function P$(n,e){return n?Rt(n)&&Rt(e)?[...new Set([...n,...e])]:gs(Object.create(null),O$(n),O$(e??{})):e}function IF(n,e){if(!n)return e;if(!e)return n;const t=gs(Object.create(null),n);for(const s in e)t[s]=Ks(n[s],e[s]);return t}function DE(){return{app:null,config:{isNativeTag:o6,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let yF=0;function bF(n,e){return function(s,r=null){Pt(s)||(s=gs({},s)),r!=null&&!Dn(r)&&(r=null);const i=DE(),o=new WeakSet,l=[];let u=!1;const d=i.app={_uid:yF++,_component:s,_props:r,_container:null,_context:i,_instance:null,version:tz,get config(){return i.config},set config(h){},use(h,...f){return o.has(h)||(h&&Pt(h.install)?(o.add(h),h.install(d,...f)):Pt(h)&&(o.add(h),h(d,...f))),d},mixin(h){return i.mixins.includes(h)||i.mixins.push(h),d},component(h,f){return f?(i.components[h]=f,d):i.components[h]},directive(h,f){return f?(i.directives[h]=f,d):i.directives[h]},mount(h,f,m){if(!u){const I=d._ceVNode||rs(s,r);return I.appContext=i,m===!0?m="svg":m===!1&&(m=void 0),f&&e?e(I,h):n(I,h,m),u=!0,d._container=h,h.__vue_app__=d,fy(I.component)}},onUnmount(h){l.push(h)},unmount(){u&&(Gi(l,d._instance,16),n(null,d._container),delete d._container.__vue_app__)},provide(h,f){return i.provides[h]=f,d},runWithContext(h){const f=su;su=d;try{return h()}finally{su=f}}};return d}}let su=null;function Ip(n,e){if(Fs){let t=Fs.provides;const s=Fs.parent&&Fs.parent.provides;s===t&&(t=Fs.provides=Object.create(s)),t[n]=e}}function da(n,e,t=!1){const s=Fs||fi;if(s||su){const r=su?su._context.provides:s?s.parent==null?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(r&&n in r)return r[n];if(arguments.length>1)return t&&Pt(e)?e.call(s&&s.proxy):e}}const EE={},kE=()=>Object.create(EE),CE=n=>Object.getPrototypeOf(n)===EE;function xF(n,e,t,s=!1){const r={},i=kE();n.propsDefaults=Object.create(null),LE(n,e,r,i);for(const o in n.propsOptions[0])o in r||(r[o]=void 0);t?n.props=s?r:dE(r):n.type.props?n.props=r:n.props=i,n.attrs=i}function NF(n,e,t,s){const{props:r,attrs:i,vnode:{patchFlag:o}}=n,l=on(r),[u]=n.propsOptions;let d=!1;if((s||o>0)&&!(o&16)){if(o&8){const h=n.vnode.dynamicProps;for(let f=0;f<h.length;f++){let m=h[f];if(vf(n.emitsOptions,m))continue;const I=e[m];if(u)if(un(i,m))I!==i[m]&&(i[m]=I,d=!0);else{const y=Xr(m);r[y]=B1(u,l,y,I,n,!1)}else I!==i[m]&&(i[m]=I,d=!0)}}}else{LE(n,e,r,i)&&(d=!0);let h;for(const f in l)(!e||!un(e,f)&&((h=gl(f))===f||!un(e,h)))&&(u?t&&(t[f]!==void 0||t[h]!==void 0)&&(r[f]=B1(u,l,f,void 0,n,!0)):delete r[f]);if(i!==l)for(const f in i)(!e||!un(e,f))&&(delete i[f],d=!0)}d&&oa(n.attrs,"set","")}function LE(n,e,t,s){const[r,i]=n.propsOptions;let o=!1,l;if(e)for(let u in e){if(Sc(u))continue;const d=e[u];let h;r&&un(r,h=Xr(u))?!i||!i.includes(h)?t[h]=d:(l||(l={}))[h]=d:vf(n.emitsOptions,u)||(!(u in s)||d!==s[u])&&(s[u]=d,o=!0)}if(i){const u=on(t),d=l||bn;for(let h=0;h<i.length;h++){const f=i[h];t[f]=B1(r,u,f,d[f],n,!un(d,f))}}return o}function B1(n,e,t,s,r,i){const o=n[t];if(o!=null){const l=un(o,"default");if(l&&s===void 0){const u=o.default;if(o.type!==Function&&!o.skipFactory&&Pt(u)){const{propsDefaults:d}=r;if(t in d)s=d[t];else{const h=ud(r);s=d[t]=u.call(null,e),h()}}else s=u;r.ce&&r.ce._setProp(t,s)}o[0]&&(i&&!l?s=!1:o[1]&&(s===""||s===gl(t))&&(s=!0))}return s}const wF=new WeakMap;function OE(n,e,t=!1){const s=t?wF:e.propsCache,r=s.get(n);if(r)return r;const i=n.props,o={},l=[];let u=!1;if(!Pt(n)){const h=f=>{u=!0;const[m,I]=OE(f,e,!0);gs(o,m),I&&l.push(...I)};!t&&e.mixins.length&&e.mixins.forEach(h),n.extends&&h(n.extends),n.mixins&&n.mixins.forEach(h)}if(!i&&!u)return Dn(n)&&s.set(n,Jl),Jl;if(Rt(i))for(let h=0;h<i.length;h++){const f=Xr(i[h]);F$(f)&&(o[f]=bn)}else if(i)for(const h in i){const f=Xr(h);if(F$(f)){const m=i[h],I=o[f]=Rt(m)||Pt(m)?{type:m}:gs({},m),y=I.type;let N=!1,w=!0;if(Rt(y))for(let T=0;T<y.length;++T){const v=y[T],E=Pt(v)&&v.name;if(E==="Boolean"){N=!0;break}else E==="String"&&(w=!1)}else N=Pt(y)&&y.name==="Boolean";I[0]=N,I[1]=w,(N||un(I,"default"))&&l.push(f)}}const d=[o,l];return Dn(n)&&s.set(n,d),d}function F$(n){return n[0]!=="$"&&!Sc(n)}const RE=n=>n[0]==="_"||n==="$stable",dy=n=>Rt(n)?n.map(Ci):[Ci(n)],AF=(n,e,t)=>{if(e._n)return e;const s=gp((...r)=>dy(e(...r)),t);return s._c=!1,s},VE=(n,e,t)=>{const s=n._ctx;for(const r in n){if(RE(r))continue;const i=n[r];if(Pt(i))e[r]=AF(r,i,s);else if(i!=null){const o=dy(i);e[r]=()=>o}}},PE=(n,e)=>{const t=dy(e);n.slots.default=()=>t},FE=(n,e,t)=>{for(const s in e)(t||s!=="_")&&(n[s]=e[s])},TF=(n,e,t)=>{const s=n.slots=kE();if(n.vnode.shapeFlag&32){const r=e._;r?(FE(s,e,t),t&&qD(s,"_",r,!0)):VE(e,s)}else e&&PE(n,e)},SF=(n,e,t)=>{const{vnode:s,slots:r}=n;let i=!0,o=bn;if(s.shapeFlag&32){const l=e._;l?t&&l===1?i=!1:FE(r,e,t):(i=!e.$stable,VE(e,r)),o=e}else e&&(PE(n,e),o={default:1});if(i)for(const l in r)!RE(l)&&o[l]==null&&delete r[l]},Ar=zF;function vF(n){return $F(n)}function $F(n,e){const t=wf();t.__VUE__=!0;const{insert:s,remove:r,patchProp:i,createElement:o,createText:l,createComment:u,setText:d,setElementText:h,parentNode:f,nextSibling:m,setScopeId:I=mi,insertStaticContent:y}=n,N=(j,Q,ue,Ee=null,Se=null,Oe=null,Xe=void 0,qe=null,Ye=!!Q.dynamicChildren)=>{if(j===Q)return;j&&!uc(j,Q)&&(Ee=he(j),Ue(j,Se,Oe,!0),j=null),Q.patchFlag===-2&&(Ye=!1,Q.dynamicChildren=null);const{type:We,ref:Nt,shapeFlag:Je}=Q;switch(We){case $f:w(j,Q,ue,Ee);break;case Qo:T(j,Q,ue,Ee);break;case yp:j==null&&v(Q,ue,Ee,Xe);break;case ci:de(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye);break;default:Je&1?L(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye):Je&6?ce(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye):(Je&64||Je&128)&&We.process(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye,ze)}Nt!=null&&Se&&Ep(Nt,j&&j.ref,Oe,Q||j,!Q)},w=(j,Q,ue,Ee)=>{if(j==null)s(Q.el=l(Q.children),ue,Ee);else{const Se=Q.el=j.el;Q.children!==j.children&&d(Se,Q.children)}},T=(j,Q,ue,Ee)=>{j==null?s(Q.el=u(Q.children||""),ue,Ee):Q.el=j.el},v=(j,Q,ue,Ee)=>{[j.el,j.anchor]=y(j.children,Q,ue,Ee,j.el,j.anchor)},E=({el:j,anchor:Q},ue,Ee)=>{let Se;for(;j&&j!==Q;)Se=m(j),s(j,ue,Ee),j=Se;s(Q,ue,Ee)},_=({el:j,anchor:Q})=>{let ue;for(;j&&j!==Q;)ue=m(j),r(j),j=ue;r(Q)},L=(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye)=>{Q.type==="svg"?Xe="svg":Q.type==="math"&&(Xe="mathml"),j==null?P(Q,ue,Ee,Se,Oe,Xe,qe,Ye):Z(j,Q,Se,Oe,Xe,qe,Ye)},P=(j,Q,ue,Ee,Se,Oe,Xe,qe)=>{let Ye,We;const{props:Nt,shapeFlag:Je,transition:ct,dirs:dt}=j;if(Ye=j.el=o(j.type,Oe,Nt&&Nt.is,Nt),Je&8?h(Ye,j.children):Je&16&&U(j.children,Ye,null,Ee,Se,r1(j,Oe),Xe,qe),dt&&Co(j,null,Ee,"created"),B(Ye,j,j.scopeId,Xe,Ee),Nt){for(const qt in Nt)qt!=="value"&&!Sc(qt)&&i(Ye,qt,null,Nt[qt],Oe,Ee);"value"in Nt&&i(Ye,"value",null,Nt.value,Oe),(We=Nt.onVnodeBeforeMount)&&_i(We,Ee,j)}dt&&Co(j,null,Ee,"beforeMount");const Dt=_F(Se,ct);Dt&&ct.beforeEnter(Ye),s(Ye,Q,ue),((We=Nt&&Nt.onVnodeMounted)||Dt||dt)&&Ar(()=>{We&&_i(We,Ee,j),Dt&&ct.enter(Ye),dt&&Co(j,null,Ee,"mounted")},Se)},B=(j,Q,ue,Ee,Se)=>{if(ue&&I(j,ue),Ee)for(let Oe=0;Oe<Ee.length;Oe++)I(j,Ee[Oe]);if(Se){let Oe=Se.subTree;if(Q===Oe||UE(Oe.type)&&(Oe.ssContent===Q||Oe.ssFallback===Q)){const Xe=Se.vnode;B(j,Xe,Xe.scopeId,Xe.slotScopeIds,Se.parent)}}},U=(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye=0)=>{for(let We=Ye;We<j.length;We++){const Nt=j[We]=qe?ka(j[We]):Ci(j[We]);N(null,Nt,Q,ue,Ee,Se,Oe,Xe,qe)}},Z=(j,Q,ue,Ee,Se,Oe,Xe)=>{const qe=Q.el=j.el;let{patchFlag:Ye,dynamicChildren:We,dirs:Nt}=Q;Ye|=j.patchFlag&16;const Je=j.props||bn,ct=Q.props||bn;let dt;if(ue&&Lo(ue,!1),(dt=ct.onVnodeBeforeUpdate)&&_i(dt,ue,Q,j),Nt&&Co(Q,j,ue,"beforeUpdate"),ue&&Lo(ue,!0),(Je.innerHTML&&ct.innerHTML==null||Je.textContent&&ct.textContent==null)&&h(qe,""),We?Y(j.dynamicChildren,We,qe,ue,Ee,r1(Q,Se),Oe):Xe||fe(j,Q,qe,null,ue,Ee,r1(Q,Se),Oe,!1),Ye>0){if(Ye&16)ae(qe,Je,ct,ue,Se);else if(Ye&2&&Je.class!==ct.class&&i(qe,"class",null,ct.class,Se),Ye&4&&i(qe,"style",Je.style,ct.style,Se),Ye&8){const Dt=Q.dynamicProps;for(let qt=0;qt<Dt.length;qt++){const Ut=Dt[qt],Bn=Je[Ut],kn=ct[Ut];(kn!==Bn||Ut==="value")&&i(qe,Ut,Bn,kn,Se,ue)}}Ye&1&&j.children!==Q.children&&h(qe,Q.children)}else!Xe&&We==null&&ae(qe,Je,ct,ue,Se);((dt=ct.onVnodeUpdated)||Nt)&&Ar(()=>{dt&&_i(dt,ue,Q,j),Nt&&Co(Q,j,ue,"updated")},Ee)},Y=(j,Q,ue,Ee,Se,Oe,Xe)=>{for(let qe=0;qe<Q.length;qe++){const Ye=j[qe],We=Q[qe],Nt=Ye.el&&(Ye.type===ci||!uc(Ye,We)||Ye.shapeFlag&70)?f(Ye.el):ue;N(Ye,We,Nt,null,Ee,Se,Oe,Xe,!0)}},ae=(j,Q,ue,Ee,Se)=>{if(Q!==ue){if(Q!==bn)for(const Oe in Q)!Sc(Oe)&&!(Oe in ue)&&i(j,Oe,Q[Oe],null,Se,Ee);for(const Oe in ue){if(Sc(Oe))continue;const Xe=ue[Oe],qe=Q[Oe];Xe!==qe&&Oe!=="value"&&i(j,Oe,qe,Xe,Se,Ee)}"value"in ue&&i(j,"value",Q.value,ue.value,Se)}},de=(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye)=>{const We=Q.el=j?j.el:l(""),Nt=Q.anchor=j?j.anchor:l("");let{patchFlag:Je,dynamicChildren:ct,slotScopeIds:dt}=Q;dt&&(qe=qe?qe.concat(dt):dt),j==null?(s(We,ue,Ee),s(Nt,ue,Ee),U(Q.children||[],ue,Nt,Se,Oe,Xe,qe,Ye)):Je>0&&Je&64&&ct&&j.dynamicChildren?(Y(j.dynamicChildren,ct,ue,Se,Oe,Xe,qe),(Q.key!=null||Se&&Q===Se.subTree)&&zE(j,Q,!0)):fe(j,Q,ue,Nt,Se,Oe,Xe,qe,Ye)},ce=(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye)=>{Q.slotScopeIds=qe,j==null?Q.shapeFlag&512?Se.ctx.activate(Q,ue,Ee,Xe,Ye):Ie(Q,ue,Ee,Se,Oe,Xe,Ye):be(j,Q,Ye)},Ie=(j,Q,ue,Ee,Se,Oe,Xe)=>{const qe=j.component=jF(j,Ee,Se);if(wE(j)&&(qe.ctx.renderer=ze),YF(qe,!1,Xe),qe.asyncDep){if(Se&&Se.registerDep(qe,ye,Xe),!j.el){const Ye=qe.subTree=rs(Qo);T(null,Ye,Q,ue)}}else ye(qe,j,Q,ue,Se,Oe,Xe)},be=(j,Q,ue)=>{const Ee=Q.component=j.component;if(PF(j,Q,ue))if(Ee.asyncDep&&!Ee.asyncResolved){we(Ee,Q,ue);return}else Ee.next=Q,Ee.update();else Q.el=j.el,Ee.vnode=Q},ye=(j,Q,ue,Ee,Se,Oe,Xe)=>{const qe=()=>{if(j.isMounted){let{next:Je,bu:ct,u:dt,parent:Dt,vnode:qt}=j;{const Hn=ME(j);if(Hn){Je&&(Je.el=qt.el,we(j,Je,Xe)),Hn.asyncDep.then(()=>{j.isUnmounted||qe()});return}}let Ut=Je,Bn;Lo(j,!1),Je?(Je.el=qt.el,we(j,Je,Xe)):Je=qt,ct&&Q0(ct),(Bn=Je.props&&Je.props.onVnodeBeforeUpdate)&&_i(Bn,Dt,Je,qt),Lo(j,!0);const kn=i1(j),Us=j.subTree;j.subTree=kn,N(Us,kn,f(Us.el),he(Us),j,Se,Oe),Je.el=kn.el,Ut===null&&FF(j,kn.el),dt&&Ar(dt,Se),(Bn=Je.props&&Je.props.onVnodeUpdated)&&Ar(()=>_i(Bn,Dt,Je,qt),Se)}else{let Je;const{el:ct,props:dt}=Q,{bm:Dt,m:qt,parent:Ut,root:Bn,type:kn}=j,Us=_c(Q);if(Lo(j,!1),Dt&&Q0(Dt),!Us&&(Je=dt&&dt.onVnodeBeforeMount)&&_i(Je,Ut,Q),Lo(j,!0),ct&&xt){const Hn=()=>{j.subTree=i1(j),xt(ct,j.subTree,j,Se,null)};Us&&kn.__asyncHydrate?kn.__asyncHydrate(ct,j,Hn):Hn()}else{Bn.ce&&Bn.ce._injectChildStyle(kn);const Hn=j.subTree=i1(j);N(null,Hn,ue,Ee,j,Se,Oe),Q.el=Hn.el}if(qt&&Ar(qt,Se),!Us&&(Je=dt&&dt.onVnodeMounted)){const Hn=Q;Ar(()=>_i(Je,Ut,Hn),Se)}(Q.shapeFlag&256||Ut&&_c(Ut.vnode)&&Ut.vnode.shapeFlag&256)&&j.a&&Ar(j.a,Se),j.isMounted=!0,Q=ue=Ee=null}};j.scope.on();const Ye=j.effect=new ZD(qe);j.scope.off();const We=j.update=Ye.run.bind(Ye),Nt=j.job=Ye.runIfDirty.bind(Ye);Nt.i=j,Nt.id=j.uid,Ye.scheduler=()=>ly(Nt),Lo(j,!0),We()},we=(j,Q,ue)=>{Q.component=j;const Ee=j.vnode.props;j.vnode=Q,j.next=null,NF(j,Q.props,Ee,ue),SF(j,Q.children,ue),no(),C$(j),so()},fe=(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye=!1)=>{const We=j&&j.children,Nt=j?j.shapeFlag:0,Je=Q.children,{patchFlag:ct,shapeFlag:dt}=Q;if(ct>0){if(ct&128){Pe(We,Je,ue,Ee,Se,Oe,Xe,qe,Ye);return}else if(ct&256){De(We,Je,ue,Ee,Se,Oe,Xe,qe,Ye);return}}dt&8?(Nt&16&&Qe(We,Se,Oe),Je!==We&&h(ue,Je)):Nt&16?dt&16?Pe(We,Je,ue,Ee,Se,Oe,Xe,qe,Ye):Qe(We,Se,Oe,!0):(Nt&8&&h(ue,""),dt&16&&U(Je,ue,Ee,Se,Oe,Xe,qe,Ye))},De=(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye)=>{j=j||Jl,Q=Q||Jl;const We=j.length,Nt=Q.length,Je=Math.min(We,Nt);let ct;for(ct=0;ct<Je;ct++){const dt=Q[ct]=Ye?ka(Q[ct]):Ci(Q[ct]);N(j[ct],dt,ue,null,Se,Oe,Xe,qe,Ye)}We>Nt?Qe(j,Se,Oe,!0,!1,Je):U(Q,ue,Ee,Se,Oe,Xe,qe,Ye,Je)},Pe=(j,Q,ue,Ee,Se,Oe,Xe,qe,Ye)=>{let We=0;const Nt=Q.length;let Je=j.length-1,ct=Nt-1;for(;We<=Je&&We<=ct;){const dt=j[We],Dt=Q[We]=Ye?ka(Q[We]):Ci(Q[We]);if(uc(dt,Dt))N(dt,Dt,ue,null,Se,Oe,Xe,qe,Ye);else break;We++}for(;We<=Je&&We<=ct;){const dt=j[Je],Dt=Q[ct]=Ye?ka(Q[ct]):Ci(Q[ct]);if(uc(dt,Dt))N(dt,Dt,ue,null,Se,Oe,Xe,qe,Ye);else break;Je--,ct--}if(We>Je){if(We<=ct){const dt=ct+1,Dt=dt<Nt?Q[dt].el:Ee;for(;We<=ct;)N(null,Q[We]=Ye?ka(Q[We]):Ci(Q[We]),ue,Dt,Se,Oe,Xe,qe,Ye),We++}}else if(We>ct)for(;We<=Je;)Ue(j[We],Se,Oe,!0),We++;else{const dt=We,Dt=We,qt=new Map;for(We=Dt;We<=ct;We++){const As=Q[We]=Ye?ka(Q[We]):Ci(Q[We]);As.key!=null&&qt.set(As.key,We)}let Ut,Bn=0;const kn=ct-Dt+1;let Us=!1,Hn=0;const vi=new Array(kn);for(We=0;We<kn;We++)vi[We]=0;for(We=dt;We<=Je;We++){const As=j[We];if(Bn>=kn){Ue(As,Se,Oe,!0);continue}let Gs;if(As.key!=null)Gs=qt.get(As.key);else for(Ut=Dt;Ut<=ct;Ut++)if(vi[Ut-Dt]===0&&uc(As,Q[Ut])){Gs=Ut;break}Gs===void 0?Ue(As,Se,Oe,!0):(vi[Gs-Dt]=We+1,Gs>=Hn?Hn=Gs:Us=!0,N(As,Q[Gs],ue,null,Se,Oe,Xe,qe,Ye),Bn++)}const cs=Us?DF(vi):Jl;for(Ut=cs.length-1,We=kn-1;We>=0;We--){const As=Dt+We,Gs=Q[As],ju=As+1<Nt?Q[As+1].el:Ee;vi[We]===0?N(null,Gs,ue,ju,Se,Oe,Xe,qe,Ye):Us&&(Ut<0||We!==cs[Ut]?Fe(Gs,ue,ju,2):Ut--)}}},Fe=(j,Q,ue,Ee,Se=null)=>{const{el:Oe,type:Xe,transition:qe,children:Ye,shapeFlag:We}=j;if(We&6){Fe(j.component.subTree,Q,ue,Ee);return}if(We&128){j.suspense.move(Q,ue,Ee);return}if(We&64){Xe.move(j,Q,ue,ze);return}if(Xe===ci){s(Oe,Q,ue);for(let Je=0;Je<Ye.length;Je++)Fe(Ye[Je],Q,ue,Ee);s(j.anchor,Q,ue);return}if(Xe===yp){E(j,Q,ue);return}if(Ee!==2&&We&1&&qe)if(Ee===0)qe.beforeEnter(Oe),s(Oe,Q,ue),Ar(()=>qe.enter(Oe),Se);else{const{leave:Je,delayLeave:ct,afterLeave:dt}=qe,Dt=()=>s(Oe,Q,ue),qt=()=>{Je(Oe,()=>{Dt(),dt&&dt()})};ct?ct(Oe,Dt,qt):qt()}else s(Oe,Q,ue)},Ue=(j,Q,ue,Ee=!1,Se=!1)=>{const{type:Oe,props:Xe,ref:qe,children:Ye,dynamicChildren:We,shapeFlag:Nt,patchFlag:Je,dirs:ct,cacheIndex:dt}=j;if(Je===-2&&(Se=!1),qe!=null&&Ep(qe,null,ue,j,!0),dt!=null&&(Q.renderCache[dt]=void 0),Nt&256){Q.ctx.deactivate(j);return}const Dt=Nt&1&&ct,qt=!_c(j);let Ut;if(qt&&(Ut=Xe&&Xe.onVnodeBeforeUnmount)&&_i(Ut,Q,j),Nt&6)je(j.component,ue,Ee);else{if(Nt&128){j.suspense.unmount(ue,Ee);return}Dt&&Co(j,null,Q,"beforeUnmount"),Nt&64?j.type.remove(j,Q,ue,ze,Ee):We&&!We.hasOnce&&(Oe!==ci||Je>0&&Je&64)?Qe(We,Q,ue,!1,!0):(Oe===ci&&Je&384||!Se&&Nt&16)&&Qe(Ye,Q,ue),Ee&&Ge(j)}(qt&&(Ut=Xe&&Xe.onVnodeUnmounted)||Dt)&&Ar(()=>{Ut&&_i(Ut,Q,j),Dt&&Co(j,null,Q,"unmounted")},ue)},Ge=j=>{const{type:Q,el:ue,anchor:Ee,transition:Se}=j;if(Q===ci){Ze(ue,Ee);return}if(Q===yp){_(j);return}const Oe=()=>{r(ue),Se&&!Se.persisted&&Se.afterLeave&&Se.afterLeave()};if(j.shapeFlag&1&&Se&&!Se.persisted){const{leave:Xe,delayLeave:qe}=Se,Ye=()=>Xe(ue,Oe);qe?qe(j.el,Oe,Ye):Ye()}else Oe()},Ze=(j,Q)=>{let ue;for(;j!==Q;)ue=m(j),r(j),j=ue;r(Q)},je=(j,Q,ue)=>{const{bum:Ee,scope:Se,job:Oe,subTree:Xe,um:qe,m:Ye,a:We}=j;z$(Ye),z$(We),Ee&&Q0(Ee),Se.stop(),Oe&&(Oe.flags|=8,Ue(Xe,j,Q,ue)),qe&&Ar(qe,Q),Ar(()=>{j.isUnmounted=!0},Q),Q&&Q.pendingBranch&&!Q.isUnmounted&&j.asyncDep&&!j.asyncResolved&&j.suspenseId===Q.pendingId&&(Q.deps--,Q.deps===0&&Q.resolve())},Qe=(j,Q,ue,Ee=!1,Se=!1,Oe=0)=>{for(let Xe=Oe;Xe<j.length;Xe++)Ue(j[Xe],Q,ue,Ee,Se)},he=j=>{if(j.shapeFlag&6)return he(j.component.subTree);if(j.shapeFlag&128)return j.suspense.next();const Q=m(j.anchor||j.el),ue=Q&&Q[X6];return ue?m(ue):Q};let _e=!1;const ke=(j,Q,ue)=>{j==null?Q._vnode&&Ue(Q._vnode,null,null,!0):N(Q._vnode||null,j,Q,null,null,null,ue),Q._vnode=j,_e||(_e=!0,C$(),yE(),_e=!1)},ze={p:N,um:Ue,m:Fe,r:Ge,mt:Ie,mc:U,pc:fe,pbc:Y,n:he,o:n};let at,xt;return e&&([at,xt]=e(ze)),{render:ke,hydrate:at,createApp:bF(ke,at)}}function r1({type:n,props:e},t){return t==="svg"&&n==="foreignObject"||t==="mathml"&&n==="annotation-xml"&&e&&e.encoding&&e.encoding.includes("html")?void 0:t}function Lo({effect:n,job:e},t){t?(n.flags|=32,e.flags|=4):(n.flags&=-33,e.flags&=-5)}function _F(n,e){return(!n||n&&!n.pendingBranch)&&e&&!e.persisted}function zE(n,e,t=!1){const s=n.children,r=e.children;if(Rt(s)&&Rt(r))for(let i=0;i<s.length;i++){const o=s[i];let l=r[i];l.shapeFlag&1&&!l.dynamicChildren&&((l.patchFlag<=0||l.patchFlag===32)&&(l=r[i]=ka(r[i]),l.el=o.el),!t&&l.patchFlag!==-2&&zE(o,l)),l.type===$f&&(l.el=o.el)}}function DF(n){const e=n.slice(),t=[0];let s,r,i,o,l;const u=n.length;for(s=0;s<u;s++){const d=n[s];if(d!==0){if(r=t[t.length-1],n[r]<d){e[s]=r,t.push(s);continue}for(i=0,o=t.length-1;i<o;)l=i+o>>1,n[t[l]]<d?i=l+1:o=l;d<n[t[i]]&&(i>0&&(e[s]=t[i-1]),t[i]=s)}}for(i=t.length,o=t[i-1];i-- >0;)t[i]=o,o=e[o];return t}function ME(n){const e=n.subTree.component;if(e)return e.asyncDep&&!e.asyncResolved?e:ME(e)}function z$(n){if(n)for(let e=0;e<n.length;e++)n[e].flags|=8}const EF=Symbol.for("v-scx"),kF=()=>da(EF);function ru(n,e,t){return WE(n,e,t)}function WE(n,e,t=bn){const{immediate:s,deep:r,flush:i,once:o}=t,l=gs({},t),u=e&&s||!e&&i!=="post";let d;if(Bc){if(i==="sync"){const I=kF();d=I.__watcherHandles||(I.__watcherHandles=[])}else if(!u){const I=()=>{};return I.stop=mi,I.resume=mi,I.pause=mi,I}}const h=Fs;l.call=(I,y,N)=>Gi(I,h,y,N);let f=!1;i==="post"?l.scheduler=I=>{Ar(I,h&&h.suspense)}:i!=="sync"&&(f=!0,l.scheduler=(I,y)=>{y?I():ly(I)}),l.augmentJob=I=>{e&&(I.flags|=4),f&&(I.flags|=2,h&&(I.id=h.uid,I.i=h))};const m=q6(n,e,l);return Bc&&(d?d.push(m):u&&m()),m}function CF(n,e,t){const s=this.proxy,r=Qn(n)?n.includes(".")?BE(s,n):()=>s[n]:n.bind(s,s);let i;Pt(e)?i=e:(i=e.handler,t=e);const o=ud(this),l=WE(r,i.bind(s),t);return o(),l}function BE(n,e){const t=e.split(".");return()=>{let s=n;for(let r=0;r<t.length&&s;r++)s=s[t[r]];return s}}const LF=(n,e)=>e==="modelValue"||e==="model-value"?n.modelModifiers:n[`${e}Modifiers`]||n[`${Xr(e)}Modifiers`]||n[`${gl(e)}Modifiers`];function OF(n,e,...t){if(n.isUnmounted)return;const s=n.vnode.props||bn;let r=t;const i=e.startsWith("update:"),o=i&&LF(s,e.slice(7));o&&(o.trim&&(r=t.map(h=>Qn(h)?h.trim():h)),o.number&&(r=t.map(h6)));let l,u=s[l=Z0(e)]||s[l=Z0(Xr(e))];!u&&i&&(u=s[l=Z0(gl(e))]),u&&Gi(u,n,6,r);const d=s[l+"Once"];if(d){if(!n.emitted)n.emitted={};else if(n.emitted[l])return;n.emitted[l]=!0,Gi(d,n,6,r)}}function HE(n,e,t=!1){const s=e.emitsCache,r=s.get(n);if(r!==void 0)return r;const i=n.emits;let o={},l=!1;if(!Pt(n)){const u=d=>{const h=HE(d,e,!0);h&&(l=!0,gs(o,h))};!t&&e.mixins.length&&e.mixins.forEach(u),n.extends&&u(n.extends),n.mixins&&n.mixins.forEach(u)}return!i&&!l?(Dn(n)&&s.set(n,null),null):(Rt(i)?i.forEach(u=>o[u]=null):gs(o,i),Dn(n)&&s.set(n,o),o)}function vf(n,e){return!n||!yf(e)?!1:(e=e.slice(2).replace(/Once$/,""),un(n,e[0].toLowerCase()+e.slice(1))||un(n,gl(e))||un(n,e))}function i1(n){const{type:e,vnode:t,proxy:s,withProxy:r,propsOptions:[i],slots:o,attrs:l,emit:u,render:d,renderCache:h,props:f,data:m,setupState:I,ctx:y,inheritAttrs:N}=n,w=Dp(n);let T,v;try{if(t.shapeFlag&4){const _=r||s,L=_;T=Ci(d.call(L,_,h,f,I,m,y)),v=l}else{const _=e;T=Ci(_.length>1?_(f,{attrs:l,slots:o,emit:u}):_(f,null)),v=e.props?l:RF(l)}}catch(_){Ec.length=0,Tf(_,n,1),T=rs(Qo)}let E=T;if(v&&N!==!1){const _=Object.keys(v),{shapeFlag:L}=E;_.length&&L&7&&(i&&_.some(ZI)&&(v=VF(v,i)),E=pu(E,v,!1,!0))}return t.dirs&&(E=pu(E,null,!1,!0),E.dirs=E.dirs?E.dirs.concat(t.dirs):t.dirs),t.transition&&uy(E,t.transition),T=E,Dp(w),T}const RF=n=>{let e;for(const t in n)(t==="class"||t==="style"||yf(t))&&((e||(e={}))[t]=n[t]);return e},VF=(n,e)=>{const t={};for(const s in n)(!ZI(s)||!(s.slice(9)in e))&&(t[s]=n[s]);return t};function PF(n,e,t){const{props:s,children:r,component:i}=n,{props:o,children:l,patchFlag:u}=e,d=i.emitsOptions;if(e.dirs||e.transition)return!0;if(t&&u>=0){if(u&1024)return!0;if(u&16)return s?M$(s,o,d):!!o;if(u&8){const h=e.dynamicProps;for(let f=0;f<h.length;f++){const m=h[f];if(o[m]!==s[m]&&!vf(d,m))return!0}}}else return(r||l)&&(!l||!l.$stable)?!0:s===o?!1:s?o?M$(s,o,d):!0:!!o;return!1}function M$(n,e,t){const s=Object.keys(e);if(s.length!==Object.keys(n).length)return!0;for(let r=0;r<s.length;r++){const i=s[r];if(e[i]!==n[i]&&!vf(t,i))return!0}return!1}function FF({vnode:n,parent:e},t){for(;e;){const s=e.subTree;if(s.suspense&&s.suspense.activeBranch===n&&(s.el=n.el),s===n)(n=e.vnode).el=t,e=e.parent;else break}}const UE=n=>n.__isSuspense;function zF(n,e){e&&e.pendingBranch?Rt(n)?e.effects.push(...n):e.effects.push(n):Y6(n)}const ci=Symbol.for("v-fgt"),$f=Symbol.for("v-txt"),Qo=Symbol.for("v-cmt"),yp=Symbol.for("v-stc"),Ec=[];let $r=null;function qi(n=!1){Ec.push($r=n?null:[])}function MF(){Ec.pop(),$r=Ec[Ec.length-1]||null}let Wc=1;function W$(n,e=!1){Wc+=n,n<0&&$r&&e&&($r.hasOnce=!0)}function GE(n){return n.dynamicChildren=Wc>0?$r||Jl:null,MF(),Wc>0&&$r&&$r.push(n),n}function Jo(n,e,t,s,r,i){return GE(Cs(n,e,t,s,r,i,!0))}function hy(n,e,t,s,r){return GE(rs(n,e,t,s,r,!0))}function Cp(n){return n?n.__v_isVNode===!0:!1}function uc(n,e){return n.type===e.type&&n.key===e.key}const qE=({key:n})=>n??null,bp=({ref:n,ref_key:e,ref_for:t})=>(typeof n=="number"&&(n=""+n),n!=null?Qn(n)||Ss(n)||Pt(n)?{i:fi,r:n,k:e,f:!!t}:n:null);function Cs(n,e=null,t=null,s=0,r=null,i=n===ci?0:1,o=!1,l=!1){const u={__v_isVNode:!0,__v_skip:!0,type:n,props:e,key:e&&qE(e),ref:e&&bp(e),scopeId:xE,slotScopeIds:null,children:t,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:i,patchFlag:s,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:fi};return l?(py(u,t),i&128&&n.normalize(u)):t&&(u.shapeFlag|=Qn(t)?8:16),Wc>0&&!o&&$r&&(u.patchFlag>0||i&6)&&u.patchFlag!==32&&$r.push(u),u}const rs=WF;function WF(n,e=null,t=null,s=0,r=null,i=!1){if((!n||n===uF)&&(n=Qo),Cp(n)){const l=pu(n,e,!0);return t&&py(l,t),Wc>0&&!i&&$r&&(l.shapeFlag&6?$r[$r.indexOf(n)]=l:$r.push(l)),l.patchFlag=-2,l}if(ez(n)&&(n=n.__vccOpts),e){e=BF(e);let{class:l,style:u}=e;l&&!Qn(l)&&(e.class=Du(l)),Dn(u)&&(oy(u)&&!Rt(u)&&(u=gs({},u)),e.style=ey(u))}const o=Qn(n)?1:UE(n)?128:Z6(n)?64:Dn(n)?4:Pt(n)?2:0;return Cs(n,e,t,s,r,o,i,!0)}function BF(n){return n?oy(n)||CE(n)?gs({},n):n:null}function pu(n,e,t=!1,s=!1){const{props:r,ref:i,patchFlag:o,children:l,transition:u}=n,d=e?GF(r||{},e):r,h={__v_isVNode:!0,__v_skip:!0,type:n.type,props:d,key:d&&qE(d),ref:e&&e.ref?t&&i?Rt(i)?i.concat(bp(e)):[i,bp(e)]:bp(e):i,scopeId:n.scopeId,slotScopeIds:n.slotScopeIds,children:l,target:n.target,targetStart:n.targetStart,targetAnchor:n.targetAnchor,staticCount:n.staticCount,shapeFlag:n.shapeFlag,patchFlag:e&&n.type!==ci?o===-1?16:o|16:o,dynamicProps:n.dynamicProps,dynamicChildren:n.dynamicChildren,appContext:n.appContext,dirs:n.dirs,transition:u,component:n.component,suspense:n.suspense,ssContent:n.ssContent&&pu(n.ssContent),ssFallback:n.ssFallback&&pu(n.ssFallback),el:n.el,anchor:n.anchor,ctx:n.ctx,ce:n.ce};return u&&s&&uy(h,u.clone(h)),h}function xp(n=" ",e=0){return rs($f,null,n,e)}function HF(n,e){const t=rs(yp,null,n);return t.staticCount=e,t}function UF(n="",e=!1){return e?(qi(),hy(Qo,null,n)):rs(Qo,null,n)}function Ci(n){return n==null||typeof n=="boolean"?rs(Qo):Rt(n)?rs(ci,null,n.slice()):Cp(n)?ka(n):rs($f,null,String(n))}function ka(n){return n.el===null&&n.patchFlag!==-1||n.memo?n:pu(n)}function py(n,e){let t=0;const{shapeFlag:s}=n;if(e==null)e=null;else if(Rt(e))t=16;else if(typeof e=="object")if(s&65){const r=e.default;r&&(r._c&&(r._d=!1),py(n,r()),r._c&&(r._d=!0));return}else{t=32;const r=e._;!r&&!CE(e)?e._ctx=fi:r===3&&fi&&(fi.slots._===1?e._=1:(e._=2,n.patchFlag|=1024))}else Pt(e)?(e={default:e,_ctx:fi},t=32):(e=String(e),s&64?(t=16,e=[xp(e)]):t=8);n.children=e,n.shapeFlag|=t}function GF(...n){const e={};for(let t=0;t<n.length;t++){const s=n[t];for(const r in s)if(r==="class")e.class!==s.class&&(e.class=Du([e.class,s.class]));else if(r==="style")e.style=ey([e.style,s.style]);else if(yf(r)){const i=e[r],o=s[r];o&&i!==o&&!(Rt(i)&&i.includes(o))&&(e[r]=i?[].concat(i,o):o)}else r!==""&&(e[r]=s[r])}return e}function _i(n,e,t,s=null){Gi(n,e,7,[t,s])}const qF=DE();let KF=0;function jF(n,e,t){const s=n.type,r=(e?e.appContext:n.appContext)||qF,i={uid:KF++,vnode:n,type:s,parent:e,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new b6(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:e?e.provides:Object.create(r.provides),ids:e?e.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:OE(s,r),emitsOptions:HE(s,r),emit:null,emitted:null,propsDefaults:bn,inheritAttrs:s.inheritAttrs,ctx:bn,data:bn,props:bn,attrs:bn,slots:bn,refs:bn,setupState:bn,setupContext:null,suspense:t,suspenseId:t?t.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return i.ctx={_:i},i.root=e?e.root:i,i.emit=OF.bind(null,i),n.ce&&n.ce(i),i}let Fs=null,Lp,H1;{const n=wf(),e=(t,s)=>{let r;return(r=n[t])||(r=n[t]=[]),r.push(s),i=>{r.length>1?r.forEach(o=>o(i)):r[0](i)}};Lp=e("__VUE_INSTANCE_SETTERS__",t=>Fs=t),H1=e("__VUE_SSR_SETTERS__",t=>Bc=t)}const ud=n=>{const e=Fs;return Lp(n),n.scope.on(),()=>{n.scope.off(),Lp(e)}},B$=()=>{Fs&&Fs.scope.off(),Lp(null)};function KE(n){return n.vnode.shapeFlag&4}let Bc=!1;function YF(n,e=!1,t=!1){e&&H1(e);const{props:s,children:r}=n.vnode,i=KE(n);xF(n,s,i,e),TF(n,r,t);const o=i?XF(n,e):void 0;return e&&H1(!1),o}function XF(n,e){const t=n.type;n.accessCache=Object.create(null),n.proxy=new Proxy(n.ctx,hF);const{setup:s}=t;if(s){no();const r=n.setupContext=s.length>1?QF(n):null,i=ud(n),o=ld(s,n,0,[n.props,r]),l=HD(o);if(so(),i(),(l||n.sp)&&!_c(n)&&NE(n),l){if(o.then(B$,B$),e)return o.then(u=>{H$(n,u,e)}).catch(u=>{Tf(u,n,0)});n.asyncDep=o}else H$(n,o,e)}else jE(n,e)}function H$(n,e,t){Pt(e)?n.type.__ssrInlineRender?n.ssrRender=e:n.render=e:Dn(e)&&(n.setupState=fE(e)),jE(n,t)}let U$;function jE(n,e,t){const s=n.type;if(!n.render){if(!e&&U$&&!s.render){const r=s.template||cy(n).template;if(r){const{isCustomElement:i,compilerOptions:o}=n.appContext.config,{delimiters:l,compilerOptions:u}=s,d=gs(gs({isCustomElement:i,delimiters:l},o),u);s.render=U$(r,d)}}n.render=s.render||mi}{const r=ud(n);no();try{pF(n)}finally{so(),r()}}}const ZF={get(n,e){return Os(n,"get",""),n[e]}};function QF(n){const e=t=>{n.exposed=t||{}};return{attrs:new Proxy(n.attrs,ZF),slots:n.slots,emit:n.emit,expose:e}}function fy(n){return n.exposed?n.exposeProxy||(n.exposeProxy=new Proxy(fE(z6(n.exposed)),{get(e,t){if(t in e)return e[t];if(t in Dc)return Dc[t](n)},has(e,t){return t in e||t in Dc}})):n.proxy}function JF(n,e=!0){return Pt(n)?n.displayName||n.name:n.name||e&&n.__name}function ez(n){return Pt(n)&&"__vccOpts"in n}const pi=(n,e)=>U6(n,e,Bc);function YE(n,e,t){const s=arguments.length;return s===2?Dn(e)&&!Rt(e)?Cp(e)?rs(n,null,[e]):rs(n,e):rs(n,null,e):(s>3?t=Array.prototype.slice.call(arguments,2):s===3&&Cp(t)&&(t=[t]),rs(n,e,t))}const tz="3.5.13";/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let U1;const G$=typeof window<"u"&&window.trustedTypes;if(G$)try{U1=G$.createPolicy("vue",{createHTML:n=>n})}catch{}const XE=U1?n=>U1.createHTML(n):n=>n,nz="http://www.w3.org/2000/svg",sz="http://www.w3.org/1998/Math/MathML",sa=typeof document<"u"?document:null,q$=sa&&sa.createElement("template"),rz={insert:(n,e,t)=>{e.insertBefore(n,t||null)},remove:n=>{const e=n.parentNode;e&&e.removeChild(n)},createElement:(n,e,t,s)=>{const r=e==="svg"?sa.createElementNS(nz,n):e==="mathml"?sa.createElementNS(sz,n):t?sa.createElement(n,{is:t}):sa.createElement(n);return n==="select"&&s&&s.multiple!=null&&r.setAttribute("multiple",s.multiple),r},createText:n=>sa.createTextNode(n),createComment:n=>sa.createComment(n),setText:(n,e)=>{n.nodeValue=e},setElementText:(n,e)=>{n.textContent=e},parentNode:n=>n.parentNode,nextSibling:n=>n.nextSibling,querySelector:n=>sa.querySelector(n),setScopeId(n,e){n.setAttribute(e,"")},insertStaticContent(n,e,t,s,r,i){const o=t?t.previousSibling:e.lastChild;if(r&&(r===i||r.nextSibling))for(;e.insertBefore(r.cloneNode(!0),t),!(r===i||!(r=r.nextSibling)););else{q$.innerHTML=XE(s==="svg"?`<svg>${n}</svg>`:s==="mathml"?`<math>${n}</math>`:n);const l=q$.content;if(s==="svg"||s==="mathml"){const u=l.firstChild;for(;u.firstChild;)l.appendChild(u.firstChild);l.removeChild(u)}e.insertBefore(l,t)}return[o?o.nextSibling:e.firstChild,t?t.previousSibling:e.lastChild]}},iz=Symbol("_vtc");function az(n,e,t){const s=n[iz];s&&(e=(e?[e,...s]:[...s]).join(" ")),e==null?n.removeAttribute("class"):t?n.setAttribute("class",e):n.className=e}const K$=Symbol("_vod"),oz=Symbol("_vsh"),lz=Symbol(""),uz=/(^|;)\s*display\s*:/;function cz(n,e,t){const s=n.style,r=Qn(t);let i=!1;if(t&&!r){if(e)if(Qn(e))for(const o of e.split(";")){const l=o.slice(0,o.indexOf(":")).trim();t[l]==null&&Np(s,l,"")}else for(const o in e)t[o]==null&&Np(s,o,"");for(const o in t)o==="display"&&(i=!0),Np(s,o,t[o])}else if(r){if(e!==t){const o=s[lz];o&&(t+=";"+o),s.cssText=t,i=uz.test(t)}}else e&&n.removeAttribute("style");K$ in n&&(n[K$]=i?s.display:"",n[oz]&&(s.display="none"))}const j$=/\s*!important$/;function Np(n,e,t){if(Rt(t))t.forEach(s=>Np(n,e,s));else if(t==null&&(t=""),e.startsWith("--"))n.setProperty(e,t);else{const s=dz(n,e);j$.test(t)?n.setProperty(gl(s),t.replace(j$,""),"important"):n[s]=t}}const Y$=["Webkit","Moz","ms"],a1={};function dz(n,e){const t=a1[e];if(t)return t;let s=Xr(e);if(s!=="filter"&&s in n)return a1[e]=s;s=Nf(s);for(let r=0;r<Y$.length;r++){const i=Y$[r]+s;if(i in n)return a1[e]=i}return e}const X$="http://www.w3.org/1999/xlink";function Z$(n,e,t,s,r,i=y6(e)){s&&e.startsWith("xlink:")?t==null?n.removeAttributeNS(X$,e.slice(6,e.length)):n.setAttributeNS(X$,e,t):t==null||i&&!KD(t)?n.removeAttribute(e):n.setAttribute(e,i?"":to(t)?String(t):t)}function Q$(n,e,t,s,r){if(e==="innerHTML"||e==="textContent"){t!=null&&(n[e]=e==="innerHTML"?XE(t):t);return}const i=n.tagName;if(e==="value"&&i!=="PROGRESS"&&!i.includes("-")){const l=i==="OPTION"?n.getAttribute("value")||"":n.value,u=t==null?n.type==="checkbox"?"on":"":String(t);(l!==u||!("_value"in n))&&(n.value=u),t==null&&n.removeAttribute(e),n._value=t;return}let o=!1;if(t===""||t==null){const l=typeof n[e];l==="boolean"?t=KD(t):t==null&&l==="string"?(t="",o=!0):l==="number"&&(t=0,o=!0)}try{n[e]=t}catch{}o&&n.removeAttribute(r||e)}function hz(n,e,t,s){n.addEventListener(e,t,s)}function pz(n,e,t,s){n.removeEventListener(e,t,s)}const J$=Symbol("_vei");function fz(n,e,t,s,r=null){const i=n[J$]||(n[J$]={}),o=i[e];if(s&&o)o.value=s;else{const[l,u]=mz(e);if(s){const d=i[e]=yz(s,r);hz(n,l,d,u)}else o&&(pz(n,l,o,u),i[e]=void 0)}}const e_=/(?:Once|Passive|Capture)$/;function mz(n){let e;if(e_.test(n)){e={};let s;for(;s=n.match(e_);)n=n.slice(0,n.length-s[0].length),e[s[0].toLowerCase()]=!0}return[n[2]===":"?n.slice(3):gl(n.slice(2)),e]}let o1=0;const gz=Promise.resolve(),Iz=()=>o1||(gz.then(()=>o1=0),o1=Date.now());function yz(n,e){const t=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=t.attached)return;Gi(bz(s,t.value),e,5,[s])};return t.value=n,t.attached=Iz(),t}function bz(n,e){if(Rt(e)){const t=n.stopImmediatePropagation;return n.stopImmediatePropagation=()=>{t.call(n),n._stopped=!0},e.map(s=>r=>!r._stopped&&s&&s(r))}else return e}const t_=n=>n.charCodeAt(0)===111&&n.charCodeAt(1)===110&&n.charCodeAt(2)>96&&n.charCodeAt(2)<123,xz=(n,e,t,s,r,i)=>{const o=r==="svg";e==="class"?az(n,s,o):e==="style"?cz(n,t,s):yf(e)?ZI(e)||fz(n,e,t,s,i):(e[0]==="."?(e=e.slice(1),!0):e[0]==="^"?(e=e.slice(1),!1):Nz(n,e,s,o))?(Q$(n,e,s),!n.tagName.includes("-")&&(e==="value"||e==="checked"||e==="selected")&&Z$(n,e,s,o,i,e!=="value")):n._isVueCE&&(/[A-Z]/.test(e)||!Qn(s))?Q$(n,Xr(e),s,i,e):(e==="true-value"?n._trueValue=s:e==="false-value"&&(n._falseValue=s),Z$(n,e,s,o))};function Nz(n,e,t,s){if(s)return!!(e==="innerHTML"||e==="textContent"||e in n&&t_(e)&&Pt(t));if(e==="spellcheck"||e==="draggable"||e==="translate"||e==="form"||e==="list"&&n.tagName==="INPUT"||e==="type"&&n.tagName==="TEXTAREA")return!1;if(e==="width"||e==="height"){const r=n.tagName;if(r==="IMG"||r==="VIDEO"||r==="CANVAS"||r==="SOURCE")return!1}return t_(e)&&Qn(t)?!1:e in n}const wz=gs({patchProp:xz},rz);let n_;function Az(){return n_||(n_=vF(wz))}const Tz=(...n)=>{const e=Az().createApp(...n),{mount:t}=e;return e.mount=s=>{const r=vz(s);if(!r)return;const i=e._component;!Pt(i)&&!i.render&&!i.template&&(i.template=r.innerHTML),r.nodeType===1&&(r.textContent="");const o=t(r,!1,Sz(r));return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),o},e};function Sz(n){if(n instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&n instanceof MathMLElement)return"mathml"}function vz(n){return Qn(n)?document.querySelector(n):n}const $z={class:"promotion-dialog",open:""},_z=["aria-label","onClick","onTouchstartPassive"],Dz=Il({__name:"PromotionDialog",props:{state:{}},emits:["promotionSelected"],setup(n,{emit:e}){const t=n,s=e,r=[{name:"Queen",data:"q"},{name:"Knight",data:"n"},{name:"Rook",data:"r"},{name:"Bishop",data:"b"}];function i(o){var l,u;(u=(l=t.state).callback)==null||u.call(l,o.data),s("promotionSelected")}return(o,l)=>(qi(),Jo("dialog",$z,[(qi(),Jo(ci,null,dF(r,u=>Cs("button",{key:u.name,type:"button",class:Du([u.name.toLowerCase(),o.state.color]),"aria-label":u.name,onClick:d=>i(u),onTouchstartPassive:d=>i(u)},null,42,_z)),64))]))}});var zi=8,Sr=8,jo=zi*Sr,s_=16,Va=-1,Op=10,Rp=20,ps=40,Ei=60,Xl=60,Zl=120,r_=120,i_=120,Ca=120,a_=60,o_=40,l_=10,u_=120,c_=30,d_=120,h_=30,p_=120,Ez=2,a;(function(n){n[n.NORTH=0]="NORTH",n[n.NORTHEAST=1]="NORTHEAST",n[n.EAST=2]="EAST",n[n.SOUTHEAST=3]="SOUTHEAST",n[n.SOUTH=4]="SOUTH",n[n.SOUTHWEST=5]="SOUTHWEST",n[n.WEST=6]="WEST",n[n.NORTHWEST=7]="NORTHWEST",n[n.INVALID=8]="INVALID"})(a||(a={}));var f_=[a.NORTHEAST,a.SOUTHEAST,a.SOUTHWEST,a.NORTHWEST],m_=[a.NORTH,a.EAST,a.SOUTH,a.WEST],g_=4;function I_(n){switch(n){case M.P1_KING:return"K";case M.P1_MAGE:return"M";case M.P1_PAWN:return"P";case M.P1_WARRIOR:return"W";case M.P1_ASSASSIN:return"A";case M.P1_KNIGHT:return"N";case M.P2_KING:return"k";case M.P2_MAGE:return"m";case M.P2_PAWN:return"p";case M.P2_WARRIOR:return"w";case M.P2_ASSASSIN:return"a";case M.P2_KNIGHT:return"n";case M.NO_PIECE:return".";default:return"default"}}function St(n,e){switch(n){case M.P1_KING:return e===Re.PLAYER_1;case M.P1_MAGE:return e===Re.PLAYER_1;case M.P1_PAWN:return e===Re.PLAYER_1;case M.P1_WARRIOR:return e===Re.PLAYER_1;case M.P1_ASSASSIN:return e===Re.PLAYER_1;case M.P1_KNIGHT:return e===Re.PLAYER_1;case M.P2_KING:return e===Re.PLAYER_2;case M.P2_MAGE:return e===Re.PLAYER_2;case M.P2_PAWN:return e===Re.PLAYER_2;case M.P2_WARRIOR:return e===Re.PLAYER_2;case M.P2_ASSASSIN:return e===Re.PLAYER_2;case M.P2_KNIGHT:return e===Re.PLAYER_2;case M.NO_PIECE:return!1;default:return!1}}function y_(n){return n<0||n>jo-1}var nt=function(){function n(){}return n.squareToNeighboringSquares=[[8,1,9],[0,8,9,2,10],[1,9,10,3,11],[2,10,11,4,12],[3,11,12,5,13],[4,12,13,6,14],[5,13,14,7,15],[6,14,15],[0,16,1,9,17],[0,8,16,1,17,2,10,18],[1,9,17,2,18,3,11,19],[2,10,18,3,19,4,12,20],[3,11,19,4,20,5,13,21],[4,12,20,5,21,6,14,22],[5,13,21,6,22,7,15,23],[6,14,22,7,23],[8,24,9,17,25],[8,16,24,9,25,10,18,26],[9,17,25,10,26,11,19,27],[10,18,26,11,27,12,20,28],[11,19,27,12,28,13,21,29],[12,20,28,13,29,14,22,30],[13,21,29,14,30,15,23,31],[14,22,30,15,31],[16,32,17,25,33],[16,24,32,17,33,18,26,34],[17,25,33,18,34,19,27,35],[18,26,34,19,35,20,28,36],[19,27,35,20,36,21,29,37],[20,28,36,21,37,22,30,38],[21,29,37,22,38,23,31,39],[22,30,38,23,39],[24,40,25,33,41],[24,32,40,25,41,26,34,42],[25,33,41,26,42,27,35,43],[26,34,42,27,43,28,36,44],[27,35,43,28,44,29,37,45],[28,36,44,29,45,30,38,46],[29,37,45,30,46,31,39,47],[30,38,46,31,47],[32,48,33,41,49],[32,40,48,33,49,34,42,50],[33,41,49,34,50,35,43,51],[34,42,50,35,51,36,44,52],[35,43,51,36,52,37,45,53],[36,44,52,37,53,38,46,54],[37,45,53,38,54,39,47,55],[38,46,54,39,55],[40,56,41,49,57],[40,48,56,41,57,42,50,58],[41,49,57,42,58,43,51,59],[42,50,58,43,59,44,52,60],[43,51,59,44,60,45,53,61],[44,52,60,45,61,46,54,62],[45,53,61,46,62,47,55,63],[46,54,62,47,63],[48,49,57],[48,56,49,50,58],[49,57,50,51,59],[50,58,51,52,60],[51,59,52,53,61],[52,60,53,54,62],[53,61,54,55,63],[54,62,55]],n.squareToNeighboringNonDiagonalSquares=[[8,1],[0,9,2],[1,10,3],[2,11,4],[3,12,5],[4,13,6],[5,14,7],[6,15],[0,16,9],[8,1,17,10],[9,2,18,11],[10,3,19,12],[11,4,20,13],[12,5,21,14],[13,6,22,15],[14,7,23],[8,24,17],[16,9,25,18],[17,10,26,19],[18,11,27,20],[19,12,28,21],[20,13,29,22],[21,14,30,23],[22,15,31],[16,32,25],[24,17,33,26],[25,18,34,27],[26,19,35,28],[27,20,36,29],[28,21,37,30],[29,22,38,31],[30,23,39],[24,40,33],[32,25,41,34],[33,26,42,35],[34,27,43,36],[35,28,44,37],[36,29,45,38],[37,30,46,39],[38,31,47],[32,48,41],[40,33,49,42],[41,34,50,43],[42,35,51,44],[43,36,52,45],[44,37,53,46],[45,38,54,47],[46,39,55],[40,56,49],[48,41,57,50],[49,42,58,51],[50,43,59,52],[51,44,60,53],[52,45,61,54],[53,46,62,55],[54,47,63],[48,57],[56,49,58],[57,50,59],[58,51,60],[59,52,61],[60,53,62],[61,54,63],[62,55]],n.squareToDirectionToLine=[[[8,16,24,32,40,48,56],[9,18,27,36,45,54,63],[1,2,3,4,5,6,7],[],[],[],[],[],[]],[[9,17,25,33,41,49,57],[10,19,28,37,46,55],[2,3,4,5,6,7],[],[],[],[0],[8],[]],[[10,18,26,34,42,50,58],[11,20,29,38,47],[3,4,5,6,7],[],[],[],[1,0],[9,16],[]],[[11,19,27,35,43,51,59],[12,21,30,39],[4,5,6,7],[],[],[],[2,1,0],[10,17,24],[]],[[12,20,28,36,44,52,60],[13,22,31],[5,6,7],[],[],[],[3,2,1,0],[11,18,25,32],[]],[[13,21,29,37,45,53,61],[14,23],[6,7],[],[],[],[4,3,2,1,0],[12,19,26,33,40],[]],[[14,22,30,38,46,54,62],[15],[7],[],[],[],[5,4,3,2,1,0],[13,20,27,34,41,48],[]],[[15,23,31,39,47,55,63],[],[],[],[],[],[6,5,4,3,2,1,0],[14,21,28,35,42,49,56],[]],[[16,24,32,40,48,56],[17,26,35,44,53,62],[9,10,11,12,13,14,15],[1],[0],[],[],[],[]],[[17,25,33,41,49,57],[18,27,36,45,54,63],[10,11,12,13,14,15],[2],[1],[0],[8],[16],[]],[[18,26,34,42,50,58],[19,28,37,46,55],[11,12,13,14,15],[3],[2],[1],[9,8],[17,24],[]],[[19,27,35,43,51,59],[20,29,38,47],[12,13,14,15],[4],[3],[2],[10,9,8],[18,25,32],[]],[[20,28,36,44,52,60],[21,30,39],[13,14,15],[5],[4],[3],[11,10,9,8],[19,26,33,40],[]],[[21,29,37,45,53,61],[22,31],[14,15],[6],[5],[4],[12,11,10,9,8],[20,27,34,41,48],[]],[[22,30,38,46,54,62],[23],[15],[7],[6],[5],[13,12,11,10,9,8],[21,28,35,42,49,56],[]],[[23,31,39,47,55,63],[],[],[],[7],[6],[14,13,12,11,10,9,8],[22,29,36,43,50,57],[]],[[24,32,40,48,56],[25,34,43,52,61],[17,18,19,20,21,22,23],[9,2],[8,0],[],[],[],[]],[[25,33,41,49,57],[26,35,44,53,62],[18,19,20,21,22,23],[10,3],[9,1],[8],[16],[24],[]],[[26,34,42,50,58],[27,36,45,54,63],[19,20,21,22,23],[11,4],[10,2],[9,0],[17,16],[25,32],[]],[[27,35,43,51,59],[28,37,46,55],[20,21,22,23],[12,5],[11,3],[10,1],[18,17,16],[26,33,40],[]],[[28,36,44,52,60],[29,38,47],[21,22,23],[13,6],[12,4],[11,2],[19,18,17,16],[27,34,41,48],[]],[[29,37,45,53,61],[30,39],[22,23],[14,7],[13,5],[12,3],[20,19,18,17,16],[28,35,42,49,56],[]],[[30,38,46,54,62],[31],[23],[15],[14,6],[13,4],[21,20,19,18,17,16],[29,36,43,50,57],[]],[[31,39,47,55,63],[],[],[],[15,7],[14,5],[22,21,20,19,18,17,16],[30,37,44,51,58],[]],[[32,40,48,56],[33,42,51,60],[25,26,27,28,29,30,31],[17,10,3],[16,8,0],[],[],[],[]],[[33,41,49,57],[34,43,52,61],[26,27,28,29,30,31],[18,11,4],[17,9,1],[16],[24],[32],[]],[[34,42,50,58],[35,44,53,62],[27,28,29,30,31],[19,12,5],[18,10,2],[17,8],[25,24],[33,40],[]],[[35,43,51,59],[36,45,54,63],[28,29,30,31],[20,13,6],[19,11,3],[18,9,0],[26,25,24],[34,41,48],[]],[[36,44,52,60],[37,46,55],[29,30,31],[21,14,7],[20,12,4],[19,10,1],[27,26,25,24],[35,42,49,56],[]],[[37,45,53,61],[38,47],[30,31],[22,15],[21,13,5],[20,11,2],[28,27,26,25,24],[36,43,50,57],[]],[[38,46,54,62],[39],[31],[23],[22,14,6],[21,12,3],[29,28,27,26,25,24],[37,44,51,58],[]],[[39,47,55,63],[],[],[],[23,15,7],[22,13,4],[30,29,28,27,26,25,24],[38,45,52,59],[]],[[40,48,56],[41,50,59],[33,34,35,36,37,38,39],[25,18,11,4],[24,16,8,0],[],[],[],[]],[[41,49,57],[42,51,60],[34,35,36,37,38,39],[26,19,12,5],[25,17,9,1],[24],[32],[40],[]],[[42,50,58],[43,52,61],[35,36,37,38,39],[27,20,13,6],[26,18,10,2],[25,16],[33,32],[41,48],[]],[[43,51,59],[44,53,62],[36,37,38,39],[28,21,14,7],[27,19,11,3],[26,17,8],[34,33,32],[42,49,56],[]],[[44,52,60],[45,54,63],[37,38,39],[29,22,15],[28,20,12,4],[27,18,9,0],[35,34,33,32],[43,50,57],[]],[[45,53,61],[46,55],[38,39],[30,23],[29,21,13,5],[28,19,10,1],[36,35,34,33,32],[44,51,58],[]],[[46,54,62],[47],[39],[31],[30,22,14,6],[29,20,11,2],[37,36,35,34,33,32],[45,52,59],[]],[[47,55,63],[],[],[],[31,23,15,7],[30,21,12,3],[38,37,36,35,34,33,32],[46,53,60],[]],[[48,56],[49,58],[41,42,43,44,45,46,47],[33,26,19,12,5],[32,24,16,8,0],[],[],[],[]],[[49,57],[50,59],[42,43,44,45,46,47],[34,27,20,13,6],[33,25,17,9,1],[32],[40],[48],[]],[[50,58],[51,60],[43,44,45,46,47],[35,28,21,14,7],[34,26,18,10,2],[33,24],[41,40],[49,56],[]],[[51,59],[52,61],[44,45,46,47],[36,29,22,15],[35,27,19,11,3],[34,25,16],[42,41,40],[50,57],[]],[[52,60],[53,62],[45,46,47],[37,30,23],[36,28,20,12,4],[35,26,17,8],[43,42,41,40],[51,58],[]],[[53,61],[54,63],[46,47],[38,31],[37,29,21,13,5],[36,27,18,9,0],[44,43,42,41,40],[52,59],[]],[[54,62],[55],[47],[39],[38,30,22,14,6],[37,28,19,10,1],[45,44,43,42,41,40],[53,60],[]],[[55,63],[],[],[],[39,31,23,15,7],[38,29,20,11,2],[46,45,44,43,42,41,40],[54,61],[]],[[56],[57],[49,50,51,52,53,54,55],[41,34,27,20,13,6],[40,32,24,16,8,0],[],[],[],[]],[[57],[58],[50,51,52,53,54,55],[42,35,28,21,14,7],[41,33,25,17,9,1],[40],[48],[56],[]],[[58],[59],[51,52,53,54,55],[43,36,29,22,15],[42,34,26,18,10,2],[41,32],[49,48],[57],[]],[[59],[60],[52,53,54,55],[44,37,30,23],[43,35,27,19,11,3],[42,33,24],[50,49,48],[58],[]],[[60],[61],[53,54,55],[45,38,31],[44,36,28,20,12,4],[43,34,25,16],[51,50,49,48],[59],[]],[[61],[62],[54,55],[46,39],[45,37,29,21,13,5],[44,35,26,17,8],[52,51,50,49,48],[60],[]],[[62],[63],[55],[47],[46,38,30,22,14,6],[45,36,27,18,9,0],[53,52,51,50,49,48],[61],[]],[[63],[],[],[],[47,39,31,23,15,7],[46,37,28,19,10,1],[54,53,52,51,50,49,48],[62],[]],[[],[],[57,58,59,60,61,62,63],[49,42,35,28,21,14,7],[48,40,32,24,16,8,0],[],[],[],[]],[[],[],[58,59,60,61,62,63],[50,43,36,29,22,15],[49,41,33,25,17,9,1],[48],[56],[],[]],[[],[],[59,60,61,62,63],[51,44,37,30,23],[50,42,34,26,18,10,2],[49,40],[57,56],[],[]],[[],[],[60,61,62,63],[52,45,38,31],[51,43,35,27,19,11,3],[50,41,32],[58,57,56],[],[]],[[],[],[61,62,63],[53,46,39],[52,44,36,28,20,12,4],[51,42,33,24],[59,58,57,56],[],[]],[[],[],[62,63],[54,47],[53,45,37,29,21,13,5],[52,43,34,25,16],[60,59,58,57,56],[],[]],[[],[],[63],[55],[54,46,38,30,22,14,6],[53,44,35,26,17,8],[61,60,59,58,57,56],[],[]],[[],[],[],[],[55,47,39,31,23,15,7],[54,45,36,27,18,9,0],[62,61,60,59,58,57,56],[],[]]],n.srcSquareToDstSquareToDirection=[[a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST],[a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID],[a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID],[a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID],[a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH],[a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID],[a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST],[a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH],[a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID],[a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID],[a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST],[a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH],[a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID],[a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHEAST],[a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.INVALID,a.NORTH],[a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST,a.INVALID],[a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.NORTHEAST],[a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.INVALID,a.NORTH],[a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST,a.INVALID],[a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID,a.NORTHEAST],[a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH,a.INVALID],[a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.INVALID,a.NORTH],[a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID,a.INVALID],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST,a.INVALID],[a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH,a.NORTHEAST],[a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.NORTHWEST,a.NORTH],[a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST],[a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST],[a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST,a.EAST],[a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHEAST,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST,a.EAST],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST,a.EAST],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHEAST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.INVALID,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST,a.EAST],[a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.SOUTHEAST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID,a.EAST],[a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.INVALID,a.SOUTH,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.INVALID,a.SOUTHWEST,a.SOUTH,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.WEST,a.INVALID]],n.squareToKnightActionSquares=[[10,17],[11,16,18],[12,8,17,19],[13,9,18,20],[14,10,19,21],[15,11,20,22],[12,21,23],[13,22],[18,2,25],[19,3,24,26],[20,4,0,16,25,27],[21,5,1,17,26,28],[22,6,2,18,27,29],[23,7,3,19,28,30],[4,20,29,31],[5,21,30],[26,10,1,33],[27,11,2,0,32,34],[28,12,3,1,8,24,33,35],[29,13,4,2,9,25,34,36],[30,14,5,3,10,26,35,37],[31,15,6,4,11,27,36,38],[7,5,12,28,37,39],[6,13,29,38],[34,18,9,41],[35,19,10,8,40,42],[36,20,11,9,16,32,41,43],[37,21,12,10,17,33,42,44],[38,22,13,11,18,34,43,45],[39,23,14,12,19,35,44,46],[15,13,20,36,45,47],[14,21,37,46],[42,26,17,49],[43,27,18,16,48,50],[44,28,19,17,24,40,49,51],[45,29,20,18,25,41,50,52],[46,30,21,19,26,42,51,53],[47,31,22,20,27,43,52,54],[23,21,28,44,53,55],[22,29,45,54],[50,34,25,57],[51,35,26,24,56,58],[52,36,27,25,32,48,57,59],[53,37,28,26,33,49,58,60],[54,38,29,27,34,50,59,61],[55,39,30,28,35,51,60,62],[31,29,36,52,61,63],[30,37,53,62],[58,42,33],[59,43,34,32],[60,44,35,33,40,56],[61,45,36,34,41,57],[62,46,37,35,42,58],[63,47,38,36,43,59],[39,37,44,60],[38,45,61],[50,41],[51,42,40],[52,43,41,48],[53,44,42,49],[54,45,43,50],[55,46,44,51],[47,45,52],[46,53]],n.squareToP1PawnMoveSquares=[[8],[9],[10],[11],[12],[13],[14],[15],[16,24],[17,25],[18,26],[19,27],[20,28],[21,29],[22,30],[23,31],[24],[25],[26],[27],[28],[29],[30],[31],[32],[33],[34],[35],[36],[37],[38],[39],[40],[41],[42],[43],[44],[45],[46],[47],[48],[49],[50],[51],[52],[53],[54],[55],[56],[57],[58],[59],[60],[61],[62],[63],[],[],[],[],[],[],[],[]],n.squareToP2PawnMoveSquares=[[],[],[],[],[],[],[],[],[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18],[19],[20],[21],[22],[23],[24],[25],[26],[27],[28],[29],[30],[31],[32],[33],[34],[35],[36],[37],[38],[39],[40,32],[41,33],[42,34],[43,35],[44,36],[45,37],[46,38],[47,39],[48],[49],[50],[51],[52],[53],[54],[55]],n.squareToP1PawnAbilitySquares=[[9],[8,10],[9,11],[10,12],[11,13],[12,14],[13,15],[14],[17],[16,18],[17,19],[18,20],[19,21],[20,22],[21,23],[22],[25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30],[33],[32,34],[33,35],[34,36],[35,37],[36,38],[37,39],[38],[41],[40,42],[41,43],[42,44],[43,45],[44,46],[45,47],[46],[49],[48,50],[49,51],[50,52],[51,53],[52,54],[53,55],[54],[57],[56,58],[57,59],[58,60],[59,61],[60,62],[61,63],[62],[],[],[],[],[],[],[],[]],n.squareToP2PawnAbilitySquares=[[],[],[],[],[],[],[],[],[1],[0,2],[1,3],[2,4],[3,5],[4,6],[5,7],[6],[9],[8,10],[9,11],[10,12],[11,13],[12,14],[13,15],[14],[17],[16,18],[17,19],[18,20],[19,21],[20,22],[21,23],[22],[25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30],[33],[32,34],[33,35],[34,36],[35,37],[36,38],[37,39],[38],[41],[40,42],[41,43],[42,44],[43,45],[44,46],[45,47],[46],[49],[48,50],[49,51],[50,52],[51,53],[52,54],[53,55],[54]],n}(),Re;(function(n){n[n.PLAYER_1=0]="PLAYER_1",n[n.PLAYER_2=1]="PLAYER_2"})(Re||(Re={}));var M;(function(n){n[n.P1_KING=0]="P1_KING",n[n.P1_MAGE=1]="P1_MAGE",n[n.P1_WARRIOR=2]="P1_WARRIOR",n[n.P1_ASSASSIN=3]="P1_ASSASSIN",n[n.P1_KNIGHT=4]="P1_KNIGHT",n[n.P1_PAWN=5]="P1_PAWN",n[n.P2_KING=6]="P2_KING",n[n.P2_MAGE=7]="P2_MAGE",n[n.P2_WARRIOR=8]="P2_WARRIOR",n[n.P2_ASSASSIN=9]="P2_ASSASSIN",n[n.P2_KNIGHT=10]="P2_KNIGHT",n[n.P2_PAWN=11]="P2_PAWN",n[n.NO_PIECE=12]="NO_PIECE"})(M||(M={}));var le;(function(n){n[n.MOVE_REGULAR=0]="MOVE_REGULAR",n[n.MOVE_CASTLE=1]="MOVE_CASTLE",n[n.MOVE_PROMOTE_P1_PAWN=2]="MOVE_PROMOTE_P1_PAWN",n[n.MOVE_PROMOTE_P2_PAWN=3]="MOVE_PROMOTE_P2_PAWN",n[n.ABILITY_KING_DAMAGE=4]="ABILITY_KING_DAMAGE",n[n.ABILITY_MAGE_DAMAGE=5]="ABILITY_MAGE_DAMAGE",n[n.ABILITY_P1_PAWN_DAMAGE_AND_PROMOTION=6]="ABILITY_P1_PAWN_DAMAGE_AND_PROMOTION",n[n.ABILITY_P2_PAWN_DAMAGE_AND_PROMOTION=7]="ABILITY_P2_PAWN_DAMAGE_AND_PROMOTION",n[n.ABILITY_KNIGHT_THROW_PAWN=8]="ABILITY_KNIGHT_THROW_PAWN",n[n.ABILITY_MAGE_THROW_ASSASSIN=9]="ABILITY_MAGE_THROW_ASSASSIN",n[n.ABILITY_WARRIOR_DAMAGE=10]="ABILITY_WARRIOR_DAMAGE",n[n.ABILITY_ASSASSIN_DAMAGE=11]="ABILITY_ASSASSIN_DAMAGE",n[n.ABILITY_KNIGHT_DAMAGE=12]="ABILITY_KNIGHT_DAMAGE",n[n.ABILITY_PAWN_DAMAGE=13]="ABILITY_PAWN_DAMAGE",n[n.ABILITY_WARRIOR_THROW_WARRIOR=14]="ABILITY_WARRIOR_THROW_WARRIOR",n[n.SKIP=15]="SKIP"})(le||(le={}));var $e=function(){function n(e){e.other===void 0?(this.type=e.type,this.healthPoints=e.healthPoints,this.squareIndex=e.squareIndex):(this.type=e.other.type,this.healthPoints=e.other.healthPoints,this.squareIndex=e.other.squareIndex)}return n}(),Le=function(){function n(e,t,s){this.srcIdx=e,this.dstIdx=t,this.actionType=s}return n}(),kz=function(){function n(){this.affectedPieces=new Array}return n}(),kc=function(){function n(e){if(this.board=new Array,this.playerToPieces=new Array,this.playerToKing=new Array(Ez),e.encodedBoard!==void 0)this.boardFromString(e.encodedBoard);else if(e.other!==void 0){this.moveNumber=e.other.moveNumber,this.currentPlayer=e.other.currentPlayer;for(var t=0;t<jo;t++)this.board[t]=new $e({other:e.other.board[t]});for(var s=e.other.playerToPieces[Re.PLAYER_1],r=new Array,t=0;t<s.length;t++){var i=s[t];i.healthPoints>0?r.push(this.board[i.squareIndex]):r.push(new $e({type:i.type,healthPoints:i.healthPoints,squareIndex:i.squareIndex}))}var o=e.other.playerToKing[Re.PLAYER_1];this.playerToKing[Re.PLAYER_1]=this.board[o.squareIndex],this.playerToPieces[Re.PLAYER_1]=r;for(var l=e.other.playerToPieces[Re.PLAYER_2],u=new Array,t=0;t<l.length;t++){var i=l[t];i.healthPoints>0?u.push(this.board[i.squareIndex]):u.push(new $e({type:i.type,healthPoints:i.healthPoints,squareIndex:i.squareIndex}))}var d=e.other.playerToKing[Re.PLAYER_2];this.playerToKing[Re.PLAYER_2]=this.board[d.squareIndex],this.playerToPieces[Re.PLAYER_2]=u}else this.reset()}return n.prototype.makeMove=function(e){if(e.actionType==le.MOVE_REGULAR)this.board[e.dstIdx]=this.board[e.srcIdx],this.board[e.dstIdx].squareIndex=e.dstIdx,this.board[e.srcIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.srcIdx});else{if(e.actionType==le.SKIP)return;this.board[e.dstIdx]=this.board[e.srcIdx],this.board[e.dstIdx].squareIndex=e.dstIdx,this.board[e.srcIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.srcIdx}),e.dstIdx==6?(this.board[5]=this.board[7],this.board[5].squareIndex=5,this.board[7]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:7})):e.dstIdx==2?(this.board[3]=this.board[0],this.board[3].squareIndex=3,this.board[0]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:0})):e.dstIdx==62?(this.board[61]=this.board[63],this.board[61].squareIndex=61,this.board[63]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:63})):(this.board[59]=this.board[56],this.board[59].squareIndex=59,this.board[56]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:56}));return}},n.prototype.undoMove=function(e){if(e.actionType==le.MOVE_REGULAR)this.board[e.srcIdx]=this.board[e.dstIdx],this.board[e.srcIdx].squareIndex=e.srcIdx,this.board[e.dstIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.dstIdx});else{if(e.actionType==le.SKIP)return;this.board[e.srcIdx]=this.board[e.dstIdx],this.board[e.srcIdx].squareIndex=e.srcIdx,this.board[e.dstIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.dstIdx}),e.dstIdx==6?(this.board[7]=this.board[5],this.board[7].squareIndex=7,this.board[5]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:5})):e.dstIdx==2?(this.board[0]=this.board[3],this.board[0].squareIndex=0,this.board[3]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:3})):e.dstIdx==62?(this.board[63]=this.board[61],this.board[63].squareIndex=63,this.board[61]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:61})):e.dstIdx==58&&(this.board[56]=this.board[59],this.board[56].squareIndex=56,this.board[59]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:59}))}},n.prototype.reset=function(){this.moveNumber=0,this.currentPlayer=Re.PLAYER_1,this.board=new Array(jo),this.board[ge(0,0)]=new $e({type:M.P1_WARRIOR,healthPoints:Ei,squareIndex:ge(0,0)}),this.board[ge(1,0)]=new $e({type:M.P1_KNIGHT,healthPoints:Zl,squareIndex:ge(1,0)}),this.board[ge(2,0)]=new $e({type:M.P1_ASSASSIN,healthPoints:Xl,squareIndex:ge(2,0)}),this.board[ge(3,0)]=new $e({type:M.P1_MAGE,healthPoints:Rp,squareIndex:ge(3,0)}),this.board[ge(4,0)]=new $e({type:M.P1_KING,healthPoints:Op,squareIndex:ge(4,0)}),this.board[ge(5,0)]=new $e({type:M.P1_ASSASSIN,healthPoints:Xl,squareIndex:ge(5,0)}),this.board[ge(6,0)]=new $e({type:M.P1_KNIGHT,healthPoints:Zl,squareIndex:ge(6,0)}),this.board[ge(7,0)]=new $e({type:M.P1_WARRIOR,healthPoints:Ei,squareIndex:ge(7,0)}),this.board[ge(0,1)]=new $e({type:M.P1_PAWN,healthPoints:ps,squareIndex:ge(0,1)}),this.board[ge(1,1)]=new $e({type:M.P1_PAWN,healthPoints:ps,squareIndex:ge(1,1)}),this.board[ge(2,1)]=new $e({type:M.P1_PAWN,healthPoints:ps,squareIndex:ge(2,1)}),this.board[ge(3,1)]=new $e({type:M.P1_PAWN,healthPoints:ps,squareIndex:ge(3,1)}),this.board[ge(4,1)]=new $e({type:M.P1_PAWN,healthPoints:ps,squareIndex:ge(4,1)}),this.board[ge(5,1)]=new $e({type:M.P1_PAWN,healthPoints:ps,squareIndex:ge(5,1)}),this.board[ge(6,1)]=new $e({type:M.P1_PAWN,healthPoints:ps,squareIndex:ge(6,1)}),this.board[ge(7,1)]=new $e({type:M.P1_PAWN,healthPoints:ps,squareIndex:ge(7,1)}),this.board[ge(0,7)]=new $e({type:M.P2_WARRIOR,healthPoints:Ei,squareIndex:ge(0,7)}),this.board[ge(1,7)]=new $e({type:M.P2_KNIGHT,healthPoints:Zl,squareIndex:ge(1,7)}),this.board[ge(2,7)]=new $e({type:M.P2_ASSASSIN,healthPoints:Xl,squareIndex:ge(2,7)}),this.board[ge(3,7)]=new $e({type:M.P2_MAGE,healthPoints:Rp,squareIndex:ge(3,7)}),this.board[ge(4,7)]=new $e({type:M.P2_KING,healthPoints:Op,squareIndex:ge(4,7)}),this.board[ge(5,7)]=new $e({type:M.P2_ASSASSIN,healthPoints:Xl,squareIndex:ge(5,7)}),this.board[ge(6,7)]=new $e({type:M.P2_KNIGHT,healthPoints:Zl,squareIndex:ge(6,7)}),this.board[ge(7,7)]=new $e({type:M.P2_WARRIOR,healthPoints:Ei,squareIndex:ge(7,7)}),this.board[ge(0,6)]=new $e({type:M.P2_PAWN,healthPoints:ps,squareIndex:ge(0,6)}),this.board[ge(1,6)]=new $e({type:M.P2_PAWN,healthPoints:ps,squareIndex:ge(1,6)}),this.board[ge(2,6)]=new $e({type:M.P2_PAWN,healthPoints:ps,squareIndex:ge(2,6)}),this.board[ge(3,6)]=new $e({type:M.P2_PAWN,healthPoints:ps,squareIndex:ge(3,6)}),this.board[ge(4,6)]=new $e({type:M.P2_PAWN,healthPoints:ps,squareIndex:ge(4,6)}),this.board[ge(5,6)]=new $e({type:M.P2_PAWN,healthPoints:ps,squareIndex:ge(5,6)}),this.board[ge(6,6)]=new $e({type:M.P2_PAWN,healthPoints:ps,squareIndex:ge(6,6)}),this.board[ge(7,6)]=new $e({type:M.P2_PAWN,healthPoints:ps,squareIndex:ge(7,6)}),this.board[ge(0,2)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(0,2)}),this.board[ge(0,3)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(0,3)}),this.board[ge(0,4)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(0,4)}),this.board[ge(0,5)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(0,5)}),this.board[ge(1,2)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(1,2)}),this.board[ge(1,3)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(1,3)}),this.board[ge(1,4)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(1,4)}),this.board[ge(1,5)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(1,5)}),this.board[ge(2,2)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(2,2)}),this.board[ge(2,3)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(2,3)}),this.board[ge(2,4)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(2,4)}),this.board[ge(2,5)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(2,5)}),this.board[ge(3,2)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(3,2)}),this.board[ge(3,3)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(3,3)}),this.board[ge(3,4)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(3,4)}),this.board[ge(3,5)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(3,5)}),this.board[ge(4,2)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(4,2)}),this.board[ge(4,3)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(4,3)}),this.board[ge(4,4)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(4,4)}),this.board[ge(4,5)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(4,5)}),this.board[ge(5,2)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(5,2)}),this.board[ge(5,3)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(5,3)}),this.board[ge(5,4)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(5,4)}),this.board[ge(5,5)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(5,5)}),this.board[ge(6,2)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(6,2)}),this.board[ge(6,3)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(6,3)}),this.board[ge(6,4)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(6,4)}),this.board[ge(6,5)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(6,5)}),this.board[ge(7,2)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(7,2)}),this.board[ge(7,3)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(7,3)}),this.board[ge(7,4)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(7,4)}),this.board[ge(7,5)]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:ge(7,5)});var e=new Array(s_);e[0]=this.board[ge(0,0)],e[1]=this.board[ge(1,0)],e[2]=this.board[ge(2,0)],e[3]=this.board[ge(3,0)],e[4]=this.board[ge(4,0)],e[5]=this.board[ge(5,0)],e[6]=this.board[ge(6,0)],e[7]=this.board[ge(7,0)],e[8]=this.board[ge(0,1)],e[9]=this.board[ge(1,1)],e[10]=this.board[ge(2,1)],e[11]=this.board[ge(3,1)],e[12]=this.board[ge(4,1)],e[13]=this.board[ge(5,1)],e[14]=this.board[ge(6,1)],e[15]=this.board[ge(7,1)],this.playerToPieces=[],this.playerToPieces.push(e),this.playerToKing[Re.PLAYER_1]=e[4];var t=new Array(s_);t[0]=this.board[ge(0,7)],t[1]=this.board[ge(1,7)],t[2]=this.board[ge(2,7)],t[3]=this.board[ge(3,7)],t[4]=this.board[ge(4,7)],t[5]=this.board[ge(5,7)],t[6]=this.board[ge(6,7)],t[7]=this.board[ge(7,7)],t[8]=this.board[ge(0,6)],t[9]=this.board[ge(1,6)],t[10]=this.board[ge(2,6)],t[11]=this.board[ge(3,6)],t[12]=this.board[ge(4,6)],t[13]=this.board[ge(5,6)],t[14]=this.board[ge(6,6)],t[15]=this.board[ge(7,6)],this.playerToPieces.push(t),this.playerToKing[Re.PLAYER_2]=t[4]},n.prototype._p1AssassinActions=function(e){for(var t=new Array,s,r=nt.squareToNeighboringNonDiagonalSquares[e.squareIndex],i=0;i<r.length;i++){s=r[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));continue}}for(var l=nt.squareToDirectionToLine[e.squareIndex][a.NORTHEAST],i=0;i<l.length;i++){s=l[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));break}else break}for(var u=nt.squareToDirectionToLine[e.squareIndex][a.SOUTHEAST],i=0;i<u.length;i++){s=u[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));break}else break}for(var d=nt.squareToDirectionToLine[e.squareIndex][a.SOUTHWEST],i=0;i<d.length;i++){s=d[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));break}else break}for(var h=nt.squareToDirectionToLine[e.squareIndex][a.NORTHWEST],i=0;i<h.length;i++){s=h[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));break}else break}return t},n.prototype._p2AssassinActions=function(e){for(var t=new Array,s,r=nt.squareToNeighboringNonDiagonalSquares[e.squareIndex],i=0;i<r.length;i++){s=r[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));continue}}for(var l=nt.squareToDirectionToLine[e.squareIndex][a.NORTHEAST],i=0;i<l.length;i++){s=l[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));break}else break}for(var u=nt.squareToDirectionToLine[e.squareIndex][a.SOUTHEAST],i=0;i<u.length;i++){s=u[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));break}else break}for(var d=nt.squareToDirectionToLine[e.squareIndex][a.SOUTHWEST],i=0;i<d.length;i++){s=d[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));break}else break}for(var h=nt.squareToDirectionToLine[e.squareIndex][a.NORTHWEST],i=0;i<h.length;i++){s=h[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_ASSASSIN_DAMAGE));break}else break}return t},n.prototype._p1PawnActions=function(e){for(var t=new Array,s,r=nt.squareToP1PawnMoveSquares[e.squareIndex],i=0;i<r.length;i++)if(s=r[i],this.board[s].type==M.NO_PIECE){if(s>55){t.push(new Le(e.squareIndex,s,le.MOVE_PROMOTE_P1_PAWN));continue}e.squareIndex-s==-2*Sr&&this.board[e.squareIndex+Sr].type!=M.NO_PIECE||t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR))}for(var o=nt.squareToP1PawnAbilitySquares[e.squareIndex],i=0;i<o.length;i++){s=o[i];var l=this.board[s];St(l.type,Re.PLAYER_2)&&(s>55?t.push(new Le(e.squareIndex,s,le.ABILITY_P1_PAWN_DAMAGE_AND_PROMOTION)):t.push(new Le(e.squareIndex,s,le.ABILITY_PAWN_DAMAGE)))}return t},n.prototype._p2PawnActions=function(e){for(var t=new Array,s,r=nt.squareToP2PawnMoveSquares[e.squareIndex],i=0;i<r.length;i++)if(s=r[i],this.board[s].type==M.NO_PIECE){if(s<8){t.push(new Le(e.squareIndex,s,le.MOVE_PROMOTE_P2_PAWN));continue}e.squareIndex-s==2*Sr&&this.board[e.squareIndex-Sr].type!=M.NO_PIECE||t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR))}for(var o=nt.squareToP2PawnAbilitySquares[e.squareIndex],i=0;i<o.length;i++){s=o[i];var l=this.board[s];St(l.type,Re.PLAYER_1)&&(s<8?t.push(new Le(e.squareIndex,s,le.ABILITY_P2_PAWN_DAMAGE_AND_PROMOTION)):t.push(new Le(e.squareIndex,s,le.ABILITY_PAWN_DAMAGE)))}return t},n.prototype._p1KingActions=function(e){for(var t=new Array,s=nt.squareToNeighboringSquares[e.squareIndex],r=0;r<s.length;r++){var i=s[r];this.board[i].type==M.NO_PIECE?t.push(new Le(e.squareIndex,i,le.MOVE_REGULAR)):St(this.board[i].type,Re.PLAYER_2)&&t.push(new Le(e.squareIndex,i,le.ABILITY_KING_DAMAGE))}return e.squareIndex==4&&(this.board[5].type==M.NO_PIECE&&this.board[6].type==M.NO_PIECE&&this.board[7].type==M.P1_WARRIOR&&t.push(new Le(4,6,le.MOVE_CASTLE)),this.board[3].type==M.NO_PIECE&&this.board[2].type==M.NO_PIECE&&this.board[1].type==M.NO_PIECE&&this.board[0].type==M.P1_WARRIOR&&t.push(new Le(4,2,le.MOVE_CASTLE))),t},n.prototype._p2KingActions=function(e){for(var t=new Array,s=nt.squareToNeighboringSquares[e.squareIndex],r=0;r<s.length;r++){var i=s[r];this.board[i].type==M.NO_PIECE?t.push(new Le(e.squareIndex,i,le.MOVE_REGULAR)):St(this.board[i].type,Re.PLAYER_1)&&t.push(new Le(e.squareIndex,i,le.ABILITY_KING_DAMAGE))}return e.squareIndex==60&&(this.board[61].type==M.NO_PIECE&&this.board[62].type==M.NO_PIECE&&this.board[63].type==M.P2_WARRIOR&&t.push(new Le(60,62,le.MOVE_CASTLE)),this.board[59].type==M.NO_PIECE&&this.board[58].type==M.NO_PIECE&&this.board[57].type==M.NO_PIECE&&this.board[56].type==M.P2_WARRIOR&&t.push(new Le(60,58,le.MOVE_CASTLE))),t},n.prototype._p1MageActions=function(e){for(var t=new Array,s,r=nt.squareToDirectionToLine[e.squareIndex][a.NORTH],i=0;i<r.length;i++){s=r[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var l=nt.squareToDirectionToLine[e.squareIndex][a.NORTHEAST],i=0;i<l.length;i++){s=l[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var u=nt.squareToDirectionToLine[e.squareIndex][a.EAST],i=0;i<u.length;i++){s=u[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var d=nt.squareToDirectionToLine[e.squareIndex][a.SOUTHEAST],i=0;i<d.length;i++){s=d[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var h=nt.squareToDirectionToLine[e.squareIndex][a.SOUTH],i=0;i<h.length;i++){s=h[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var f=nt.squareToDirectionToLine[e.squareIndex][a.SOUTHWEST],i=0;i<f.length;i++){s=f[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var m=nt.squareToDirectionToLine[e.squareIndex][a.WEST],i=0;i<m.length;i++){s=m[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var I=nt.squareToDirectionToLine[e.squareIndex][a.NORTHWEST],i=0;i<I.length;i++){s=I[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var y=0;y<g_;y++)for(var N=f_[y],w=nt.squareToDirectionToLine[e.squareIndex][N],i=0;i<w.length;i++){var T=this.board[w[i]];if(T.type!=M.P1_ASSASSIN)break;for(var v=i+1;v<w.length;v++){var E=this.board[w[v]];if(St(E.type,Re.PLAYER_2)){var _=le.ABILITY_MAGE_THROW_ASSASSIN,L=new Le(e.squareIndex,E.squareIndex,_);t.push(L);break}else if(St(E.type,Re.PLAYER_1))break}break}return t},n.prototype._p2MageActions=function(e){for(var t=new Array,s,r=nt.squareToDirectionToLine[e.squareIndex][a.NORTH],i=0;i<r.length;i++){s=r[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var l=nt.squareToDirectionToLine[e.squareIndex][a.NORTHEAST],i=0;i<l.length;i++){s=l[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var u=nt.squareToDirectionToLine[e.squareIndex][a.EAST],i=0;i<u.length;i++){s=u[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var d=nt.squareToDirectionToLine[e.squareIndex][a.SOUTHEAST],i=0;i<d.length;i++){s=d[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var h=nt.squareToDirectionToLine[e.squareIndex][a.SOUTH],i=0;i<h.length;i++){s=h[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var f=nt.squareToDirectionToLine[e.squareIndex][a.SOUTHWEST],i=0;i<f.length;i++){s=f[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var m=nt.squareToDirectionToLine[e.squareIndex][a.WEST],i=0;i<m.length;i++){s=m[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var I=nt.squareToDirectionToLine[e.squareIndex][a.NORTHWEST],i=0;i<I.length;i++){s=I[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_MAGE_DAMAGE));break}else break}for(var y=0;y<g_;y++)for(var N=f_[y],w=nt.squareToDirectionToLine[e.squareIndex][N],i=0;i<w.length;i++){var T=this.board[w[i]];if(T.type!=M.P2_ASSASSIN)break;for(var v=i+1;v<w.length;v++){var E=this.board[w[v]];if(St(E.type,Re.PLAYER_1)){var _=le.ABILITY_MAGE_THROW_ASSASSIN,L=new Le(e.squareIndex,E.squareIndex,_);t.push(L);break}else if(St(E.type,Re.PLAYER_2))break}break}return t},n.prototype._p1WarriorActions=function(e){for(var t=new Array,s,r=nt.squareToDirectionToLine[e.squareIndex][a.NORTH],i=0;i<r.length;i++){s=r[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_WARRIOR_DAMAGE));break}else break}for(var l=nt.squareToDirectionToLine[e.squareIndex][a.EAST],i=0;i<l.length;i++){s=l[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_WARRIOR_DAMAGE));break}else break}for(var u=nt.squareToDirectionToLine[e.squareIndex][a.SOUTH],i=0;i<u.length;i++){s=u[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_WARRIOR_DAMAGE));break}else break}for(var d=nt.squareToDirectionToLine[e.squareIndex][a.WEST],i=0;i<d.length;i++){s=d[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_2)){t.push(new Le(e.squareIndex,s,le.ABILITY_WARRIOR_DAMAGE));break}else break}for(var h=0;h<4;h++)for(var f=nt.squareToDirectionToLine[e.squareIndex][m_[h]],i=0;i<f.length;i++){var m=this.board[f[i]];if(m.type!=M.P1_WARRIOR)break;for(var I=i+1;I<f.length;I++){var y=this.board[f[I]];if(St(y.type,Re.PLAYER_2)){var N=new Le(e.squareIndex,y.squareIndex,le.ABILITY_WARRIOR_THROW_WARRIOR);t.push(N);break}else if(St(y.type,Re.PLAYER_1))break}break}return t},n.prototype._p2WarriorActions=function(e){for(var t=new Array,s,r=nt.squareToDirectionToLine[e.squareIndex][a.NORTH],i=0;i<r.length;i++){s=r[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_WARRIOR_DAMAGE));break}else break}for(var l=nt.squareToDirectionToLine[e.squareIndex][a.EAST],i=0;i<l.length;i++){s=l[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_WARRIOR_DAMAGE));break}else break}for(var u=nt.squareToDirectionToLine[e.squareIndex][a.SOUTH],i=0;i<u.length;i++){s=u[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_WARRIOR_DAMAGE));break}else break}for(var d=nt.squareToDirectionToLine[e.squareIndex][a.WEST],i=0;i<d.length;i++){s=d[i];var o=this.board[s];if(o.type==M.NO_PIECE)t.push(new Le(e.squareIndex,s,le.MOVE_REGULAR));else if(St(o.type,Re.PLAYER_1)){t.push(new Le(e.squareIndex,s,le.ABILITY_WARRIOR_DAMAGE));break}else break}for(var h=0;h<4;h++)for(var f=nt.squareToDirectionToLine[e.squareIndex][m_[h]],i=0;i<f.length;i++){var m=this.board[f[i]];if(m.type!=M.P2_WARRIOR)break;for(var I=i+1;I<f.length;I++){var y=this.board[f[I]];if(St(y.type,Re.PLAYER_1)){var N=new Le(e.squareIndex,y.squareIndex,le.ABILITY_WARRIOR_THROW_WARRIOR);t.push(N);break}else if(St(y.type,Re.PLAYER_2))break}break}return t},n.prototype._p1KnightActions=function(e){for(var t=new Array,s=nt.squareToKnightActionSquares[e.squareIndex],r=0;r<s.length;r++){var i=s[r],o=this.board[i];o.type==M.NO_PIECE?t.push(new Le(e.squareIndex,i,le.MOVE_REGULAR)):St(o.type,Re.PLAYER_2)&&t.push(new Le(e.squareIndex,i,le.ABILITY_KNIGHT_DAMAGE))}var l=e.squareIndex+16,u=e.squareIndex+8;return y_(l)||this.board[u].type==M.P1_PAWN&&St(this.board[l].type,Re.PLAYER_2)&&t.push(new Le(e.squareIndex,l,le.ABILITY_KNIGHT_THROW_PAWN)),t},n.prototype._p2KnightActions=function(e){for(var t=new Array,s=nt.squareToKnightActionSquares[e.squareIndex],r=0;r<s.length;r++){var i=s[r],o=this.board[i];o.type==M.NO_PIECE?t.push(new Le(e.squareIndex,i,le.MOVE_REGULAR)):St(o.type,Re.PLAYER_1)&&t.push(new Le(e.squareIndex,i,le.ABILITY_KNIGHT_DAMAGE))}var l=e.squareIndex-16,u=e.squareIndex-8;return y_(l)||this.board[u].type==M.P2_PAWN&&St(this.board[l].type,Re.PLAYER_1)&&t.push(new Le(e.squareIndex,l,le.ABILITY_KNIGHT_THROW_PAWN)),t},n.prototype.legalActionsByPiece=function(e){switch(e.type){case M.P1_KING:return this._p1KingActions(e);case M.P1_MAGE:return this._p1MageActions(e);case M.P1_PAWN:return this._p1PawnActions(e);case M.P1_WARRIOR:return this._p1WarriorActions(e);case M.P1_ASSASSIN:return this._p1AssassinActions(e);case M.P1_KNIGHT:return this._p1KnightActions(e);case M.P2_KING:return this._p2KingActions(e);case M.P2_MAGE:return this._p2MageActions(e);case M.P2_PAWN:return this._p2PawnActions(e);case M.P2_WARRIOR:return this._p2WarriorActions(e);case M.P2_ASSASSIN:return this._p2AssassinActions(e);case M.P2_KNIGHT:return this._p2KnightActions(e);default:return new Array}},n.prototype.generateLegalActions=function(){var e=new Array;if(this.playerToKing[this.currentPlayer].healthPoints<=0)return e;for(var t=this.playerToPieces[this.currentPlayer],s=0;s<t.length;s++){var r=t[s];if(!(r.healthPoints<=0)){var i=this.legalActionsByPiece(r);e=e.concat(i)}}var o=new Le(Va,Va,le.SKIP);return e.push(o),e},n.prototype.makeAction=function(e){var t=new kz;if(t.action=e,e.actionType!=le.SKIP){var s=e.srcIdx,r=e.dstIdx,i=this.board[s],o=this.board[r],l=void 0,u=void 0,d=void 0,h=void 0,f=void 0,m=void 0,I=void 0;switch(e.actionType){case le.MOVE_REGULAR:this.board[e.dstIdx]=this.board[e.srcIdx],this.board[e.dstIdx].squareIndex=e.dstIdx,this.board[e.srcIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.srcIdx});break;case le.MOVE_CASTLE:this.board[e.dstIdx]=this.board[e.srcIdx],this.board[e.dstIdx].squareIndex=e.dstIdx,this.board[e.srcIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.srcIdx}),e.dstIdx==6?(this.board[5]=this.board[7],this.board[5].squareIndex=5,this.board[7]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:7})):e.dstIdx==2?(this.board[3]=this.board[0],this.board[3].squareIndex=3,this.board[0]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:0})):e.dstIdx==62?(this.board[61]=this.board[63],this.board[61].squareIndex=61,this.board[63]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:63})):(this.board[59]=this.board[56],this.board[59].squareIndex=59,this.board[56]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:56}));break;case le.MOVE_PROMOTE_P1_PAWN:t.t1=i.healthPoints,m=this.playerToPieces[Re.PLAYER_1].indexOf(i),this.playerToPieces[Re.PLAYER_1].splice(m,1),this.board[e.srcIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.srcIdx}),this.board[e.dstIdx]=new $e({type:M.P1_WARRIOR,healthPoints:Ei,squareIndex:e.dstIdx}),this.playerToPieces[Re.PLAYER_1].push(this.board[e.dstIdx]);break;case le.MOVE_PROMOTE_P2_PAWN:t.t1=i.healthPoints,m=this.playerToPieces[Re.PLAYER_2].indexOf(i),this.playerToPieces[Re.PLAYER_2].splice(m,1),this.board[e.srcIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.srcIdx}),this.board[e.dstIdx]=new $e({type:M.P2_WARRIOR,healthPoints:Ei,squareIndex:e.dstIdx}),this.playerToPieces[Re.PLAYER_2].push(this.board[e.dstIdx]);break;case le.ABILITY_KING_DAMAGE:o.healthPoints-=r_,t.affectedPieces[0]=o,o.healthPoints<=0&&(this.board[r]=i,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}),i.squareIndex=r);break;case le.ABILITY_MAGE_DAMAGE:if(o.healthPoints-=i_,t.affectedPieces[0]=o,o.healthPoints<=0)this.board[r]=i,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}),i.squareIndex=r;else{for(d=nt.srcSquareToDstSquareToDirection[s][r],h=nt.squareToDirectionToLine[s][d],m=0;l=this.board[h[m]],l.type==M.NO_PIECE;)m++;m!=0&&(u=h[m-1],t.t1=u,this.board[u]=this.board[s],this.board[u].squareIndex=u,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}))}break;case le.ABILITY_MAGE_THROW_ASSASSIN:i.type==M.P1_MAGE?I=Re.PLAYER_2:I=Re.PLAYER_1,d=nt.srcSquareToDstSquareToDirection[s][r],h=nt.squareToDirectionToLine[s][d],m=h[0],t.t1=m,t.affectedPieces.push(this.board[m]),o.healthPoints-=u_,t.affectedPieces.push(o),this.board[r]=this.board[m],this.board[r].squareIndex=r,this.board[m]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:m}),f=nt.squareToNeighboringSquares[r];for(var y=0;y<f.length;y++)l=this.board[f[y]],St(l.type,I)&&(l.healthPoints-=c_,t.affectedPieces.push(l),l.healthPoints<=0&&(this.board[l.squareIndex]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:l.squareIndex})));break;case le.ABILITY_PAWN_DAMAGE:o.healthPoints-=Ca,t.affectedPieces[0]=o,o.healthPoints<=0&&(this.board[r]=i,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}),i.squareIndex=r);break;case le.ABILITY_P1_PAWN_DAMAGE_AND_PROMOTION:t.t1=i.healthPoints,m=this.playerToPieces[Re.PLAYER_1].indexOf(i),this.playerToPieces[Re.PLAYER_1].splice(m,1),this.board[e.srcIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.srcIdx}),o.healthPoints-=Ca,t.affectedPieces[0]=o,this.board[e.dstIdx]=new $e({type:M.P1_WARRIOR,healthPoints:Ei,squareIndex:e.dstIdx}),this.playerToPieces[Re.PLAYER_1].push(this.board[e.dstIdx]);break;case le.ABILITY_P2_PAWN_DAMAGE_AND_PROMOTION:t.t1=i.healthPoints,m=this.playerToPieces[Re.PLAYER_2].indexOf(i),this.playerToPieces[Re.PLAYER_2].splice(m,1),this.board[e.srcIdx]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.srcIdx}),o.healthPoints-=Ca,t.affectedPieces[0]=o,this.board[e.dstIdx]=new $e({type:M.P2_WARRIOR,healthPoints:Ei,squareIndex:e.dstIdx}),this.playerToPieces[Re.PLAYER_2].push(this.board[e.dstIdx]);break;case le.ABILITY_WARRIOR_DAMAGE:if(o.healthPoints-=a_,t.affectedPieces[0]=o,o.healthPoints<=0)this.board[r]=i,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}),i.squareIndex=r;else{for(d=nt.srcSquareToDstSquareToDirection[s][r],h=nt.squareToDirectionToLine[s][d],m=0;l=this.board[h[m]],l.type==M.NO_PIECE;)m++;m!=0&&(u=h[m-1],t.t1=u,this.board[u]=this.board[s],this.board[u].squareIndex=u,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}))}break;case le.ABILITY_WARRIOR_THROW_WARRIOR:i.type==M.P1_WARRIOR?I=Re.PLAYER_2:I=Re.PLAYER_1,d=nt.srcSquareToDstSquareToDirection[s][r],h=nt.squareToDirectionToLine[s][d],m=h[0],t.t1=m,t.affectedPieces.push(this.board[m]),o.healthPoints-=d_,t.affectedPieces.push(o),this.board[r]=this.board[m],this.board[r].squareIndex=r,this.board[m]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:m}),f=nt.squareToNeighboringSquares[r];for(var y=0;y<f.length;y++)l=this.board[f[y]],St(l.type,I)&&(l.healthPoints-=h_,t.affectedPieces.push(l),l.healthPoints<=0&&(this.board[l.squareIndex]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:l.squareIndex})));break;case le.ABILITY_ASSASSIN_DAMAGE:if(o.healthPoints-=o_,t.affectedPieces[0]=o,o.healthPoints<=0)this.board[r]=i,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}),i.squareIndex=r;else{for(d=nt.srcSquareToDstSquareToDirection[s][r],h=nt.squareToDirectionToLine[s][d],m=0;l=this.board[h[m]],l.type==M.NO_PIECE;)m++;m!=0&&(u=h[m-1],t.t1=u,this.board[u]=this.board[s],this.board[u].squareIndex=u,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}))}break;case le.ABILITY_KNIGHT_DAMAGE:o.healthPoints-=l_,t.affectedPieces[0]=o,o.healthPoints<=0&&(this.board[r]=i,this.board[s]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:s}),i.squareIndex=r);break;case le.ABILITY_KNIGHT_THROW_PAWN:i.type==M.P1_KNIGHT?I=Re.PLAYER_2:I=Re.PLAYER_1,d=nt.srcSquareToDstSquareToDirection[s][r],h=nt.squareToDirectionToLine[s][d],m=h[0],t.t1=this.board[m].healthPoints,this.board[m].healthPoints=0,t.affectedPieces.push(this.board[m]),this.board[m]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:m}),o.healthPoints-=p_,t.affectedPieces.push(o),o.healthPoints<=0&&(this.board[r]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:r}));break}}return this.moveNumber+=1,this.currentPlayer=1-this.currentPlayer,t},n.prototype.undoAction=function(e){var t,s,r=e.action.srcIdx,i=e.action.dstIdx,o;switch(e.action.actionType){case le.MOVE_REGULAR:this.undoMove(e.action);break;case le.MOVE_CASTLE:this.undoMove(e.action);break;case le.MOVE_PROMOTE_P1_PAWN:s=this.board[i],o=this.playerToPieces[Re.PLAYER_1].indexOf(s),this.playerToPieces[Re.PLAYER_1].splice(o,1),this.board[i]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:i}),this.board[r]=new $e({type:M.P1_PAWN,healthPoints:e.t1,squareIndex:r}),this.playerToPieces[Re.PLAYER_1].push(this.board[r]);break;case le.MOVE_PROMOTE_P2_PAWN:s=this.board[i],o=this.playerToPieces[Re.PLAYER_2].indexOf(s),this.playerToPieces[Re.PLAYER_2].splice(o,1),this.board[i]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:i}),this.board[r]=new $e({type:M.P2_PAWN,healthPoints:e.t1,squareIndex:r}),this.playerToPieces[Re.PLAYER_2].push(this.board[r]);break;case le.ABILITY_KING_DAMAGE:t=e.affectedPieces[0],t.healthPoints+=r_,this.board[t.squareIndex]!=t&&(this.board[r]=this.board[i],this.board[r].squareIndex=r,this.board[i]=t);break;case le.ABILITY_MAGE_DAMAGE:t=e.affectedPieces[0],t.healthPoints+=i_,this.board[t.squareIndex]!=t?(this.board[r]=this.board[i],this.board[r].squareIndex=r,this.board[i]=t):e.t1!==void 0&&(this.board[r]=this.board[e.t1],this.board[r].squareIndex=r,this.board[e.t1]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.t1}));break;case le.ABILITY_MAGE_THROW_ASSASSIN:this.board[e.t1]=e.affectedPieces[0],this.board[e.t1].squareIndex=e.t1,t=e.affectedPieces[1],t.healthPoints+=u_,this.board[t.squareIndex]=t;for(var l=2;l<e.affectedPieces.length;l++)t=e.affectedPieces[l],t.healthPoints+=c_,this.board[t.squareIndex]=t;break;case le.ABILITY_WARRIOR_THROW_WARRIOR:this.board[e.t1]=e.affectedPieces[0],this.board[e.t1].squareIndex=e.t1,t=e.affectedPieces[1],t.healthPoints+=d_,this.board[t.squareIndex]=t;for(var l=2;l<e.affectedPieces.length;l++)t=e.affectedPieces[l],t.healthPoints+=h_,this.board[t.squareIndex]=t;break;case le.ABILITY_WARRIOR_DAMAGE:t=e.affectedPieces[0],t.healthPoints+=a_,this.board[t.squareIndex]!=t?(this.board[r]=this.board[i],this.board[r].squareIndex=r,this.board[i]=t):e.t1!==void 0&&(this.board[r]=this.board[e.t1],this.board[r].squareIndex=r,this.board[e.t1]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.t1}));break;case le.ABILITY_ASSASSIN_DAMAGE:t=e.affectedPieces[0],t.healthPoints+=o_,this.board[t.squareIndex]!=t?(this.board[r]=this.board[i],this.board[r].squareIndex=r,this.board[i]=t):e.t1!==void 0&&(this.board[r]=this.board[e.t1],this.board[r].squareIndex=r,this.board[e.t1]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:e.t1}));break;case le.ABILITY_KNIGHT_DAMAGE:t=e.affectedPieces[0],t.healthPoints+=l_,this.board[t.squareIndex]!=t&&(this.board[r]=this.board[i],this.board[r].squareIndex=r,this.board[i]=t);break;case le.ABILITY_KNIGHT_THROW_PAWN:this.board[e.affectedPieces[0].squareIndex]=e.affectedPieces[0],this.board[e.affectedPieces[0].squareIndex].healthPoints=e.t1,t=e.affectedPieces[1],t.healthPoints+=p_,this.board[t.squareIndex]=t;break;case le.ABILITY_PAWN_DAMAGE:t=e.affectedPieces[0],t.healthPoints+=Ca,this.board[t.squareIndex]!=t&&(this.board[r]=this.board[i],this.board[r].squareIndex=r,this.board[i]=t);break;case le.ABILITY_P1_PAWN_DAMAGE_AND_PROMOTION:s=this.board[i],o=this.playerToPieces[Re.PLAYER_1].indexOf(s),this.playerToPieces[Re.PLAYER_1].splice(o,1),this.board[i]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:i}),t=e.affectedPieces[0],t.healthPoints+=Ca,this.board[i]=t,this.board[r]=new $e({type:M.P1_PAWN,healthPoints:e.t1,squareIndex:r}),this.playerToPieces[Re.PLAYER_1].push(this.board[r]);break;case le.ABILITY_P2_PAWN_DAMAGE_AND_PROMOTION:s=this.board[i],o=this.playerToPieces[Re.PLAYER_2].indexOf(s),this.playerToPieces[Re.PLAYER_2].splice(o,1),this.board[i]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:i}),t=e.affectedPieces[0],t.healthPoints+=Ca,this.board[i]=t,this.board[r]=new $e({type:M.P2_PAWN,healthPoints:e.t1,squareIndex:r}),this.playerToPieces[Re.PLAYER_2].push(this.board[r]);break;case le.SKIP:break}this.moveNumber-=1,this.currentPlayer=1-this.currentPlayer},n.prototype.dump=function(){var e="";e+=`------------------------------------------
`;for(var t=zi-1;t>=0;t--){e+=t+"   ";for(var s=0;s<Sr;s++)this.board[ge(s,t)].type!==M.NO_PIECE?e+=I_(this.board[ge(s,t)].type)+this.board[ge(s,t)].healthPoints+" ":e+=I_(this.board[ge(s,t)].type)+"    ";e+=`
`}e+=`
`,e+="   ";for(var t=0;t<Sr;t++)e+=" "+t+"   ";return e+=`
------------------------------------------
`,e},n.prototype.isActionLegal=function(e,t){return!0},n.prototype.getCurrentPlayer=function(){return this.currentPlayer},n.prototype.getPieceByCoordinates=function(e,t){return this.board[ge(e,t)]},n.prototype.getPieceBySquareIndex=function(e){return this.board[e]},n.prototype.getAllPiecesByPlayer=function(e){return this.playerToPieces[e]},n.prototype.isGameOver=function(){return this.playerToKing[Re.PLAYER_1].healthPoints<=0||this.playerToKing[Re.PLAYER_2].healthPoints<=0},n.prototype.winner=function(){if(this.playerToKing[Re.PLAYER_1].healthPoints<=0)return Re.PLAYER_2;if(this.playerToKing[Re.PLAYER_2].healthPoints<=0)return Re.PLAYER_1},n.prototype.boardFromString=function(e){var t=this;this.currentPlayer=Number(e.charAt(0)),this.moveNumber=0,this.playerToKing[Re.PLAYER_1]=new $e({type:M.P1_KING,healthPoints:0,squareIndex:0}),this.playerToKing[Re.PLAYER_2]=new $e({type:M.P2_KING,healthPoints:0,squareIndex:0});var s=new Array,r=new Array,i=e.substring(2),o=i.split(",");o.pop();var l=0;o.forEach(function(u){var d=u.split("-");if(d[0]==="empty")t.board[l]=new $e({type:M.NO_PIECE,healthPoints:0,squareIndex:l});else{var h=Number(d[2]),f=d[0]+d[1];f=="0king"?(t.board[l]=new $e({type:M.P1_KING,healthPoints:h,squareIndex:l}),s.push(t.board[l]),t.playerToKing[Re.PLAYER_1]=t.board[l]):f=="0pawn"?(t.board[l]=new $e({type:M.P1_PAWN,healthPoints:h,squareIndex:l}),s.push(t.board[l])):f=="0mage"?(t.board[l]=new $e({type:M.P1_MAGE,healthPoints:h,squareIndex:l}),s.push(t.board[l])):f=="0assassin"?(t.board[l]=new $e({type:M.P1_ASSASSIN,healthPoints:h,squareIndex:l}),s.push(t.board[l])):f=="0knight"?(t.board[l]=new $e({type:M.P1_KNIGHT,healthPoints:h,squareIndex:l}),s.push(t.board[l])):f=="0warrior"?(t.board[l]=new $e({type:M.P1_WARRIOR,healthPoints:h,squareIndex:l}),s.push(t.board[l])):f=="1king"?(t.board[l]=new $e({type:M.P2_KING,healthPoints:h,squareIndex:l}),r.push(t.board[l]),t.playerToKing[Re.PLAYER_2]=t.board[l]):f=="1pawn"?(t.board[l]=new $e({type:M.P2_PAWN,healthPoints:h,squareIndex:l}),r.push(t.board[l])):f=="1mage"?(t.board[l]=new $e({type:M.P2_MAGE,healthPoints:h,squareIndex:l}),r.push(t.board[l])):f=="1assassin"?(t.board[l]=new $e({type:M.P2_ASSASSIN,healthPoints:h,squareIndex:l}),r.push(t.board[l])):f=="1knight"?(t.board[l]=new $e({type:M.P2_KNIGHT,healthPoints:h,squareIndex:l}),r.push(t.board[l])):f=="1warrior"&&(t.board[l]=new $e({type:M.P2_WARRIOR,healthPoints:h,squareIndex:l}),r.push(t.board[l]))}l+=1}),this.playerToPieces[Re.PLAYER_1]=s,this.playerToPieces[Re.PLAYER_2]=r},n.prototype.boardToString=function(){var e="";e+=this.currentPlayer+"|";for(var t,s=0;s<jo;s++)if(t=this.board[s],t.type==M.NO_PIECE)e+="empty,";else{switch(t.type){case M.P1_KING:e+="0-king-";break;case M.P1_MAGE:e+="0-mage-";break;case M.P1_PAWN:e+="0-pawn-";break;case M.P1_WARRIOR:e+="0-warrior-";break;case M.P1_ASSASSIN:e+="0-assassin-";break;case M.P1_KNIGHT:e+="0-knight-";break;case M.P2_KING:e+="1-king-";break;case M.P2_MAGE:e+="1-mage-";break;case M.P2_PAWN:e+="1-pawn-";break;case M.P2_WARRIOR:e+="1-warrior-";break;case M.P2_ASSASSIN:e+="1-assassin-";break;case M.P2_KNIGHT:e+="1-knight-";break}e+=t.healthPoints+","}return e},n.prototype.board2D=function(){for(var e=new Array,t=new Array,s=zi-1;s>=0;s--){for(var r=0;r<Sr;r++)t.push(this.getPieceByCoordinates(r,s));e.push(t),t=[]}return e},n.prototype.getMoveNumber=function(){return this.moveNumber},n}();function ge(n,e){return n+e*Sr}var Cz=function(){function n(){this.game=new kc({})}return n.prototype.makeAction=function(e,t){var s,r,i;if(e==Va&&t==Va)s=new Le(Va,Va,le.SKIP);else{var o=this.game.board[e],l=this.game.board[t];if(l.type==M.NO_PIECE)e==4&&t==6&&o.type==M.P1_KING||e==4&&t==2&&o.type==M.P1_KING?s=new Le(e,t,le.MOVE_CASTLE):e==60&&t==62&&o.type==M.P2_KING||e==60&&t==58&&o.type==M.P2_KING?s=new Le(e,t,le.MOVE_CASTLE):o.type==M.P1_PAWN&&t>55?s=new Le(e,t,le.MOVE_PROMOTE_P1_PAWN):o.type==M.P2_PAWN&&t<8?s=new Le(e,t,le.MOVE_PROMOTE_P2_PAWN):s=new Le(e,t,le.MOVE_REGULAR);else if(o.type==M.P1_KNIGHT)t-e==16?s=new Le(e,t,le.ABILITY_KNIGHT_THROW_PAWN):s=new Le(e,t,le.ABILITY_KNIGHT_DAMAGE);else if(o.type==M.P2_KNIGHT)t-e==-16?s=new Le(e,t,le.ABILITY_KNIGHT_THROW_PAWN):s=new Le(e,t,le.ABILITY_KNIGHT_DAMAGE);else if(o.type==M.P1_ASSASSIN){r=nt.srcSquareToDstSquareToDirection[o.squareIndex][l.squareIndex],i=nt.squareToDirectionToLine[o.squareIndex][r];var u=this.game.board[i[0]];s=new Le(e,t,wr(o))}else if(o.type==M.P2_ASSASSIN){r=nt.srcSquareToDstSquareToDirection[o.squareIndex][l.squareIndex],i=nt.squareToDirectionToLine[o.squareIndex][r];var u=this.game.board[i[0]];s=new Le(e,t,wr(o))}else if(o.type==M.P1_MAGE)if(r=nt.srcSquareToDstSquareToDirection[o.squareIndex][l.squareIndex],r!=a.INVALID){i=nt.squareToDirectionToLine[o.squareIndex][r];var u=this.game.board[i[0]];u.type==M.P1_ASSASSIN?s=new Le(e,t,le.ABILITY_MAGE_THROW_ASSASSIN):s=new Le(e,t,wr(o))}else s=new Le(e,t,wr(o));else if(o.type==M.P2_MAGE)if(r=nt.srcSquareToDstSquareToDirection[o.squareIndex][l.squareIndex],r!=a.INVALID){i=nt.squareToDirectionToLine[o.squareIndex][r];var u=this.game.board[i[0]];u.type==M.P2_ASSASSIN?s=new Le(e,t,le.ABILITY_MAGE_THROW_ASSASSIN):s=new Le(e,t,wr(o))}else s=new Le(e,t,wr(o));else if(o.type==M.P1_WARRIOR)if(r=nt.srcSquareToDstSquareToDirection[o.squareIndex][l.squareIndex],r!=a.INVALID){i=nt.squareToDirectionToLine[o.squareIndex][r];var u=this.game.board[i[0]];u.type==M.P1_WARRIOR?s=new Le(e,t,le.ABILITY_WARRIOR_THROW_WARRIOR):s=new Le(e,t,wr(o))}else s=new Le(e,t,wr(o));else if(o.type==M.P2_WARRIOR)if(r=nt.srcSquareToDstSquareToDirection[o.squareIndex][l.squareIndex],r!=a.INVALID){i=nt.squareToDirectionToLine[o.squareIndex][r];var u=this.game.board[i[0]];u.type==M.P2_WARRIOR?s=new Le(e,t,le.ABILITY_WARRIOR_THROW_WARRIOR):s=new Le(e,t,wr(o))}else s=new Le(e,t,wr(o));else o.type==M.P1_PAWN?t>55?s=new Le(e,t,le.ABILITY_P1_PAWN_DAMAGE_AND_PROMOTION):s=new Le(e,t,wr(o)):o.type==M.P2_PAWN?t<8?s=new Le(e,t,le.ABILITY_P2_PAWN_DAMAGE_AND_PROMOTION):s=new Le(e,t,wr(o)):s=new Le(e,t,wr(o))}return this.game.makeAction(s)},n.prototype.undoAction=function(e){this.game.undoAction(e)},n.prototype.reset=function(){this.game.reset()},n.prototype.legalActions=function(){return this.game.generateLegalActions()},n.prototype.legalActionsBySquare=function(e){if(!b_(e))throw new Error("Invalid square");var t=this.game.getPieceBySquareIndex(e);return!St(t.type,this.game.currentPlayer)||t.healthPoints<=0?new Array:this.game.legalActionsByPiece(t)},n.prototype.currentPlayer=function(){return this.game.getCurrentPlayer()},n.prototype.pieceByCoordinates=function(e,t){if(e<0||e>Sr||t<0||t>zi)throw new Error("Invalid coordinates");return this.game.getPieceByCoordinates(e,t)},n.prototype.pieceBySquare=function(e){if(!b_(e))throw new Error("Invalid square");return this.game.getPieceBySquareIndex(e)},n.prototype.allPiecesByPlayer=function(e){return this.game.getAllPiecesByPlayer(e)},n.prototype.playerToKing=function(e){return this.game.playerToKing[e]},n.prototype.isGameOver=function(){return this.game.isGameOver()},n.prototype.winner=function(){return this.game.winner()},n.prototype.boardFromString=function(e){this.game.boardFromString(e)},n.prototype.boardToString=function(){return this.game.boardToString()},n.prototype.board2D=function(){return this.game.board2D()},n.prototype.dump=function(){return this.game.dump()},n.prototype.moveNumber=function(){return this.game.getMoveNumber()},n}();function wr(n){switch(n.type){case M.P1_KING:return le.ABILITY_KING_DAMAGE;case M.P1_MAGE:return le.ABILITY_MAGE_DAMAGE;case M.P1_WARRIOR:return le.ABILITY_WARRIOR_DAMAGE;case M.P1_ASSASSIN:return le.ABILITY_ASSASSIN_DAMAGE;case M.P1_KNIGHT:return le.ABILITY_KNIGHT_DAMAGE;case M.P1_PAWN:return le.ABILITY_PAWN_DAMAGE;case M.P2_KING:return le.ABILITY_KING_DAMAGE;case M.P2_MAGE:return le.ABILITY_MAGE_DAMAGE;case M.P2_WARRIOR:return le.ABILITY_WARRIOR_DAMAGE;case M.P2_ASSASSIN:return le.ABILITY_ASSASSIN_DAMAGE;case M.P2_KNIGHT:return le.ABILITY_KNIGHT_DAMAGE;case M.P2_PAWN:return le.ABILITY_PAWN_DAMAGE;default:return le.ABILITY_MAGE_DAMAGE}}function b_(n){return!(n<0||n>=jo)}function Lz(n){let e=n-Math.floor(n/zi)*zi,t=Math.floor(n/zi);return[e+1,t+1]}function Cc(n){let e=Lz(n),t=e[0],s=e[1],r="";switch(t){case 1:r="a";break;case 2:r="b";break;case 3:r="c";break;case 4:r="d";break;case 5:r="e";break;case 6:r="f";break;case 7:r="g";break;case 8:r="h";break}return r+s.toString()}function x_(n){let e=n[0],t=0;switch(e){case"a":t=0;break;case"b":t=1;break;case"c":t=2;break;case"d":t=3;break;case"e":t=4;break;case"f":t=5;break;case"g":t=6;break;case"h":t=7;break}return(parseInt(n[1])-1)*zi+t}function N_(n){switch(n){case M.P1_KING:return"king";case M.P1_MAGE:return"queen";case M.P1_WARRIOR:return"rook";case M.P1_ASSASSIN:return"bishop";case M.P1_KNIGHT:return"knight";case M.P1_PAWN:return"pawn";case M.P2_KING:return"king";case M.P2_MAGE:return"queen";case M.P2_WARRIOR:return"rook";case M.P2_ASSASSIN:return"bishop";case M.P2_KNIGHT:return"knight";case M.P2_PAWN:return"pawn";default:return"error"}}function w_(n){switch(n){case M.P1_KING:return"white";case M.P1_MAGE:return"white";case M.P1_WARRIOR:return"white";case M.P1_ASSASSIN:return"white";case M.P1_KNIGHT:return"white";case M.P1_PAWN:return"white";case M.P2_KING:return"black";case M.P2_MAGE:return"black";case M.P2_WARRIOR:return"black";case M.P2_ASSASSIN:return"black";case M.P2_KNIGHT:return"black";case M.P2_PAWN:return"black";default:return"error"}}function A_(n,e){let t=new Map;for(let i=0;i<jo;i++){let o=Cc(i);t.set(o,void 0)}let s=e.allPiecesByPlayer(e.currentPlayer());for(let i=0;i<s.length;i++){let o=s[i],l=Cc(o.squareIndex);if(!(o.healthPoints<=0)){n.state.pieces.get(l);let u={role:N_(o.type),color:w_(o.type),healthPoints:o.healthPoints};t.set(l,u)}}let r=e.allPiecesByPlayer(1-e.currentPlayer());for(let i=0;i<r.length;i++){let o=r[i],l=Cc(o.squareIndex);if(!(o.healthPoints<=0)){let u={role:N_(o.type),color:w_(o.type),healthPoints:o.healthPoints};t.set(l,u)}}n.setPieces(t)}function T_(n){const e=new Map;for(let t=0;t<jo;t++){const s=n.legalActionsBySquare(t);if(s.length){let r=Cc(t);e.set(r,s.map(i=>Cc(i.dstIdx)))}}return e}function Hc(n){return!!n&&n instanceof Object&&!(n instanceof Array)&&!(n instanceof Function)}function Vp(n){return Hc(n)?Object.fromEntries(Object.entries(n).map(([e,t])=>[e,Vp(t)])):n}function ZE(n,e){const t={...n,...e};for(const s in t)t[s]=Hc(n==null?void 0:n[s])&&Hc(e==null?void 0:e[s])?ZE(n[s],e[s]):Vp(t[s]);return t}function QE(n,e){const t={};for(const s in e)if(Hc(n==null?void 0:n[s])&&Hc(e==null?void 0:e[s])){const r=QE(n[s],e[s]);Object.keys(r).length>0&&(t[s]=r)}else(n==null?void 0:n[s])!==e[s]&&(t[s]=e[s]);return t}const Oz=new Map([["b1",["a3","c3"]],["g1",["f3","h3"]],["a2",["a3","a4"]],["b2",["b3","b4"]],["c2",["c3","c4"]],["d2",["d3","d4"]],["e2",["e3","e4"]],["f2",["f3","f4"]],["g2",["g3","g4"]],["h2",["h3","h4"]]]);let Rz=new kc({});const Vz=Rz.boardToString(),Pz={fen:Vz,orientation:"white",turnColor:"white",coordinates:!1,autoCastle:!0,viewOnly:!1,disableContextMenu:!1,addPieceZIndex:!1,blockTouchScroll:!1,highlight:{lastMove:!0,check:!0},animation:{enabled:!0,duration:300},lastMove:void 0,movable:{free:!1,color:"white",showDests:!0,dests:Oz,events:{after:()=>{},afterNewPiece:void 0},rookCastle:!0},premovable:{enabled:!0,showDests:!0,castle:!0,events:{set:void 0,unset:void 0}},predroppable:{enabled:!1,events:{set:void 0,unset:void 0}},draggable:{enabled:!0,distance:3,autoDistance:!0,showGhost:!0,deleteOnDropOff:!1},selectable:{enabled:!0},events:{change:void 0,move:void 0,dropNewPiece:void 0,select:void 0,insert:void 0},drawable:{enabled:!0,visible:!0,defaultSnapToValidMove:!0,eraseOnClick:!0,shapes:[],autoShapes:[],brushes:{green:{key:"g",color:"#15781B",opacity:1,lineWidth:10},red:{key:"r",color:"#882020",opacity:1,lineWidth:10},blue:{key:"b",color:"#003088",opacity:1,lineWidth:10},yellow:{key:"y",color:"#e68f00",opacity:1,lineWidth:10},paleBlue:{key:"pb",color:"#003088",opacity:.4,lineWidth:15},paleGreen:{key:"pg",color:"#15781B",opacity:.4,lineWidth:15},paleRed:{key:"pr",color:"#882020",opacity:.4,lineWidth:15},paleGrey:{key:"pgr",color:"#4a4a4a",opacity:.35,lineWidth:15}}}},Fz=8,zz=8,Mz=7*8+8,Ho=Fz*zz*Mz+1,S_=Ho-1,Wz=2,v_=1;class Pp{}Mt(Pp,"moveIndexToSrcAndDstSquare",[[0,8],[0,16],[0,24],[0,32],[0,40],[0,48],[0,56],[0,9],[0,18],[0,27],[0,36],[0,45],[0,54],[0,63],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,-7],[0,-14],[0,-21],[0,-28],[0,-35],[0,-42],[0,-49],[0,-8],[0,-16],[0,-24],[0,-32],[0,-40],[0,-48],[0,-56],[0,-9],[0,-18],[0,-27],[0,-36],[0,-45],[0,-54],[0,-63],[0,-1],[0,-2],[0,-3],[0,-4],[0,-5],[0,-6],[0,-7],[0,7],[0,14],[0,21],[0,28],[0,35],[0,42],[0,49],[0,17],[0,10],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[1,9],[1,17],[1,25],[1,33],[1,41],[1,49],[1,57],[1,10],[1,19],[1,28],[1,37],[1,46],[1,55],[1,64],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,-6],[1,-13],[1,-20],[1,-27],[1,-34],[1,-41],[1,-48],[1,-7],[1,-15],[1,-23],[1,-31],[1,-39],[1,-47],[1,-55],[1,-8],[1,-17],[1,-26],[1,-35],[1,-44],[1,-53],[1,-62],[1,0],[1,-1],[1,-2],[1,-3],[1,-4],[1,-5],[1,-6],[1,8],[1,15],[1,22],[1,29],[1,36],[1,43],[1,50],[1,18],[1,11],[0,0],[0,0],[0,0],[0,0],[0,0],[1,16],[2,10],[2,18],[2,26],[2,34],[2,42],[2,50],[2,58],[2,11],[2,20],[2,29],[2,38],[2,47],[2,56],[2,65],[2,3],[2,4],[2,5],[2,6],[2,7],[2,8],[2,9],[2,-5],[2,-12],[2,-19],[2,-26],[2,-33],[2,-40],[2,-47],[2,-6],[2,-14],[2,-22],[2,-30],[2,-38],[2,-46],[2,-54],[2,-7],[2,-16],[2,-25],[2,-34],[2,-43],[2,-52],[2,-61],[2,1],[2,0],[2,-1],[2,-2],[2,-3],[2,-4],[2,-5],[2,9],[2,16],[2,23],[2,30],[2,37],[2,44],[2,51],[2,19],[2,12],[0,0],[0,0],[0,0],[0,0],[2,8],[2,17],[3,11],[3,19],[3,27],[3,35],[3,43],[3,51],[3,59],[3,12],[3,21],[3,30],[3,39],[3,48],[3,57],[3,66],[3,4],[3,5],[3,6],[3,7],[3,8],[3,9],[3,10],[3,-4],[3,-11],[3,-18],[3,-25],[3,-32],[3,-39],[3,-46],[3,-5],[3,-13],[3,-21],[3,-29],[3,-37],[3,-45],[3,-53],[3,-6],[3,-15],[3,-24],[3,-33],[3,-42],[3,-51],[3,-60],[3,2],[3,1],[3,0],[3,-1],[3,-2],[3,-3],[3,-4],[3,10],[3,17],[3,24],[3,31],[3,38],[3,45],[3,52],[3,20],[3,13],[0,0],[0,0],[0,0],[0,0],[3,9],[3,18],[4,12],[4,20],[4,28],[4,36],[4,44],[4,52],[4,60],[4,13],[4,22],[4,31],[4,40],[4,49],[4,58],[4,67],[4,5],[4,6],[4,7],[4,8],[4,9],[4,10],[4,11],[4,-3],[4,-10],[4,-17],[4,-24],[4,-31],[4,-38],[4,-45],[4,-4],[4,-12],[4,-20],[4,-28],[4,-36],[4,-44],[4,-52],[4,-5],[4,-14],[4,-23],[4,-32],[4,-41],[4,-50],[4,-59],[4,3],[4,2],[4,1],[4,0],[4,-1],[4,-2],[4,-3],[4,11],[4,18],[4,25],[4,32],[4,39],[4,46],[4,53],[4,21],[4,14],[0,0],[0,0],[0,0],[0,0],[4,10],[4,19],[5,13],[5,21],[5,29],[5,37],[5,45],[5,53],[5,61],[5,14],[5,23],[5,32],[5,41],[5,50],[5,59],[5,68],[5,6],[5,7],[5,8],[5,9],[5,10],[5,11],[5,12],[5,-2],[5,-9],[5,-16],[5,-23],[5,-30],[5,-37],[5,-44],[5,-3],[5,-11],[5,-19],[5,-27],[5,-35],[5,-43],[5,-51],[5,-4],[5,-13],[5,-22],[5,-31],[5,-40],[5,-49],[5,-58],[5,4],[5,3],[5,2],[5,1],[5,0],[5,-1],[5,-2],[5,12],[5,19],[5,26],[5,33],[5,40],[5,47],[5,54],[5,22],[5,15],[0,0],[0,0],[0,0],[0,0],[5,11],[5,20],[6,14],[6,22],[6,30],[6,38],[6,46],[6,54],[6,62],[6,15],[6,24],[6,33],[6,42],[6,51],[6,60],[6,69],[6,7],[6,8],[6,9],[6,10],[6,11],[6,12],[6,13],[6,-1],[6,-8],[6,-15],[6,-22],[6,-29],[6,-36],[6,-43],[6,-2],[6,-10],[6,-18],[6,-26],[6,-34],[6,-42],[6,-50],[6,-3],[6,-12],[6,-21],[6,-30],[6,-39],[6,-48],[6,-57],[6,5],[6,4],[6,3],[6,2],[6,1],[6,0],[6,-1],[6,13],[6,20],[6,27],[6,34],[6,41],[6,48],[6,55],[6,23],[0,0],[0,0],[0,0],[0,0],[0,0],[6,12],[6,21],[7,15],[7,23],[7,31],[7,39],[7,47],[7,55],[7,63],[7,16],[7,25],[7,34],[7,43],[7,52],[7,61],[7,70],[7,8],[7,9],[7,10],[7,11],[7,12],[7,13],[7,14],[7,0],[7,-7],[7,-14],[7,-21],[7,-28],[7,-35],[7,-42],[7,-1],[7,-9],[7,-17],[7,-25],[7,-33],[7,-41],[7,-49],[7,-2],[7,-11],[7,-20],[7,-29],[7,-38],[7,-47],[7,-56],[7,6],[7,5],[7,4],[7,3],[7,2],[7,1],[7,0],[7,14],[7,21],[7,28],[7,35],[7,42],[7,49],[7,56],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[7,13],[7,22],[8,16],[8,24],[8,32],[8,40],[8,48],[8,56],[8,64],[8,17],[8,26],[8,35],[8,44],[8,53],[8,62],[8,71],[8,9],[8,10],[8,11],[8,12],[8,13],[8,14],[8,15],[8,1],[8,-6],[8,-13],[8,-20],[8,-27],[8,-34],[8,-41],[8,0],[8,-8],[8,-16],[8,-24],[8,-32],[8,-40],[8,-48],[8,-1],[8,-10],[8,-19],[8,-28],[8,-37],[8,-46],[8,-55],[8,7],[8,6],[8,5],[8,4],[8,3],[8,2],[8,1],[8,15],[8,22],[8,29],[8,36],[8,43],[8,50],[8,57],[8,25],[8,18],[8,2],[0,0],[0,0],[0,0],[0,0],[0,0],[9,17],[9,25],[9,33],[9,41],[9,49],[9,57],[9,65],[9,18],[9,27],[9,36],[9,45],[9,54],[9,63],[9,72],[9,10],[9,11],[9,12],[9,13],[9,14],[9,15],[9,16],[9,2],[9,-5],[9,-12],[9,-19],[9,-26],[9,-33],[9,-40],[9,1],[9,-7],[9,-15],[9,-23],[9,-31],[9,-39],[9,-47],[9,0],[9,-9],[9,-18],[9,-27],[9,-36],[9,-45],[9,-54],[9,8],[9,7],[9,6],[9,5],[9,4],[9,3],[9,2],[9,16],[9,23],[9,30],[9,37],[9,44],[9,51],[9,58],[9,26],[9,19],[9,3],[0,0],[0,0],[0,0],[0,0],[9,24],[10,18],[10,26],[10,34],[10,42],[10,50],[10,58],[10,66],[10,19],[10,28],[10,37],[10,46],[10,55],[10,64],[10,73],[10,11],[10,12],[10,13],[10,14],[10,15],[10,16],[10,17],[10,3],[10,-4],[10,-11],[10,-18],[10,-25],[10,-32],[10,-39],[10,2],[10,-6],[10,-14],[10,-22],[10,-30],[10,-38],[10,-46],[10,1],[10,-8],[10,-17],[10,-26],[10,-35],[10,-44],[10,-53],[10,9],[10,8],[10,7],[10,6],[10,5],[10,4],[10,3],[10,17],[10,24],[10,31],[10,38],[10,45],[10,52],[10,59],[10,27],[10,20],[10,4],[0,0],[0,0],[10,0],[10,16],[10,25],[11,19],[11,27],[11,35],[11,43],[11,51],[11,59],[11,67],[11,20],[11,29],[11,38],[11,47],[11,56],[11,65],[11,74],[11,12],[11,13],[11,14],[11,15],[11,16],[11,17],[11,18],[11,4],[11,-3],[11,-10],[11,-17],[11,-24],[11,-31],[11,-38],[11,3],[11,-5],[11,-13],[11,-21],[11,-29],[11,-37],[11,-45],[11,2],[11,-7],[11,-16],[11,-25],[11,-34],[11,-43],[11,-52],[11,10],[11,9],[11,8],[11,7],[11,6],[11,5],[11,4],[11,18],[11,25],[11,32],[11,39],[11,46],[11,53],[11,60],[11,28],[11,21],[11,5],[0,0],[0,0],[11,1],[11,17],[11,26],[12,20],[12,28],[12,36],[12,44],[12,52],[12,60],[12,68],[12,21],[12,30],[12,39],[12,48],[12,57],[12,66],[12,75],[12,13],[12,14],[12,15],[12,16],[12,17],[12,18],[12,19],[12,5],[12,-2],[12,-9],[12,-16],[12,-23],[12,-30],[12,-37],[12,4],[12,-4],[12,-12],[12,-20],[12,-28],[12,-36],[12,-44],[12,3],[12,-6],[12,-15],[12,-24],[12,-33],[12,-42],[12,-51],[12,11],[12,10],[12,9],[12,8],[12,7],[12,6],[12,5],[12,19],[12,26],[12,33],[12,40],[12,47],[12,54],[12,61],[12,29],[12,22],[12,6],[0,0],[0,0],[12,2],[12,18],[12,27],[13,21],[13,29],[13,37],[13,45],[13,53],[13,61],[13,69],[13,22],[13,31],[13,40],[13,49],[13,58],[13,67],[13,76],[13,14],[13,15],[13,16],[13,17],[13,18],[13,19],[13,20],[13,6],[13,-1],[13,-8],[13,-15],[13,-22],[13,-29],[13,-36],[13,5],[13,-3],[13,-11],[13,-19],[13,-27],[13,-35],[13,-43],[13,4],[13,-5],[13,-14],[13,-23],[13,-32],[13,-41],[13,-50],[13,12],[13,11],[13,10],[13,9],[13,8],[13,7],[13,6],[13,20],[13,27],[13,34],[13,41],[13,48],[13,55],[13,62],[13,30],[13,23],[13,7],[0,0],[0,0],[13,3],[13,19],[13,28],[14,22],[14,30],[14,38],[14,46],[14,54],[14,62],[14,70],[14,23],[14,32],[14,41],[14,50],[14,59],[14,68],[14,77],[14,15],[14,16],[14,17],[14,18],[14,19],[14,20],[14,21],[14,7],[14,0],[14,-7],[14,-14],[14,-21],[14,-28],[14,-35],[14,6],[14,-2],[14,-10],[14,-18],[14,-26],[14,-34],[14,-42],[14,5],[14,-4],[14,-13],[14,-22],[14,-31],[14,-40],[14,-49],[14,13],[14,12],[14,11],[14,10],[14,9],[14,8],[14,7],[14,21],[14,28],[14,35],[14,42],[14,49],[14,56],[14,63],[14,31],[0,0],[0,0],[0,0],[0,0],[14,4],[14,20],[14,29],[15,23],[15,31],[15,39],[15,47],[15,55],[15,63],[15,71],[15,24],[15,33],[15,42],[15,51],[15,60],[15,69],[15,78],[15,16],[15,17],[15,18],[15,19],[15,20],[15,21],[15,22],[15,8],[15,1],[15,-6],[15,-13],[15,-20],[15,-27],[15,-34],[15,7],[15,-1],[15,-9],[15,-17],[15,-25],[15,-33],[15,-41],[15,6],[15,-3],[15,-12],[15,-21],[15,-30],[15,-39],[15,-48],[15,14],[15,13],[15,12],[15,11],[15,10],[15,9],[15,8],[15,22],[15,29],[15,36],[15,43],[15,50],[15,57],[15,64],[0,0],[0,0],[0,0],[0,0],[0,0],[15,5],[15,21],[15,30],[16,24],[16,32],[16,40],[16,48],[16,56],[16,64],[16,72],[16,25],[16,34],[16,43],[16,52],[16,61],[16,70],[16,79],[16,17],[16,18],[16,19],[16,20],[16,21],[16,22],[16,23],[16,9],[16,2],[16,-5],[16,-12],[16,-19],[16,-26],[16,-33],[16,8],[16,0],[16,-8],[16,-16],[16,-24],[16,-32],[16,-40],[16,7],[16,-2],[16,-11],[16,-20],[16,-29],[16,-38],[16,-47],[16,15],[16,14],[16,13],[16,12],[16,11],[16,10],[16,9],[16,23],[16,30],[16,37],[16,44],[16,51],[16,58],[16,65],[16,33],[16,26],[16,10],[16,1],[0,0],[0,0],[0,0],[0,0],[17,25],[17,33],[17,41],[17,49],[17,57],[17,65],[17,73],[17,26],[17,35],[17,44],[17,53],[17,62],[17,71],[17,80],[17,18],[17,19],[17,20],[17,21],[17,22],[17,23],[17,24],[17,10],[17,3],[17,-4],[17,-11],[17,-18],[17,-25],[17,-32],[17,9],[17,1],[17,-7],[17,-15],[17,-23],[17,-31],[17,-39],[17,8],[17,-1],[17,-10],[17,-19],[17,-28],[17,-37],[17,-46],[17,16],[17,15],[17,14],[17,13],[17,12],[17,11],[17,10],[17,24],[17,31],[17,38],[17,45],[17,52],[17,59],[17,66],[17,34],[17,27],[17,11],[17,2],[17,0],[0,0],[0,0],[17,32],[18,26],[18,34],[18,42],[18,50],[18,58],[18,66],[18,74],[18,27],[18,36],[18,45],[18,54],[18,63],[18,72],[18,81],[18,19],[18,20],[18,21],[18,22],[18,23],[18,24],[18,25],[18,11],[18,4],[18,-3],[18,-10],[18,-17],[18,-24],[18,-31],[18,10],[18,2],[18,-6],[18,-14],[18,-22],[18,-30],[18,-38],[18,9],[18,0],[18,-9],[18,-18],[18,-27],[18,-36],[18,-45],[18,17],[18,16],[18,15],[18,14],[18,13],[18,12],[18,11],[18,25],[18,32],[18,39],[18,46],[18,53],[18,60],[18,67],[18,35],[18,28],[18,12],[18,3],[18,1],[18,8],[18,24],[18,33],[19,27],[19,35],[19,43],[19,51],[19,59],[19,67],[19,75],[19,28],[19,37],[19,46],[19,55],[19,64],[19,73],[19,82],[19,20],[19,21],[19,22],[19,23],[19,24],[19,25],[19,26],[19,12],[19,5],[19,-2],[19,-9],[19,-16],[19,-23],[19,-30],[19,11],[19,3],[19,-5],[19,-13],[19,-21],[19,-29],[19,-37],[19,10],[19,1],[19,-8],[19,-17],[19,-26],[19,-35],[19,-44],[19,18],[19,17],[19,16],[19,15],[19,14],[19,13],[19,12],[19,26],[19,33],[19,40],[19,47],[19,54],[19,61],[19,68],[19,36],[19,29],[19,13],[19,4],[19,2],[19,9],[19,25],[19,34],[20,28],[20,36],[20,44],[20,52],[20,60],[20,68],[20,76],[20,29],[20,38],[20,47],[20,56],[20,65],[20,74],[20,83],[20,21],[20,22],[20,23],[20,24],[20,25],[20,26],[20,27],[20,13],[20,6],[20,-1],[20,-8],[20,-15],[20,-22],[20,-29],[20,12],[20,4],[20,-4],[20,-12],[20,-20],[20,-28],[20,-36],[20,11],[20,2],[20,-7],[20,-16],[20,-25],[20,-34],[20,-43],[20,19],[20,18],[20,17],[20,16],[20,15],[20,14],[20,13],[20,27],[20,34],[20,41],[20,48],[20,55],[20,62],[20,69],[20,37],[20,30],[20,14],[20,5],[20,3],[20,10],[20,26],[20,35],[21,29],[21,37],[21,45],[21,53],[21,61],[21,69],[21,77],[21,30],[21,39],[21,48],[21,57],[21,66],[21,75],[21,84],[21,22],[21,23],[21,24],[21,25],[21,26],[21,27],[21,28],[21,14],[21,7],[21,0],[21,-7],[21,-14],[21,-21],[21,-28],[21,13],[21,5],[21,-3],[21,-11],[21,-19],[21,-27],[21,-35],[21,12],[21,3],[21,-6],[21,-15],[21,-24],[21,-33],[21,-42],[21,20],[21,19],[21,18],[21,17],[21,16],[21,15],[21,14],[21,28],[21,35],[21,42],[21,49],[21,56],[21,63],[21,70],[21,38],[21,31],[21,15],[21,6],[21,4],[21,11],[21,27],[21,36],[22,30],[22,38],[22,46],[22,54],[22,62],[22,70],[22,78],[22,31],[22,40],[22,49],[22,58],[22,67],[22,76],[22,85],[22,23],[22,24],[22,25],[22,26],[22,27],[22,28],[22,29],[22,15],[22,8],[22,1],[22,-6],[22,-13],[22,-20],[22,-27],[22,14],[22,6],[22,-2],[22,-10],[22,-18],[22,-26],[22,-34],[22,13],[22,4],[22,-5],[22,-14],[22,-23],[22,-32],[22,-41],[22,21],[22,20],[22,19],[22,18],[22,17],[22,16],[22,15],[22,29],[22,36],[22,43],[22,50],[22,57],[22,64],[22,71],[22,39],[0,0],[0,0],[22,7],[22,5],[22,12],[22,28],[22,37],[23,31],[23,39],[23,47],[23,55],[23,63],[23,71],[23,79],[23,32],[23,41],[23,50],[23,59],[23,68],[23,77],[23,86],[23,24],[23,25],[23,26],[23,27],[23,28],[23,29],[23,30],[23,16],[23,9],[23,2],[23,-5],[23,-12],[23,-19],[23,-26],[23,15],[23,7],[23,-1],[23,-9],[23,-17],[23,-25],[23,-33],[23,14],[23,5],[23,-4],[23,-13],[23,-22],[23,-31],[23,-40],[23,22],[23,21],[23,20],[23,19],[23,18],[23,17],[23,16],[23,30],[23,37],[23,44],[23,51],[23,58],[23,65],[23,72],[0,0],[0,0],[0,0],[0,0],[23,6],[23,13],[23,29],[23,38],[24,32],[24,40],[24,48],[24,56],[24,64],[24,72],[24,80],[24,33],[24,42],[24,51],[24,60],[24,69],[24,78],[24,87],[24,25],[24,26],[24,27],[24,28],[24,29],[24,30],[24,31],[24,17],[24,10],[24,3],[24,-4],[24,-11],[24,-18],[24,-25],[24,16],[24,8],[24,0],[24,-8],[24,-16],[24,-24],[24,-32],[24,15],[24,6],[24,-3],[24,-12],[24,-21],[24,-30],[24,-39],[24,23],[24,22],[24,21],[24,20],[24,19],[24,18],[24,17],[24,31],[24,38],[24,45],[24,52],[24,59],[24,66],[24,73],[24,41],[24,34],[24,18],[24,9],[0,0],[0,0],[0,0],[0,0],[25,33],[25,41],[25,49],[25,57],[25,65],[25,73],[25,81],[25,34],[25,43],[25,52],[25,61],[25,70],[25,79],[25,88],[25,26],[25,27],[25,28],[25,29],[25,30],[25,31],[25,32],[25,18],[25,11],[25,4],[25,-3],[25,-10],[25,-17],[25,-24],[25,17],[25,9],[25,1],[25,-7],[25,-15],[25,-23],[25,-31],[25,16],[25,7],[25,-2],[25,-11],[25,-20],[25,-29],[25,-38],[25,24],[25,23],[25,22],[25,21],[25,20],[25,19],[25,18],[25,32],[25,39],[25,46],[25,53],[25,60],[25,67],[25,74],[25,42],[25,35],[25,19],[25,10],[25,8],[0,0],[0,0],[25,40],[26,34],[26,42],[26,50],[26,58],[26,66],[26,74],[26,82],[26,35],[26,44],[26,53],[26,62],[26,71],[26,80],[26,89],[26,27],[26,28],[26,29],[26,30],[26,31],[26,32],[26,33],[26,19],[26,12],[26,5],[26,-2],[26,-9],[26,-16],[26,-23],[26,18],[26,10],[26,2],[26,-6],[26,-14],[26,-22],[26,-30],[26,17],[26,8],[26,-1],[26,-10],[26,-19],[26,-28],[26,-37],[26,25],[26,24],[26,23],[26,22],[26,21],[26,20],[26,19],[26,33],[26,40],[26,47],[26,54],[26,61],[26,68],[26,75],[26,43],[26,36],[26,20],[26,11],[26,9],[26,16],[26,32],[26,41],[27,35],[27,43],[27,51],[27,59],[27,67],[27,75],[27,83],[27,36],[27,45],[27,54],[27,63],[27,72],[27,81],[27,90],[27,28],[27,29],[27,30],[27,31],[27,32],[27,33],[27,34],[27,20],[27,13],[27,6],[27,-1],[27,-8],[27,-15],[27,-22],[27,19],[27,11],[27,3],[27,-5],[27,-13],[27,-21],[27,-29],[27,18],[27,9],[27,0],[27,-9],[27,-18],[27,-27],[27,-36],[27,26],[27,25],[27,24],[27,23],[27,22],[27,21],[27,20],[27,34],[27,41],[27,48],[27,55],[27,62],[27,69],[27,76],[27,44],[27,37],[27,21],[27,12],[27,10],[27,17],[27,33],[27,42],[28,36],[28,44],[28,52],[28,60],[28,68],[28,76],[28,84],[28,37],[28,46],[28,55],[28,64],[28,73],[28,82],[28,91],[28,29],[28,30],[28,31],[28,32],[28,33],[28,34],[28,35],[28,21],[28,14],[28,7],[28,0],[28,-7],[28,-14],[28,-21],[28,20],[28,12],[28,4],[28,-4],[28,-12],[28,-20],[28,-28],[28,19],[28,10],[28,1],[28,-8],[28,-17],[28,-26],[28,-35],[28,27],[28,26],[28,25],[28,24],[28,23],[28,22],[28,21],[28,35],[28,42],[28,49],[28,56],[28,63],[28,70],[28,77],[28,45],[28,38],[28,22],[28,13],[28,11],[28,18],[28,34],[28,43],[29,37],[29,45],[29,53],[29,61],[29,69],[29,77],[29,85],[29,38],[29,47],[29,56],[29,65],[29,74],[29,83],[29,92],[29,30],[29,31],[29,32],[29,33],[29,34],[29,35],[29,36],[29,22],[29,15],[29,8],[29,1],[29,-6],[29,-13],[29,-20],[29,21],[29,13],[29,5],[29,-3],[29,-11],[29,-19],[29,-27],[29,20],[29,11],[29,2],[29,-7],[29,-16],[29,-25],[29,-34],[29,28],[29,27],[29,26],[29,25],[29,24],[29,23],[29,22],[29,36],[29,43],[29,50],[29,57],[29,64],[29,71],[29,78],[29,46],[29,39],[29,23],[29,14],[29,12],[29,19],[29,35],[29,44],[30,38],[30,46],[30,54],[30,62],[30,70],[30,78],[30,86],[30,39],[30,48],[30,57],[30,66],[30,75],[30,84],[30,93],[30,31],[30,32],[30,33],[30,34],[30,35],[30,36],[30,37],[30,23],[30,16],[30,9],[30,2],[30,-5],[30,-12],[30,-19],[30,22],[30,14],[30,6],[30,-2],[30,-10],[30,-18],[30,-26],[30,21],[30,12],[30,3],[30,-6],[30,-15],[30,-24],[30,-33],[30,29],[30,28],[30,27],[30,26],[30,25],[30,24],[30,23],[30,37],[30,44],[30,51],[30,58],[30,65],[30,72],[30,79],[30,47],[0,0],[0,0],[30,15],[30,13],[30,20],[30,36],[30,45],[31,39],[31,47],[31,55],[31,63],[31,71],[31,79],[31,87],[31,40],[31,49],[31,58],[31,67],[31,76],[31,85],[31,94],[31,32],[31,33],[31,34],[31,35],[31,36],[31,37],[31,38],[31,24],[31,17],[31,10],[31,3],[31,-4],[31,-11],[31,-18],[31,23],[31,15],[31,7],[31,-1],[31,-9],[31,-17],[31,-25],[31,22],[31,13],[31,4],[31,-5],[31,-14],[31,-23],[31,-32],[31,30],[31,29],[31,28],[31,27],[31,26],[31,25],[31,24],[31,38],[31,45],[31,52],[31,59],[31,66],[31,73],[31,80],[0,0],[0,0],[0,0],[0,0],[31,14],[31,21],[31,37],[31,46],[32,40],[32,48],[32,56],[32,64],[32,72],[32,80],[32,88],[32,41],[32,50],[32,59],[32,68],[32,77],[32,86],[32,95],[32,33],[32,34],[32,35],[32,36],[32,37],[32,38],[32,39],[32,25],[32,18],[32,11],[32,4],[32,-3],[32,-10],[32,-17],[32,24],[32,16],[32,8],[32,0],[32,-8],[32,-16],[32,-24],[32,23],[32,14],[32,5],[32,-4],[32,-13],[32,-22],[32,-31],[32,31],[32,30],[32,29],[32,28],[32,27],[32,26],[32,25],[32,39],[32,46],[32,53],[32,60],[32,67],[32,74],[32,81],[32,49],[32,42],[32,26],[32,17],[0,0],[0,0],[0,0],[0,0],[33,41],[33,49],[33,57],[33,65],[33,73],[33,81],[33,89],[33,42],[33,51],[33,60],[33,69],[33,78],[33,87],[33,96],[33,34],[33,35],[33,36],[33,37],[33,38],[33,39],[33,40],[33,26],[33,19],[33,12],[33,5],[33,-2],[33,-9],[33,-16],[33,25],[33,17],[33,9],[33,1],[33,-7],[33,-15],[33,-23],[33,24],[33,15],[33,6],[33,-3],[33,-12],[33,-21],[33,-30],[33,32],[33,31],[33,30],[33,29],[33,28],[33,27],[33,26],[33,40],[33,47],[33,54],[33,61],[33,68],[33,75],[33,82],[33,50],[33,43],[33,27],[33,18],[33,16],[0,0],[0,0],[33,48],[34,42],[34,50],[34,58],[34,66],[34,74],[34,82],[34,90],[34,43],[34,52],[34,61],[34,70],[34,79],[34,88],[34,97],[34,35],[34,36],[34,37],[34,38],[34,39],[34,40],[34,41],[34,27],[34,20],[34,13],[34,6],[34,-1],[34,-8],[34,-15],[34,26],[34,18],[34,10],[34,2],[34,-6],[34,-14],[34,-22],[34,25],[34,16],[34,7],[34,-2],[34,-11],[34,-20],[34,-29],[34,33],[34,32],[34,31],[34,30],[34,29],[34,28],[34,27],[34,41],[34,48],[34,55],[34,62],[34,69],[34,76],[34,83],[34,51],[34,44],[34,28],[34,19],[34,17],[34,24],[34,40],[34,49],[35,43],[35,51],[35,59],[35,67],[35,75],[35,83],[35,91],[35,44],[35,53],[35,62],[35,71],[35,80],[35,89],[35,98],[35,36],[35,37],[35,38],[35,39],[35,40],[35,41],[35,42],[35,28],[35,21],[35,14],[35,7],[35,0],[35,-7],[35,-14],[35,27],[35,19],[35,11],[35,3],[35,-5],[35,-13],[35,-21],[35,26],[35,17],[35,8],[35,-1],[35,-10],[35,-19],[35,-28],[35,34],[35,33],[35,32],[35,31],[35,30],[35,29],[35,28],[35,42],[35,49],[35,56],[35,63],[35,70],[35,77],[35,84],[35,52],[35,45],[35,29],[35,20],[35,18],[35,25],[35,41],[35,50],[36,44],[36,52],[36,60],[36,68],[36,76],[36,84],[36,92],[36,45],[36,54],[36,63],[36,72],[36,81],[36,90],[36,99],[36,37],[36,38],[36,39],[36,40],[36,41],[36,42],[36,43],[36,29],[36,22],[36,15],[36,8],[36,1],[36,-6],[36,-13],[36,28],[36,20],[36,12],[36,4],[36,-4],[36,-12],[36,-20],[36,27],[36,18],[36,9],[36,0],[36,-9],[36,-18],[36,-27],[36,35],[36,34],[36,33],[36,32],[36,31],[36,30],[36,29],[36,43],[36,50],[36,57],[36,64],[36,71],[36,78],[36,85],[36,53],[36,46],[36,30],[36,21],[36,19],[36,26],[36,42],[36,51],[37,45],[37,53],[37,61],[37,69],[37,77],[37,85],[37,93],[37,46],[37,55],[37,64],[37,73],[37,82],[37,91],[37,100],[37,38],[37,39],[37,40],[37,41],[37,42],[37,43],[37,44],[37,30],[37,23],[37,16],[37,9],[37,2],[37,-5],[37,-12],[37,29],[37,21],[37,13],[37,5],[37,-3],[37,-11],[37,-19],[37,28],[37,19],[37,10],[37,1],[37,-8],[37,-17],[37,-26],[37,36],[37,35],[37,34],[37,33],[37,32],[37,31],[37,30],[37,44],[37,51],[37,58],[37,65],[37,72],[37,79],[37,86],[37,54],[37,47],[37,31],[37,22],[37,20],[37,27],[37,43],[37,52],[38,46],[38,54],[38,62],[38,70],[38,78],[38,86],[38,94],[38,47],[38,56],[38,65],[38,74],[38,83],[38,92],[38,101],[38,39],[38,40],[38,41],[38,42],[38,43],[38,44],[38,45],[38,31],[38,24],[38,17],[38,10],[38,3],[38,-4],[38,-11],[38,30],[38,22],[38,14],[38,6],[38,-2],[38,-10],[38,-18],[38,29],[38,20],[38,11],[38,2],[38,-7],[38,-16],[38,-25],[38,37],[38,36],[38,35],[38,34],[38,33],[38,32],[38,31],[38,45],[38,52],[38,59],[38,66],[38,73],[38,80],[38,87],[38,55],[0,0],[0,0],[38,23],[38,21],[38,28],[38,44],[38,53],[39,47],[39,55],[39,63],[39,71],[39,79],[39,87],[39,95],[39,48],[39,57],[39,66],[39,75],[39,84],[39,93],[39,102],[39,40],[39,41],[39,42],[39,43],[39,44],[39,45],[39,46],[39,32],[39,25],[39,18],[39,11],[39,4],[39,-3],[39,-10],[39,31],[39,23],[39,15],[39,7],[39,-1],[39,-9],[39,-17],[39,30],[39,21],[39,12],[39,3],[39,-6],[39,-15],[39,-24],[39,38],[39,37],[39,36],[39,35],[39,34],[39,33],[39,32],[39,46],[39,53],[39,60],[39,67],[39,74],[39,81],[39,88],[0,0],[0,0],[0,0],[0,0],[39,22],[39,29],[39,45],[39,54],[40,48],[40,56],[40,64],[40,72],[40,80],[40,88],[40,96],[40,49],[40,58],[40,67],[40,76],[40,85],[40,94],[40,103],[40,41],[40,42],[40,43],[40,44],[40,45],[40,46],[40,47],[40,33],[40,26],[40,19],[40,12],[40,5],[40,-2],[40,-9],[40,32],[40,24],[40,16],[40,8],[40,0],[40,-8],[40,-16],[40,31],[40,22],[40,13],[40,4],[40,-5],[40,-14],[40,-23],[40,39],[40,38],[40,37],[40,36],[40,35],[40,34],[40,33],[40,47],[40,54],[40,61],[40,68],[40,75],[40,82],[40,89],[40,57],[40,50],[40,34],[40,25],[0,0],[0,0],[0,0],[0,0],[41,49],[41,57],[41,65],[41,73],[41,81],[41,89],[41,97],[41,50],[41,59],[41,68],[41,77],[41,86],[41,95],[41,104],[41,42],[41,43],[41,44],[41,45],[41,46],[41,47],[41,48],[41,34],[41,27],[41,20],[41,13],[41,6],[41,-1],[41,-8],[41,33],[41,25],[41,17],[41,9],[41,1],[41,-7],[41,-15],[41,32],[41,23],[41,14],[41,5],[41,-4],[41,-13],[41,-22],[41,40],[41,39],[41,38],[41,37],[41,36],[41,35],[41,34],[41,48],[41,55],[41,62],[41,69],[41,76],[41,83],[41,90],[41,58],[41,51],[41,35],[41,26],[41,24],[0,0],[0,0],[41,56],[42,50],[42,58],[42,66],[42,74],[42,82],[42,90],[42,98],[42,51],[42,60],[42,69],[42,78],[42,87],[42,96],[42,105],[42,43],[42,44],[42,45],[42,46],[42,47],[42,48],[42,49],[42,35],[42,28],[42,21],[42,14],[42,7],[42,0],[42,-7],[42,34],[42,26],[42,18],[42,10],[42,2],[42,-6],[42,-14],[42,33],[42,24],[42,15],[42,6],[42,-3],[42,-12],[42,-21],[42,41],[42,40],[42,39],[42,38],[42,37],[42,36],[42,35],[42,49],[42,56],[42,63],[42,70],[42,77],[42,84],[42,91],[42,59],[42,52],[42,36],[42,27],[42,25],[42,32],[42,48],[42,57],[43,51],[43,59],[43,67],[43,75],[43,83],[43,91],[43,99],[43,52],[43,61],[43,70],[43,79],[43,88],[43,97],[43,106],[43,44],[43,45],[43,46],[43,47],[43,48],[43,49],[43,50],[43,36],[43,29],[43,22],[43,15],[43,8],[43,1],[43,-6],[43,35],[43,27],[43,19],[43,11],[43,3],[43,-5],[43,-13],[43,34],[43,25],[43,16],[43,7],[43,-2],[43,-11],[43,-20],[43,42],[43,41],[43,40],[43,39],[43,38],[43,37],[43,36],[43,50],[43,57],[43,64],[43,71],[43,78],[43,85],[43,92],[43,60],[43,53],[43,37],[43,28],[43,26],[43,33],[43,49],[43,58],[44,52],[44,60],[44,68],[44,76],[44,84],[44,92],[44,100],[44,53],[44,62],[44,71],[44,80],[44,89],[44,98],[44,107],[44,45],[44,46],[44,47],[44,48],[44,49],[44,50],[44,51],[44,37],[44,30],[44,23],[44,16],[44,9],[44,2],[44,-5],[44,36],[44,28],[44,20],[44,12],[44,4],[44,-4],[44,-12],[44,35],[44,26],[44,17],[44,8],[44,-1],[44,-10],[44,-19],[44,43],[44,42],[44,41],[44,40],[44,39],[44,38],[44,37],[44,51],[44,58],[44,65],[44,72],[44,79],[44,86],[44,93],[44,61],[44,54],[44,38],[44,29],[44,27],[44,34],[44,50],[44,59],[45,53],[45,61],[45,69],[45,77],[45,85],[45,93],[45,101],[45,54],[45,63],[45,72],[45,81],[45,90],[45,99],[45,108],[45,46],[45,47],[45,48],[45,49],[45,50],[45,51],[45,52],[45,38],[45,31],[45,24],[45,17],[45,10],[45,3],[45,-4],[45,37],[45,29],[45,21],[45,13],[45,5],[45,-3],[45,-11],[45,36],[45,27],[45,18],[45,9],[45,0],[45,-9],[45,-18],[45,44],[45,43],[45,42],[45,41],[45,40],[45,39],[45,38],[45,52],[45,59],[45,66],[45,73],[45,80],[45,87],[45,94],[45,62],[45,55],[45,39],[45,30],[45,28],[45,35],[45,51],[45,60],[46,54],[46,62],[46,70],[46,78],[46,86],[46,94],[46,102],[46,55],[46,64],[46,73],[46,82],[46,91],[46,100],[46,109],[46,47],[46,48],[46,49],[46,50],[46,51],[46,52],[46,53],[46,39],[46,32],[46,25],[46,18],[46,11],[46,4],[46,-3],[46,38],[46,30],[46,22],[46,14],[46,6],[46,-2],[46,-10],[46,37],[46,28],[46,19],[46,10],[46,1],[46,-8],[46,-17],[46,45],[46,44],[46,43],[46,42],[46,41],[46,40],[46,39],[46,53],[46,60],[46,67],[46,74],[46,81],[46,88],[46,95],[46,63],[0,0],[0,0],[46,31],[46,29],[46,36],[46,52],[46,61],[47,55],[47,63],[47,71],[47,79],[47,87],[47,95],[47,103],[47,56],[47,65],[47,74],[47,83],[47,92],[47,101],[47,110],[47,48],[47,49],[47,50],[47,51],[47,52],[47,53],[47,54],[47,40],[47,33],[47,26],[47,19],[47,12],[47,5],[47,-2],[47,39],[47,31],[47,23],[47,15],[47,7],[47,-1],[47,-9],[47,38],[47,29],[47,20],[47,11],[47,2],[47,-7],[47,-16],[47,46],[47,45],[47,44],[47,43],[47,42],[47,41],[47,40],[47,54],[47,61],[47,68],[47,75],[47,82],[47,89],[47,96],[0,0],[0,0],[0,0],[0,0],[47,30],[47,37],[47,53],[47,62],[48,56],[48,64],[48,72],[48,80],[48,88],[48,96],[48,104],[48,57],[48,66],[48,75],[48,84],[48,93],[48,102],[48,111],[48,49],[48,50],[48,51],[48,52],[48,53],[48,54],[48,55],[48,41],[48,34],[48,27],[48,20],[48,13],[48,6],[48,-1],[48,40],[48,32],[48,24],[48,16],[48,8],[48,0],[48,-8],[48,39],[48,30],[48,21],[48,12],[48,3],[48,-6],[48,-15],[48,47],[48,46],[48,45],[48,44],[48,43],[48,42],[48,41],[48,55],[48,62],[48,69],[48,76],[48,83],[48,90],[48,97],[0,0],[48,58],[48,42],[48,33],[0,0],[0,0],[0,0],[0,0],[49,57],[49,65],[49,73],[49,81],[49,89],[49,97],[49,105],[49,58],[49,67],[49,76],[49,85],[49,94],[49,103],[49,112],[49,50],[49,51],[49,52],[49,53],[49,54],[49,55],[49,56],[49,42],[49,35],[49,28],[49,21],[49,14],[49,7],[49,0],[49,41],[49,33],[49,25],[49,17],[49,9],[49,1],[49,-7],[49,40],[49,31],[49,22],[49,13],[49,4],[49,-5],[49,-14],[49,48],[49,47],[49,46],[49,45],[49,44],[49,43],[49,42],[49,56],[49,63],[49,70],[49,77],[49,84],[49,91],[49,98],[0,0],[49,59],[49,43],[49,34],[49,32],[0,0],[0,0],[0,0],[50,58],[50,66],[50,74],[50,82],[50,90],[50,98],[50,106],[50,59],[50,68],[50,77],[50,86],[50,95],[50,104],[50,113],[50,51],[50,52],[50,53],[50,54],[50,55],[50,56],[50,57],[50,43],[50,36],[50,29],[50,22],[50,15],[50,8],[50,1],[50,42],[50,34],[50,26],[50,18],[50,10],[50,2],[50,-6],[50,41],[50,32],[50,23],[50,14],[50,5],[50,-4],[50,-13],[50,49],[50,48],[50,47],[50,46],[50,45],[50,44],[50,43],[50,57],[50,64],[50,71],[50,78],[50,85],[50,92],[50,99],[0,0],[50,60],[50,44],[50,35],[50,33],[50,40],[50,56],[0,0],[51,59],[51,67],[51,75],[51,83],[51,91],[51,99],[51,107],[51,60],[51,69],[51,78],[51,87],[51,96],[51,105],[51,114],[51,52],[51,53],[51,54],[51,55],[51,56],[51,57],[51,58],[51,44],[51,37],[51,30],[51,23],[51,16],[51,9],[51,2],[51,43],[51,35],[51,27],[51,19],[51,11],[51,3],[51,-5],[51,42],[51,33],[51,24],[51,15],[51,6],[51,-3],[51,-12],[51,50],[51,49],[51,48],[51,47],[51,46],[51,45],[51,44],[51,58],[51,65],[51,72],[51,79],[51,86],[51,93],[51,100],[0,0],[51,61],[51,45],[51,36],[51,34],[51,41],[51,57],[0,0],[52,60],[52,68],[52,76],[52,84],[52,92],[52,100],[52,108],[52,61],[52,70],[52,79],[52,88],[52,97],[52,106],[52,115],[52,53],[52,54],[52,55],[52,56],[52,57],[52,58],[52,59],[52,45],[52,38],[52,31],[52,24],[52,17],[52,10],[52,3],[52,44],[52,36],[52,28],[52,20],[52,12],[52,4],[52,-4],[52,43],[52,34],[52,25],[52,16],[52,7],[52,-2],[52,-11],[52,51],[52,50],[52,49],[52,48],[52,47],[52,46],[52,45],[52,59],[52,66],[52,73],[52,80],[52,87],[52,94],[52,101],[0,0],[52,62],[52,46],[52,37],[52,35],[52,42],[52,58],[0,0],[53,61],[53,69],[53,77],[53,85],[53,93],[53,101],[53,109],[53,62],[53,71],[53,80],[53,89],[53,98],[53,107],[53,116],[53,54],[53,55],[53,56],[53,57],[53,58],[53,59],[53,60],[53,46],[53,39],[53,32],[53,25],[53,18],[53,11],[53,4],[53,45],[53,37],[53,29],[53,21],[53,13],[53,5],[53,-3],[53,44],[53,35],[53,26],[53,17],[53,8],[53,-1],[53,-10],[53,52],[53,51],[53,50],[53,49],[53,48],[53,47],[53,46],[53,60],[53,67],[53,74],[53,81],[53,88],[53,95],[53,102],[0,0],[53,63],[53,47],[53,38],[53,36],[53,43],[53,59],[0,0],[54,62],[54,70],[54,78],[54,86],[54,94],[54,102],[54,110],[54,63],[54,72],[54,81],[54,90],[54,99],[54,108],[54,117],[54,55],[54,56],[54,57],[54,58],[54,59],[54,60],[54,61],[54,47],[54,40],[54,33],[54,26],[54,19],[54,12],[54,5],[54,46],[54,38],[54,30],[54,22],[54,14],[54,6],[54,-2],[54,45],[54,36],[54,27],[54,18],[54,9],[54,0],[54,-9],[54,53],[54,52],[54,51],[54,50],[54,49],[54,48],[54,47],[54,61],[54,68],[54,75],[54,82],[54,89],[54,96],[54,103],[0,0],[0,0],[0,0],[54,39],[54,37],[54,44],[54,60],[0,0],[55,63],[55,71],[55,79],[55,87],[55,95],[55,103],[55,111],[55,64],[55,73],[55,82],[55,91],[55,100],[55,109],[55,118],[55,56],[55,57],[55,58],[55,59],[55,60],[55,61],[55,62],[55,48],[55,41],[55,34],[55,27],[55,20],[55,13],[55,6],[55,47],[55,39],[55,31],[55,23],[55,15],[55,7],[55,-1],[55,46],[55,37],[55,28],[55,19],[55,10],[55,1],[55,-8],[55,54],[55,53],[55,52],[55,51],[55,50],[55,49],[55,48],[55,62],[55,69],[55,76],[55,83],[55,90],[55,97],[55,104],[0,0],[0,0],[0,0],[0,0],[55,38],[55,45],[55,61],[0,0],[56,64],[56,72],[56,80],[56,88],[56,96],[56,104],[56,112],[56,65],[56,74],[56,83],[56,92],[56,101],[56,110],[56,119],[56,57],[56,58],[56,59],[56,60],[56,61],[56,62],[56,63],[56,49],[56,42],[56,35],[56,28],[56,21],[56,14],[56,7],[56,48],[56,40],[56,32],[56,24],[56,16],[56,8],[56,0],[56,47],[56,38],[56,29],[56,20],[56,11],[56,2],[56,-7],[56,55],[56,54],[56,53],[56,52],[56,51],[56,50],[56,49],[56,63],[56,70],[56,77],[56,84],[56,91],[56,98],[56,105],[0,0],[0,0],[56,50],[56,41],[0,0],[0,0],[0,0],[0,0],[57,65],[57,73],[57,81],[57,89],[57,97],[57,105],[57,113],[57,66],[57,75],[57,84],[57,93],[57,102],[57,111],[57,120],[57,58],[57,59],[57,60],[57,61],[57,62],[57,63],[57,64],[57,50],[57,43],[57,36],[57,29],[57,22],[57,15],[57,8],[57,49],[57,41],[57,33],[57,25],[57,17],[57,9],[57,1],[57,48],[57,39],[57,30],[57,21],[57,12],[57,3],[57,-6],[57,56],[57,55],[57,54],[57,53],[57,52],[57,51],[57,50],[57,64],[57,71],[57,78],[57,85],[57,92],[57,99],[57,106],[0,0],[0,0],[57,51],[57,42],[57,40],[0,0],[0,0],[0,0],[58,66],[58,74],[58,82],[58,90],[58,98],[58,106],[58,114],[58,67],[58,76],[58,85],[58,94],[58,103],[58,112],[58,121],[58,59],[58,60],[58,61],[58,62],[58,63],[58,64],[58,65],[58,51],[58,44],[58,37],[58,30],[58,23],[58,16],[58,9],[58,50],[58,42],[58,34],[58,26],[58,18],[58,10],[58,2],[58,49],[58,40],[58,31],[58,22],[58,13],[58,4],[58,-5],[58,57],[58,56],[58,55],[58,54],[58,53],[58,52],[58,51],[58,65],[58,72],[58,79],[58,86],[58,93],[58,100],[58,107],[0,0],[0,0],[58,52],[58,43],[58,41],[58,48],[0,0],[0,0],[59,67],[59,75],[59,83],[59,91],[59,99],[59,107],[59,115],[59,68],[59,77],[59,86],[59,95],[59,104],[59,113],[59,122],[59,60],[59,61],[59,62],[59,63],[59,64],[59,65],[59,66],[59,52],[59,45],[59,38],[59,31],[59,24],[59,17],[59,10],[59,51],[59,43],[59,35],[59,27],[59,19],[59,11],[59,3],[59,50],[59,41],[59,32],[59,23],[59,14],[59,5],[59,-4],[59,58],[59,57],[59,56],[59,55],[59,54],[59,53],[59,52],[59,66],[59,73],[59,80],[59,87],[59,94],[59,101],[59,108],[0,0],[0,0],[59,53],[59,44],[59,42],[59,49],[0,0],[0,0],[60,68],[60,76],[60,84],[60,92],[60,100],[60,108],[60,116],[60,69],[60,78],[60,87],[60,96],[60,105],[60,114],[60,123],[60,61],[60,62],[60,63],[60,64],[60,65],[60,66],[60,67],[60,53],[60,46],[60,39],[60,32],[60,25],[60,18],[60,11],[60,52],[60,44],[60,36],[60,28],[60,20],[60,12],[60,4],[60,51],[60,42],[60,33],[60,24],[60,15],[60,6],[60,-3],[60,59],[60,58],[60,57],[60,56],[60,55],[60,54],[60,53],[60,67],[60,74],[60,81],[60,88],[60,95],[60,102],[60,109],[0,0],[0,0],[60,54],[60,45],[60,43],[60,50],[0,0],[0,0],[61,69],[61,77],[61,85],[61,93],[61,101],[61,109],[61,117],[61,70],[61,79],[61,88],[61,97],[61,106],[61,115],[61,124],[61,62],[61,63],[61,64],[61,65],[61,66],[61,67],[61,68],[61,54],[61,47],[61,40],[61,33],[61,26],[61,19],[61,12],[61,53],[61,45],[61,37],[61,29],[61,21],[61,13],[61,5],[61,52],[61,43],[61,34],[61,25],[61,16],[61,7],[61,-2],[61,60],[61,59],[61,58],[61,57],[61,56],[61,55],[61,54],[61,68],[61,75],[61,82],[61,89],[61,96],[61,103],[61,110],[0,0],[0,0],[61,55],[61,46],[61,44],[61,51],[0,0],[0,0],[62,70],[62,78],[62,86],[62,94],[62,102],[62,110],[62,118],[62,71],[62,80],[62,89],[62,98],[62,107],[62,116],[62,125],[62,63],[62,64],[62,65],[62,66],[62,67],[62,68],[62,69],[62,55],[62,48],[62,41],[62,34],[62,27],[62,20],[62,13],[62,54],[62,46],[62,38],[62,30],[62,22],[62,14],[62,6],[62,53],[62,44],[62,35],[62,26],[62,17],[62,8],[62,-1],[62,61],[62,60],[62,59],[62,58],[62,57],[62,56],[62,55],[62,69],[62,76],[62,83],[62,90],[62,97],[62,104],[62,111],[0,0],[0,0],[0,0],[62,47],[62,45],[62,52],[0,0],[0,0],[63,71],[63,79],[63,87],[63,95],[63,103],[63,111],[63,119],[63,72],[63,81],[63,90],[63,99],[63,108],[63,117],[63,126],[63,64],[63,65],[63,66],[63,67],[63,68],[63,69],[63,70],[63,56],[63,49],[63,42],[63,35],[63,28],[63,21],[63,14],[63,55],[63,47],[63,39],[63,31],[63,23],[63,15],[63,7],[63,54],[63,45],[63,36],[63,27],[63,18],[63,9],[63,0],[63,62],[63,61],[63,60],[63,59],[63,58],[63,57],[63,56],[63,70],[63,77],[63,84],[63,91],[63,98],[63,105],[63,112],[0,0],[0,0],[0,0],[0,0],[63,46],[63,53],[0,0],[0,0]]),Mt(Pp,"srcSquareToDstSquareToMoveIndex",[[0,14,15,16,17,18,19,20,0,7,57,0,0,0,0,0,1,56,8,0,0,0,0,0,2,0,0,9,0,0,0,0,3,0,0,0,10,0,0,0,4,0,0,0,0,11,0,0,5,0,0,0,0,0,12,0,6,0,0,0,0,0,0,13],[106,0,78,79,80,81,82,83,113,64,71,121,0,0,0,0,127,65,120,72,0,0,0,0,0,66,0,0,73,0,0,0,0,67,0,0,0,74,0,0,0,68,0,0,0,0,75,0,0,69,0,0,0,0,0,76,0,70,0,0,0,0,0,0],[171,170,0,142,143,144,145,146,190,177,128,135,185,0,0,0,178,191,129,184,136,0,0,0,0,0,130,0,0,137,0,0,0,0,131,0,0,0,138,0,0,0,132,0,0,0,0,139,0,0,133,0,0,0,0,0,0,0,134,0,0,0,0,0],[236,235,234,0,206,207,208,209,0,254,241,192,199,249,0,0,0,242,255,193,248,200,0,0,243,0,0,194,0,0,201,0,0,0,0,195,0,0,0,202,0,0,0,196,0,0,0,0,0,0,0,197,0,0,0,0,0,0,0,198,0,0,0,0],[301,300,299,298,0,270,271,272,0,0,318,305,256,263,313,0,0,0,306,319,257,312,264,0,0,307,0,0,258,0,0,265,308,0,0,0,259,0,0,0,0,0,0,0,260,0,0,0,0,0,0,0,261,0,0,0,0,0,0,0,262,0,0,0],[366,365,364,363,362,0,334,335,0,0,0,382,369,320,327,377,0,0,0,370,383,321,376,328,0,0,371,0,0,322,0,0,0,372,0,0,0,323,0,0,373,0,0,0,0,324,0,0,0,0,0,0,0,325,0,0,0,0,0,0,0,326,0,0],[431,430,429,428,427,426,0,398,0,0,0,0,446,433,384,391,0,0,0,0,434,447,385,440,0,0,0,435,0,0,386,0,0,0,436,0,0,0,387,0,0,437,0,0,0,0,388,0,438,0,0,0,0,0,389,0,0,0,0,0,0,0,390,0],[496,495,494,493,492,491,490,0,0,0,0,0,0,510,497,448,0,0,0,0,0,498,511,449,0,0,0,0,499,0,0,450,0,0,0,500,0,0,0,451,0,0,501,0,0,0,0,452,0,502,0,0,0,0,0,453,503,0,0,0,0,0,0,454],[540,533,570,0,0,0,0,0,0,526,527,528,529,530,531,532,512,519,569,0,0,0,0,0,513,568,520,0,0,0,0,0,514,0,0,521,0,0,0,0,515,0,0,0,522,0,0,0,516,0,0,0,0,523,0,0,517,0,0,0,0,0,524,0],[611,604,597,634,0,0,0,0,618,0,590,591,592,593,594,595,625,576,583,633,0,0,0,0,639,577,632,584,0,0,0,0,0,578,0,0,585,0,0,0,0,579,0,0,0,586,0,0,0,580,0,0,0,0,587,0,0,581,0,0,0,0,0,588],[701,675,668,661,698,0,0,0,683,682,0,654,655,656,657,658,702,689,640,647,697,0,0,0,690,703,641,696,648,0,0,0,0,0,642,0,0,649,0,0,0,0,643,0,0,0,650,0,0,0,644,0,0,0,0,651,0,0,645,0,0,0,0,0],[0,765,739,732,725,762,0,0,748,747,746,0,718,719,720,721,0,766,753,704,711,761,0,0,0,754,767,705,760,712,0,0,755,0,0,706,0,0,713,0,0,0,0,707,0,0,0,714,0,0,0,708,0,0,0,0,0,0,0,709,0,0,0,0],[0,0,829,803,796,789,826,0,813,812,811,810,0,782,783,784,0,0,830,817,768,775,825,0,0,0,818,831,769,824,776,0,0,819,0,0,770,0,0,777,820,0,0,0,771,0,0,0,0,0,0,0,772,0,0,0,0,0,0,0,773,0,0,0],[0,0,0,893,867,860,853,890,878,877,876,875,874,0,846,847,0,0,0,894,881,832,839,889,0,0,0,882,895,833,888,840,0,0,883,0,0,834,0,0,0,884,0,0,0,835,0,0,885,0,0,0,0,836,0,0,0,0,0,0,0,837,0,0],[0,0,0,0,957,931,924,917,943,942,941,940,939,938,0,910,0,0,0,0,958,945,896,903,0,0,0,0,946,959,897,952,0,0,0,947,0,0,898,0,0,0,948,0,0,0,899,0,0,949,0,0,0,0,900,0,950,0,0,0,0,0,901,0],[0,0,0,0,0,1021,995,988,1008,1007,1006,1005,1004,1003,1002,0,0,0,0,0,0,1022,1009,960,0,0,0,0,0,1010,1023,961,0,0,0,0,1011,0,0,962,0,0,0,1012,0,0,0,963,0,0,1013,0,0,0,0,964,0,1014,0,0,0,0,0,965],[1053,1083,1046,0,0,0,0,0,1052,1045,1082,0,0,0,0,0,0,1038,1039,1040,1041,1042,1043,1044,1024,1031,1081,0,0,0,0,0,1025,1080,1032,0,0,0,0,0,1026,0,0,1033,0,0,0,0,1027,0,0,0,1034,0,0,0,1028,0,0,0,0,1035,0,0],[1148,1117,1147,1110,0,0,0,0,1123,1116,1109,1146,0,0,0,0,1130,0,1102,1103,1104,1105,1106,1107,1137,1088,1095,1145,0,0,0,0,1151,1089,1144,1096,0,0,0,0,0,1090,0,0,1097,0,0,0,0,1091,0,0,0,1098,0,0,0,1092,0,0,0,0,1099,0],[1188,1212,1181,1211,1174,0,0,0,1213,1187,1180,1173,1210,0,0,0,1195,1194,0,1166,1167,1168,1169,1170,1214,1201,1152,1159,1209,0,0,0,1202,1215,1153,1208,1160,0,0,0,0,0,1154,0,0,1161,0,0,0,0,1155,0,0,0,1162,0,0,0,1156,0,0,0,0,1163],[0,1252,1276,1245,1275,1238,0,0,0,1277,1251,1244,1237,1274,0,0,1260,1259,1258,0,1230,1231,1232,1233,0,1278,1265,1216,1223,1273,0,0,0,1266,1279,1217,1272,1224,0,0,1267,0,0,1218,0,0,1225,0,0,0,0,1219,0,0,0,1226,0,0,0,1220,0,0,0,0],[0,0,1316,1340,1309,1339,1302,0,0,0,1341,1315,1308,1301,1338,0,1325,1324,1323,1322,0,1294,1295,1296,0,0,1342,1329,1280,1287,1337,0,0,0,1330,1343,1281,1336,1288,0,0,1331,0,0,1282,0,0,1289,1332,0,0,0,1283,0,0,0,0,0,0,0,1284,0,0,0],[0,0,0,1380,1404,1373,1403,1366,0,0,0,1405,1379,1372,1365,1402,1390,1389,1388,1387,1386,0,1358,1359,0,0,0,1406,1393,1344,1351,1401,0,0,0,1394,1407,1345,1400,1352,0,0,1395,0,0,1346,0,0,0,1396,0,0,0,1347,0,0,1397,0,0,0,0,1348,0,0],[0,0,0,0,1444,1468,1437,1467,0,0,0,0,1469,1443,1436,1429,1455,1454,1453,1452,1451,1450,0,1422,0,0,0,0,1470,1457,1408,1415,0,0,0,0,1458,1471,1409,1464,0,0,0,1459,0,0,1410,0,0,0,1460,0,0,0,1411,0,0,1461,0,0,0,0,1412,0],[0,0,0,0,0,1508,1532,1501,0,0,0,0,0,1533,1507,1500,1520,1519,1518,1517,1516,1515,1514,0,0,0,0,0,0,1534,1521,1472,0,0,0,0,0,1522,1535,1473,0,0,0,0,1523,0,0,1474,0,0,0,1524,0,0,0,1475,0,0,1525,0,0,0,0,1476],[1566,0,0,1559,0,0,0,0,1565,1595,1558,0,0,0,0,0,1564,1557,1594,0,0,0,0,0,0,1550,1551,1552,1553,1554,1555,1556,1536,1543,1593,0,0,0,0,0,1537,1592,1544,0,0,0,0,0,1538,0,0,1545,0,0,0,0,1539,0,0,0,1546,0,0,0],[0,1630,0,0,1623,0,0,0,1660,1629,1659,1622,0,0,0,0,1635,1628,1621,1658,0,0,0,0,1642,0,1614,1615,1616,1617,1618,1619,1649,1600,1607,1657,0,0,0,0,1663,1601,1656,1608,0,0,0,0,0,1602,0,0,1609,0,0,0,0,1603,0,0,0,1610,0,0],[0,0,1694,0,0,1687,0,0,1700,1724,1693,1723,1686,0,0,0,1725,1699,1692,1685,1722,0,0,0,1707,1706,0,1678,1679,1680,1681,1682,1726,1713,1664,1671,1721,0,0,0,1714,1727,1665,1720,1672,0,0,0,0,0,1666,0,0,1673,0,0,0,0,1667,0,0,0,1674,0],[1765,0,0,1758,0,0,1751,0,0,1764,1788,1757,1787,1750,0,0,0,1789,1763,1756,1749,1786,0,0,1772,1771,1770,0,1742,1743,1744,1745,0,1790,1777,1728,1735,1785,0,0,0,1778,1791,1729,1784,1736,0,0,1779,0,0,1730,0,0,1737,0,0,0,0,1731,0,0,0,1738],[0,1829,0,0,1822,0,0,1815,0,0,1828,1852,1821,1851,1814,0,0,0,1853,1827,1820,1813,1850,0,1837,1836,1835,1834,0,1806,1807,1808,0,0,1854,1841,1792,1799,1849,0,0,0,1842,1855,1793,1848,1800,0,0,1843,0,0,1794,0,0,1801,1844,0,0,0,1795,0,0,0],[0,0,1893,0,0,1886,0,0,0,0,0,1892,1916,1885,1915,1878,0,0,0,1917,1891,1884,1877,1914,1902,1901,1900,1899,1898,0,1870,1871,0,0,0,1918,1905,1856,1863,1913,0,0,0,1906,1919,1857,1912,1864,0,0,1907,0,0,1858,0,0,0,1908,0,0,0,1859,0,0],[0,0,0,1957,0,0,1950,0,0,0,0,0,1956,1980,1949,1979,0,0,0,0,1981,1955,1948,1941,1967,1966,1965,1964,1963,1962,0,1934,0,0,0,0,1982,1969,1920,1927,0,0,0,0,1970,1983,1921,1976,0,0,0,1971,0,0,1922,0,0,0,1972,0,0,0,1923,0],[0,0,0,0,2021,0,0,2014,0,0,0,0,0,2020,2044,2013,0,0,0,0,0,2045,2019,2012,2032,2031,2030,2029,2028,2027,2026,0,0,0,0,0,0,2046,2033,1984,0,0,0,0,0,2034,2047,1985,0,0,0,0,2035,0,0,1986,0,0,0,2036,0,0,0,1987],[2079,0,0,0,2072,0,0,0,2078,0,0,2071,0,0,0,0,2077,2107,2070,0,0,0,0,0,2076,2069,2106,0,0,0,0,0,0,2062,2063,2064,2065,2066,2067,2068,2048,2055,2105,0,0,0,0,0,2049,2104,2056,0,0,0,0,0,2050,0,0,2057,0,0,0,0],[0,2143,0,0,0,2136,0,0,0,2142,0,0,2135,0,0,0,2172,2141,2171,2134,0,0,0,0,2147,2140,2133,2170,0,0,0,0,2154,0,2126,2127,2128,2129,2130,2131,2161,2112,2119,2169,0,0,0,0,2175,2113,2168,2120,0,0,0,0,0,2114,0,0,2121,0,0,0],[0,0,2207,0,0,0,2200,0,0,0,2206,0,0,2199,0,0,2212,2236,2205,2235,2198,0,0,0,2237,2211,2204,2197,2234,0,0,0,2219,2218,0,2190,2191,2192,2193,2194,2238,2225,2176,2183,2233,0,0,0,2226,2239,2177,2232,2184,0,0,0,0,0,2178,0,0,2185,0,0],[0,0,0,2271,0,0,0,2264,2277,0,0,2270,0,0,2263,0,0,2276,2300,2269,2299,2262,0,0,0,2301,2275,2268,2261,2298,0,0,2284,2283,2282,0,2254,2255,2256,2257,0,2302,2289,2240,2247,2297,0,0,0,2290,2303,2241,2296,2248,0,0,2291,0,0,2242,0,0,2249,0],[2342,0,0,0,2335,0,0,0,0,2341,0,0,2334,0,0,2327,0,0,2340,2364,2333,2363,2326,0,0,0,2365,2339,2332,2325,2362,0,2349,2348,2347,2346,0,2318,2319,2320,0,0,2366,2353,2304,2311,2361,0,0,0,2354,2367,2305,2360,2312,0,0,2355,0,0,2306,0,0,2313],[0,2406,0,0,0,2399,0,0,0,0,2405,0,0,2398,0,0,0,0,0,2404,2428,2397,2427,2390,0,0,0,2429,2403,2396,2389,2426,2414,2413,2412,2411,2410,0,2382,2383,0,0,0,2430,2417,2368,2375,2425,0,0,0,2418,2431,2369,2424,2376,0,0,2419,0,0,2370,0,0],[0,0,2470,0,0,0,2463,0,0,0,0,2469,0,0,2462,0,0,0,0,0,2468,2492,2461,2491,0,0,0,0,2493,2467,2460,2453,2479,2478,2477,2476,2475,2474,0,2446,0,0,0,0,2494,2481,2432,2439,0,0,0,0,2482,2495,2433,2488,0,0,0,2483,0,0,2434,0],[0,0,0,2534,0,0,0,2527,0,0,0,0,2533,0,0,2526,0,0,0,0,0,2532,2556,2525,0,0,0,0,0,2557,2531,2524,2544,2543,2542,2541,2540,2539,2538,0,0,0,0,0,0,2558,2545,2496,0,0,0,0,0,2546,2559,2497,0,0,0,0,2547,0,0,2498],[2592,0,0,0,0,2585,0,0,2591,0,0,0,2584,0,0,0,2590,0,0,2583,0,0,0,0,2589,2619,2582,0,0,0,0,0,2588,2581,2618,0,0,0,0,0,0,2574,2575,2576,2577,2578,2579,2580,2560,2567,2617,0,0,0,0,0,2561,2616,2568,0,0,0,0,0],[0,2656,0,0,0,0,2649,0,0,2655,0,0,0,2648,0,0,0,2654,0,0,2647,0,0,0,2684,2653,2683,2646,0,0,0,0,2659,2652,2645,2682,0,0,0,0,2666,0,2638,2639,2640,2641,2642,2643,2673,2624,2631,2681,0,0,0,0,2687,2625,2680,2632,0,0,0,0],[0,0,2720,0,0,0,0,2713,0,0,2719,0,0,0,2712,0,0,0,2718,0,0,2711,0,0,2724,2748,2717,2747,2710,0,0,0,2749,2723,2716,2709,2746,0,0,0,2731,2730,0,2702,2703,2704,2705,2706,2750,2737,2688,2695,2745,0,0,0,2738,2751,2689,2744,2696,0,0,0],[0,0,0,2784,0,0,0,0,0,0,0,2783,0,0,0,2776,2789,0,0,2782,0,0,2775,0,0,2788,2812,2781,2811,2774,0,0,0,2813,2787,2780,2773,2810,0,0,2796,2795,2794,0,2766,2767,2768,2769,0,2814,2801,2752,2759,2809,0,0,0,2802,2815,2753,2808,2760,0,0],[0,0,0,0,2848,0,0,0,2854,0,0,0,2847,0,0,0,0,2853,0,0,2846,0,0,2839,0,0,2852,2876,2845,2875,2838,0,0,0,2877,2851,2844,2837,2874,0,2861,2860,2859,2858,0,2830,2831,2832,0,0,2878,2865,2816,2823,2873,0,0,0,2866,2879,2817,2872,2824,0],[2919,0,0,0,0,2912,0,0,0,2918,0,0,0,2911,0,0,0,0,2917,0,0,2910,0,0,0,0,0,2916,2940,2909,2939,2902,0,0,0,2941,2915,2908,2901,2938,2926,2925,2924,2923,2922,0,2894,2895,0,0,0,2942,2929,2880,2887,2937,0,0,0,2930,2943,2881,2936,2888],[0,2983,0,0,0,0,2976,0,0,0,2982,0,0,0,2975,0,0,0,0,2981,0,0,2974,0,0,0,0,0,2980,3004,2973,3003,0,0,0,0,3005,2979,2972,2965,2991,2990,2989,2988,2987,2986,0,2958,0,0,0,0,3006,2993,2944,2951,0,0,0,0,2994,3007,2945,3e3],[0,0,3047,0,0,0,0,3040,0,0,0,3046,0,0,0,3039,0,0,0,0,3045,0,0,3038,0,0,0,0,0,3044,3068,3037,0,0,0,0,0,3069,3043,3036,3056,3055,3054,3053,3052,3051,3050,0,0,0,0,0,0,3070,3057,3008,0,0,0,0,0,3058,3071,3009],[3105,0,0,0,0,0,3098,0,3104,0,0,0,0,3097,0,0,3103,0,0,0,3096,0,0,0,3102,0,0,3095,0,0,0,0,3101,3131,3094,0,0,0,0,0,3100,3093,3130,0,0,0,0,0,0,3086,3087,3088,3089,3090,3091,3092,3072,3079,3129,0,0,0,0,0],[0,3169,0,0,0,0,0,3162,0,3168,0,0,0,0,3161,0,0,3167,0,0,0,3160,0,0,0,3166,0,0,3159,0,0,0,3196,3165,3195,3158,0,0,0,0,3171,3164,3157,3194,0,0,0,0,3178,0,3150,3151,3152,3153,3154,3155,3185,3136,3143,3193,0,0,0,0],[0,0,3233,0,0,0,0,0,0,0,3232,0,0,0,0,3225,0,0,3231,0,0,0,3224,0,0,0,3230,0,0,3223,0,0,3236,3260,3229,3259,3222,0,0,0,3261,3235,3228,3221,3258,0,0,0,3243,3242,0,3214,3215,3216,3217,3218,3262,3249,3200,3207,3257,0,0,0],[0,0,0,3297,0,0,0,0,0,0,0,3296,0,0,0,0,0,0,0,3295,0,0,0,3288,3301,0,0,3294,0,0,3287,0,0,3300,3324,3293,3323,3286,0,0,0,3325,3299,3292,3285,3322,0,0,3308,3307,3306,0,3278,3279,3280,3281,0,3326,3313,3264,3271,3321,0,0],[0,0,0,0,3361,0,0,0,0,0,0,0,3360,0,0,0,3366,0,0,0,3359,0,0,0,0,3365,0,0,3358,0,0,3351,0,0,3364,3388,3357,3387,3350,0,0,0,3389,3363,3356,3349,3386,0,3373,3372,3371,3370,0,3342,3343,3344,0,0,3390,3377,3328,3335,3385,0],[0,0,0,0,0,3425,0,0,3431,0,0,0,0,3424,0,0,0,3430,0,0,0,3423,0,0,0,0,3429,0,0,3422,0,0,0,0,0,3428,3452,3421,3451,3414,0,0,0,3453,3427,3420,3413,3450,3438,3437,3436,3435,3434,0,3406,3407,0,0,0,3454,3441,3392,3399,3449],[3496,0,0,0,0,0,3489,0,0,3495,0,0,0,0,3488,0,0,0,3494,0,0,0,3487,0,0,0,0,3493,0,0,3486,0,0,0,0,0,3492,3516,3485,3515,0,0,0,0,3517,3491,3484,3477,3503,3502,3501,3500,3499,3498,0,3470,0,0,0,0,3518,3505,3456,3463],[0,3560,0,0,0,0,0,3553,0,0,3559,0,0,0,0,3552,0,0,0,3558,0,0,0,3551,0,0,0,0,3557,0,0,3550,0,0,0,0,0,3556,3580,3549,0,0,0,0,0,3581,3555,3548,3568,3567,3566,3565,3564,3563,3562,0,0,0,0,0,0,3582,3569,3520],[3618,0,0,0,0,0,0,3611,3617,0,0,0,0,0,3610,0,3616,0,0,0,0,3609,0,0,3615,0,0,0,3608,0,0,0,3614,0,0,3607,0,0,0,0,3613,3643,3606,0,0,0,0,0,3612,3605,3642,0,0,0,0,0,0,3598,3599,3600,3601,3602,3603,3604],[0,3682,0,0,0,0,0,0,0,3681,0,0,0,0,0,3674,0,3680,0,0,0,0,3673,0,0,3679,0,0,0,3672,0,0,0,3678,0,0,3671,0,0,0,3708,3677,3707,3670,0,0,0,0,3683,3676,3669,3706,0,0,0,0,3690,0,3662,3663,3664,3665,3666,3667],[0,0,3746,0,0,0,0,0,0,0,3745,0,0,0,0,0,0,0,3744,0,0,0,0,3737,0,0,3743,0,0,0,3736,0,0,0,3742,0,0,3735,0,0,3748,3772,3741,3771,3734,0,0,0,3773,3747,3740,3733,3770,0,0,0,3755,3754,0,3726,3727,3728,3729,3730],[0,0,0,3810,0,0,0,0,0,0,0,3809,0,0,0,0,0,0,0,3808,0,0,0,0,0,0,0,3807,0,0,0,3800,3813,0,0,3806,0,0,3799,0,0,3812,3836,3805,3835,3798,0,0,0,3837,3811,3804,3797,3834,0,0,3820,3819,3818,0,3790,3791,3792,3793],[0,0,0,0,3874,0,0,0,0,0,0,0,3873,0,0,0,0,0,0,0,3872,0,0,0,3878,0,0,0,3871,0,0,0,0,3877,0,0,3870,0,0,3863,0,0,3876,3900,3869,3899,3862,0,0,0,3901,3875,3868,3861,3898,0,3885,3884,3883,3882,0,3854,3855,3856],[0,0,0,0,0,3938,0,0,0,0,0,0,0,3937,0,0,3943,0,0,0,0,3936,0,0,0,3942,0,0,0,3935,0,0,0,0,3941,0,0,3934,0,0,0,0,0,3940,3964,3933,3963,3926,0,0,0,3965,3939,3932,3925,3962,3950,3949,3948,3947,3946,0,3918,3919],[0,0,0,0,0,0,4002,0,4008,0,0,0,0,0,4001,0,0,4007,0,0,0,0,4e3,0,0,0,4006,0,0,0,3999,0,0,0,0,4005,0,0,3998,0,0,0,0,0,4004,4028,3997,4027,0,0,0,0,4029,4003,3996,3989,4015,4014,4013,4012,4011,4010,0,3982],[4073,0,0,0,0,0,0,4066,0,4072,0,0,0,0,0,4065,0,0,4071,0,0,0,0,4064,0,0,0,4070,0,0,0,4063,0,0,0,0,4069,0,0,4062,0,0,0,0,0,4068,4092,4061,0,0,0,0,0,4093,4067,4060,4080,4079,4078,4077,4076,4075,4074,0]]);class l1{constructor(e){Mt(this,"game");Mt(this,"actionsSinceProgress");e.encodedBoard!==void 0?(this.actionsSinceProgress=0,this.game=new kc({encodedBoard:e.encodedBoard})):e.other!==void 0?(this.actionsSinceProgress=e.other.actionsSinceProgress,this.game=new kc({other:e.other.game})):(this.actionsSinceProgress=0,this.game=new kc({}))}computeValids(){let e=new Array(Ho).fill(0),t=!1,s=this.game.playerToPieces[this.game.currentPlayer];for(let r=0;r<s.length;r++){let i=s[r];if(i.healthPoints<=0)continue;let o=this.game.legalActionsByPiece(i);for(let l=0;l<o.length;l++){let u=o[l],d=Pp.srcSquareToDstSquareToMoveIndex[u.srcIdx][u.dstIdx];e[d]=1,t=!0}}return t||(e[S_]=1),e}createNichessAction(e){let t,s;if(e==S_)return new Le(Va,Va,le.SKIP);{let h=Pp.moveIndexToSrcAndDstSquare[e];t=h[0],s=h[1]}let r=this.game.board[t],i=this.game.board[s],o,l,u,d;switch(r.type){case M.P1_KING:St(i.type,Re.PLAYER_2)?o=le.ABILITY_KING_DAMAGE:t==4&&s==6||t==4&&s==2?o=le.MOVE_CASTLE:o=le.MOVE_REGULAR;break;case M.P1_MAGE:i.type==M.NO_PIECE?o=le.MOVE_REGULAR:(l=nt.srcSquareToDstSquareToDirection[t][s],u=nt.squareToDirectionToLine[t][l],d=this.game.board[u[0]],d.type==M.P1_ASSASSIN?o=le.ABILITY_MAGE_THROW_ASSASSIN:o=le.ABILITY_MAGE_DAMAGE);break;case M.P1_PAWN:i.type==M.NO_PIECE?s>55?o=le.MOVE_PROMOTE_P1_PAWN:o=le.MOVE_REGULAR:s>55&&i.healthPoints<=Ca?o=le.ABILITY_P1_PAWN_DAMAGE_AND_PROMOTION:o=le.ABILITY_PAWN_DAMAGE;break;case M.P1_WARRIOR:i.type==M.NO_PIECE?o=le.MOVE_REGULAR:(l=nt.srcSquareToDstSquareToDirection[t][s],u=nt.squareToDirectionToLine[t][l],d=this.game.board[u[0]],d.type==M.P1_WARRIOR?o=le.ABILITY_WARRIOR_THROW_WARRIOR:o=le.ABILITY_WARRIOR_DAMAGE);break;case M.P1_ASSASSIN:i.type==M.NO_PIECE?o=le.MOVE_REGULAR:o=le.ABILITY_ASSASSIN_DAMAGE;break;case M.P1_KNIGHT:i.type==M.NO_PIECE?o=le.MOVE_REGULAR:o=le.ABILITY_KNIGHT_DAMAGE;break;case M.P2_KING:St(i.type,Re.PLAYER_1)?o=le.ABILITY_KING_DAMAGE:t==60&&s==62||t==60&&s==58?o=le.MOVE_CASTLE:o=le.MOVE_REGULAR;break;case M.P2_MAGE:i.type==M.NO_PIECE?o=le.MOVE_REGULAR:(l=nt.srcSquareToDstSquareToDirection[t][s],u=nt.squareToDirectionToLine[t][l],d=this.game.board[u[0]],d.type==M.P2_ASSASSIN?o=le.ABILITY_MAGE_THROW_ASSASSIN:o=le.ABILITY_MAGE_DAMAGE);break;case M.P2_PAWN:i.type==M.NO_PIECE?s<8?o=le.MOVE_PROMOTE_P2_PAWN:o=le.MOVE_REGULAR:s<8&&i.healthPoints<=Ca?o=le.ABILITY_P2_PAWN_DAMAGE_AND_PROMOTION:o=le.ABILITY_PAWN_DAMAGE;break;case M.P2_WARRIOR:i.type==M.NO_PIECE?o=le.MOVE_REGULAR:(l=nt.srcSquareToDstSquareToDirection[t][s],u=nt.squareToDirectionToLine[t][l],d=this.game.board[u[0]],d.type==M.P2_WARRIOR?o=le.ABILITY_WARRIOR_THROW_WARRIOR:o=le.ABILITY_WARRIOR_DAMAGE);break;case M.P2_ASSASSIN:i.type==M.NO_PIECE?o=le.MOVE_REGULAR:o=le.ABILITY_ASSASSIN_DAMAGE;break;case M.P2_KNIGHT:i.type==M.NO_PIECE?o=le.MOVE_REGULAR:o=le.ABILITY_KNIGHT_DAMAGE;break}return new Le(t,s,o)}makeAction(e){let t=this.createNichessAction(e);if(t.actionType==le.SKIP)this.actionsSinceProgress+=1;else{let s=this.game.board[t.srcIdx];s.type==M.P1_PAWN||s.type==M.P2_PAWN?this.actionsSinceProgress=0:t.actionType==le.MOVE_REGULAR||t.actionType==le.MOVE_CASTLE?this.actionsSinceProgress+=1:this.actionsSinceProgress=0}this.game.makeAction(t)}moveToPlayerAction(e){let t=this.createNichessAction(e),s="";return s+=t.srcIdx.toString()+".",s+=t.dstIdx.toString(),s}}class my{constructor(e){Mt(this,"gameWrapper");e.other!==void 0?this.gameWrapper=new l1({other:e.other.gameWrapper}):e.encodedBoard!==void 0?this.gameWrapper=new l1({encodedBoard:e.encodedBoard}):this.gameWrapper=new l1({})}copy(){return new my({other:this})}current_player(){return this.gameWrapper.game.currentPlayer}current_turn(){return this.gameWrapper.game.moveNumber}num_moves(){return Ho}num_players(){return Wz}valid_moves(){return this.gameWrapper.computeValids()}play_move(e){this.gameWrapper.makeAction(e)}scores(){let e=this.gameWrapper.game.winner();if(e!==void 0){if(e===Re.PLAYER_1)return[1,0,0];if(e===Re.PLAYER_2)return[0,1,0]}}canonicalized(){let e=new Array,t=24+this.gameWrapper.game.currentPlayer;for(let s=0;s<26;s++){e[s]=new Array;for(let r=0;r<zi;r++){e[s][r]=new Array(Sr);for(let i=0;i<Sr;i++)e[s][r][i]=0}}for(let s=0;s<zi;s++)for(let r=0;r<Sr;r++){e[t][s][r]=1;let i=ge(r,s),o=this.gameWrapper.game.board[i];if(o.type==M.NO_PIECE)continue;let l=Bz(o.type);e[l][s][r]=1;let u=Hz(o.type);e[l+12][s][r]=o.healthPoints/u}return e}dump(){return this.gameWrapper.game.dump()}}function Bz(n){switch(n){case M.P1_KING:return 0;case M.P1_MAGE:return 1;case M.P1_PAWN:return 2;case M.P1_WARRIOR:return 3;case M.P1_ASSASSIN:return 4;case M.P1_KNIGHT:return 5;case M.P2_KING:return 6;case M.P2_MAGE:return 7;case M.P2_PAWN:return 8;case M.P2_WARRIOR:return 9;case M.P2_ASSASSIN:return 10;case M.P2_KNIGHT:return 11;default:return 1e3}}function Hz(n){switch(n){case M.P1_KING:return Op;case M.P1_MAGE:return Rp;case M.P1_PAWN:return ps;case M.P1_WARRIOR:return Ei;case M.P1_ASSASSIN:return Xl;case M.P1_KNIGHT:return Zl;case M.P2_KING:return Op;case M.P2_MAGE:return Rp;case M.P2_PAWN:return ps;case M.P2_WARRIOR:return Ei;case M.P2_ASSASSIN:return Xl;case M.P2_KNIGHT:return Zl;default:return 0}}function Uz(n){var e,t,s;for(s=n.length-1;s>0;s--)e=Math.floor(Math.random()*(s+1)),t=n[s],n[s]=n[e],n[e]=t;return n}let Gz=class JE{constructor(e){Mt(this,"q",0);Mt(this,"d",0);Mt(this,"v",0);Mt(this,"virtual_loss",0);Mt(this,"policy",0);Mt(this,"move",0);Mt(this,"n",0);Mt(this,"player",0);Mt(this,"scores");Mt(this,"children");this.move=e}add_children(e){this.children=new Array(e.reduce((s,r)=>s+r));let t=0;for(let s=0;s<e.length;s++)e[s]==1&&(this.children[t]=new JE(s),t++);Uz(this.children)}update_policy(e){let t;for(let s=0;s<this.children.length;s++)t=this.children[s],t.policy=e[t.move]}uct(e,t,s){return this.n==0?s+t*this.policy*e/(this.n+1+this.virtual_loss):this.q+t*this.policy*e/(this.n+1+this.virtual_loss)}best_child(e,t){let s=0,r;for(let d=0;d<this.children.length;d++)r=this.children[d],r.n>0&&(s+=r.policy);let i=this.v-t*Math.sqrt(s),o=Math.sqrt(this.n),l=0,u=this.children[0].uct(o,e,i);for(let d=1;d<this.children.length;d++){let h=this.children[d].uct(o,e,i);h>u&&(u=h,l=d)}return this.children[l]}};class qz{constructor(e,t,s){Mt(this,"path");Mt(this,"current");Mt(this,"gs");Mt(this,"v",0);Mt(this,"pi",0);this.path=e,this.current=t,this.gs=s}}class Kz{constructor(e,t,s,r,i,o){Mt(this,"cpuct_");Mt(this,"num_players_");Mt(this,"num_moves_");Mt(this,"depth_");Mt(this,"root_");Mt(this,"current_");Mt(this,"path_");Mt(this,"epsilon");Mt(this,"root_policy_temp_");Mt(this,"fpu_reduction_");this.cpuct_=e,this.num_players_=t,this.num_moves_=s,this.epsilon=r,this.root_policy_temp_=i,this.fpu_reduction_=o,this.root_=new Gz(-1),this.current_=this.root_,this.path_=new Array}update_root(e,t){this.depth_=0,this.root_.children.length==0&&this.root_.add_children(e.valid_moves());let s,r;for(let i=0;i<this.root_.children.length;i++)if(r=this.root_.children[i],t==r.move){s=r;break}this.root_=s}process_result(e,t,s,r,i,o){if(i.scores!=null)t=i.scores;else{let l=new Float32Array(e.num_moves()).fill(0),u;for(let h=0;h<i.children.length;h++)u=i.children[h],l[u.move]=1;let d=0;for(let h=0;h<s.length;h++)s[h]*=l[h],d+=s[h];for(let h=0;h<s.length;h++)s[h]/=d;if(i==this.root_){let h=0;for(let m=0;m<s.length;m++)s[m]=s[m]**(1/this.root_policy_temp_),h+=s[m];for(let m=0;m<s.length;m++)s[m]/=h;i.update_policy(s);let f=t[i.player]+t[this.num_players_]/this.num_players_;i.v=f,r&&this.add_root_noise()}else i.update_policy(s)}for(;o.length!==0;){let l=o.pop(),u=t[l.player];if(u+=t[this.num_players_]/this.num_players_,i.q=(i.q*i.n+u)/(i.n+1),i.d=(i.d*i.n+t[this.num_players_])/(i.n+1),i.n==0){let d=t[i.player]+t[this.num_players_]/this.num_players_;i.v=d}i.n+=1,i.virtual_loss=0,i=l}this.depth_+=1,this.root_.n+=1,this.root_.virtual_loss=0}add_root_noise(){}find_leaf(e){this.current_=this.root_;let t=e.copy();for(;this.current_.n>0&&this.current_.scores==null;)this.current_.virtual_loss+=v_,this.path_.push(this.current_),this.current_=this.current_.best_child(this.cpuct_,this.fpu_reduction_),t.play_move(this.current_.move);if(this.current_.n==0){if(this.current_.virtual_loss!=0)return null;this.current_.player=t.current_player(),this.current_.scores=t.scores(),this.current_.add_children(t.valid_moves())}return this.current_.virtual_loss+=v_,t}root_value(){let e=0,t=0,s;for(let l=0;l<this.root_.children.length;l++)s=this.root_.children[l],s.n>0&&s.q>e&&(e=s.q,t=s.d);let r=e-t/this.num_players_,i=1-r-t;return[r,i,t]}counts(){let e=new Array(this.num_moves_).fill(0),t;for(let s=0;s<this.root_.children.length;s++)t=this.root_.children[s],e[t.move]=t.n;return e}probs(e){let t=this.counts(),s=new Array(this.num_moves_).fill(0);if(e==0){let o=new Array,l=t[0];for(let d=0;d<this.num_moves_;d++)t[d]>l?(l=t[d],o=[],o.push(d)):t[d]==l&&o.push(d);console.log(`best_count: ${l}`),console.log(`best_move: ${o[0]}`);let u;for(let d=0;d<o.length;d++)u=o[d],s[u]=1/o.length;return s}let r=0;for(let o=0;o<t.length;o++)r+=t[o];let i=0;for(let o=0;o<t.length;o++)s[o]=(t[o]/r)**(1/e),i+=s[o];for(let o=0;o<t.length;o++)s[o]/=i;return s}depth(){return this.depth_}pick_move(e){let t=Math.random(),s=0;for(let r=0;r<e.length;r++)if(s+=e[r],s>t)return r;for(let r=e.length-1;r>=0;r--)if(e[r]>0)return r;throw new Error("This shouldn't be possible.")}}const jz="modulepreload",Yz=function(n,e){return new URL(n,e).href},$_={},Xz=function(e,t,s){if(!t||t.length===0)return e();const r=document.getElementsByTagName("link");return Promise.all(t.map(i=>{if(i=Yz(i,s),i in $_)return;$_[i]=!0;const o=i.endsWith(".css"),l=o?'[rel="stylesheet"]':"";if(!!s)for(let h=r.length-1;h>=0;h--){const f=r[h];if(f.href===i&&(!o||f.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${i}"]${l}`))return;const d=document.createElement("link");if(d.rel=o?"stylesheet":jz,o||(d.as="script",d.crossOrigin=""),d.href=i,document.head.appendChild(d),o)return new Promise((h,f)=>{d.addEventListener("load",h),d.addEventListener("error",()=>f(new Error(`Unable to preload CSS for ${i}`)))})})).then(()=>e()).catch(i=>{const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=i,window.dispatchEvent(o),!o.defaultPrevented)throw i})};var yl=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Zz(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Qz(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}function Ml(n){throw new Error('Could not dynamically require "'+n+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var Jz={exports:{}};(function(n,e){var t=(()=>{var s=Object.defineProperty,r=Object.getOwnPropertyDescriptor,i=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,l=(c=>typeof Ml<"u"?Ml:typeof Proxy<"u"?new Proxy(c,{get:(p,g)=>(typeof Ml<"u"?Ml:p)[g]}):c)(function(c){if(typeof Ml<"u")return Ml.apply(this,arguments);throw Error('Dynamic require of "'+c+'" is not supported')}),u=(c,p)=>()=>(c&&(p=c(c=0)),p),d=(c,p)=>{for(var g in p)s(c,g,{get:p[g],enumerable:!0})},h=(c,p,g,b)=>{if(p&&typeof p=="object"||typeof p=="function")for(let x of i(p))!o.call(c,x)&&x!==g&&s(c,x,{get:()=>p[x],enumerable:!(b=r(p,x))||b.enumerable});return c},f=c=>h(s({},"__esModule",{value:!0}),c),m,I,y,N,w,T=u(()=>{m=new Map,I=[],y=(c,p,g)=>{if(p&&typeof p.init=="function"&&typeof p.createInferenceSessionHandler=="function"){let b=m.get(c);if(b===void 0)m.set(c,{backend:p,priority:g});else{if(b.priority>g)return;if(b.priority===g&&b.backend!==p)throw new Error(`cannot register backend "${c}" using priority ${g}`)}if(g>=0){let x=I.indexOf(c);x!==-1&&I.splice(x,1);for(let S=0;S<I.length;S++)if(m.get(I[S]).priority<=g){I.splice(S,0,c);return}I.push(c)}return}throw new TypeError("not a valid backend")},N=async c=>{let p=m.get(c);if(!p)return"backend not found.";if(p.initialized)return p.backend;if(p.aborted)return p.error;{let g=!!p.initPromise;try{return g||(p.initPromise=p.backend.init(c)),await p.initPromise,p.initialized=!0,p.backend}catch(b){return g||(p.error=`${b}`,p.aborted=!0),p.error}finally{delete p.initPromise}}},w=async c=>{let p=c.executionProviders||[],g=p.map(D=>typeof D=="string"?D:D.name),b=g.length===0?I:g,x,S=[],A=new Set;for(let D of b){let k=await N(D);typeof k=="string"?S.push({name:D,err:k}):(x||(x=k),x===k&&A.add(D))}if(!x)throw new Error(`no available backend found. ERR: ${S.map(D=>`[${D.name}] ${D.err}`).join(", ")}`);for(let{name:D,err:k}of S)g.includes(D)&&console.warn(`removing requested execution provider "${D}" from session options because it is not available: ${k}`);let $=p.filter(D=>A.has(typeof D=="string"?D:D.name));return[x,new Proxy(c,{get:(D,k)=>k==="executionProviders"?$:Reflect.get(D,k)})]}}),v=u(()=>{T()}),E,_=u(()=>{E="1.21.0"}),L,P,B=u(()=>{_(),L="warning",P={wasm:{},webgl:{},webgpu:{},versions:{common:E},set logLevel(c){if(c!==void 0){if(typeof c!="string"||["verbose","info","warning","error","fatal"].indexOf(c)===-1)throw new Error(`Unsupported logging level: ${c}`);L=c}},get logLevel(){return L}},Object.defineProperty(P,"logLevel",{enumerable:!0})}),U,Z=u(()=>{B(),U=P}),Y,ae,de=u(()=>{Y=(c,p)=>{let g=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);g.width=c.dims[3],g.height=c.dims[2];let b=g.getContext("2d");if(b!=null){let x,S;(p==null?void 0:p.tensorLayout)!==void 0&&p.tensorLayout==="NHWC"?(x=c.dims[2],S=c.dims[3]):(x=c.dims[3],S=c.dims[2]);let A=(p==null?void 0:p.format)!==void 0?p.format:"RGB",$=p==null?void 0:p.norm,D,k;$===void 0||$.mean===void 0?D=[255,255,255,255]:typeof $.mean=="number"?D=[$.mean,$.mean,$.mean,$.mean]:(D=[$.mean[0],$.mean[1],$.mean[2],0],$.mean[3]!==void 0&&(D[3]=$.mean[3])),$===void 0||$.bias===void 0?k=[0,0,0,0]:typeof $.bias=="number"?k=[$.bias,$.bias,$.bias,$.bias]:(k=[$.bias[0],$.bias[1],$.bias[2],0],$.bias[3]!==void 0&&(k[3]=$.bias[3]));let O=S*x,R=0,V=O,F=O*2,z=-1;A==="RGBA"?(R=0,V=O,F=O*2,z=O*3):A==="RGB"?(R=0,V=O,F=O*2):A==="RBG"&&(R=0,F=O,V=O*2);for(let G=0;G<S;G++)for(let X=0;X<x;X++){let K=(c.data[R++]-k[0])*D[0],q=(c.data[V++]-k[1])*D[1],te=(c.data[F++]-k[2])*D[2],ee=z===-1?255:(c.data[z++]-k[3])*D[3];b.fillStyle="rgba("+K+","+q+","+te+","+ee+")",b.fillRect(X,G,1,1)}if("toDataURL"in g)return g.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},ae=(c,p)=>{let g=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),b;if(g!=null){let x,S,A;(p==null?void 0:p.tensorLayout)!==void 0&&p.tensorLayout==="NHWC"?(x=c.dims[2],S=c.dims[1],A=c.dims[3]):(x=c.dims[3],S=c.dims[2],A=c.dims[1]);let $=p!==void 0&&p.format!==void 0?p.format:"RGB",D=p==null?void 0:p.norm,k,O;D===void 0||D.mean===void 0?k=[255,255,255,255]:typeof D.mean=="number"?k=[D.mean,D.mean,D.mean,D.mean]:(k=[D.mean[0],D.mean[1],D.mean[2],255],D.mean[3]!==void 0&&(k[3]=D.mean[3])),D===void 0||D.bias===void 0?O=[0,0,0,0]:typeof D.bias=="number"?O=[D.bias,D.bias,D.bias,D.bias]:(O=[D.bias[0],D.bias[1],D.bias[2],0],D.bias[3]!==void 0&&(O[3]=D.bias[3]));let R=S*x;if(p!==void 0&&(p.format!==void 0&&A===4&&p.format!=="RGBA"||A===3&&p.format!=="RGB"&&p.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let V=4,F=0,z=1,G=2,X=3,K=0,q=R,te=R*2,ee=-1;$==="RGBA"?(K=0,q=R,te=R*2,ee=R*3):$==="RGB"?(K=0,q=R,te=R*2):$==="RBG"&&(K=0,te=R,q=R*2),b=g.createImageData(x,S);for(let re=0;re<S*x;F+=V,z+=V,G+=V,X+=V,re++)b.data[F]=(c.data[K++]-O[0])*k[0],b.data[z]=(c.data[q++]-O[1])*k[1],b.data[G]=(c.data[te++]-O[2])*k[2],b.data[X]=ee===-1?255:(c.data[ee++]-O[3])*k[3]}else throw new Error("Can not access image data");return b}}),ce,Ie,be,ye,we,fe,De=u(()=>{ke(),ce=(c,p)=>{if(c===void 0)throw new Error("Image buffer must be defined");if(p.height===void 0||p.width===void 0)throw new Error("Image height and width must be defined");if(p.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:g,width:b}=p,x=p.norm??{mean:255,bias:0},S,A;typeof x.mean=="number"?S=[x.mean,x.mean,x.mean,x.mean]:S=[x.mean[0],x.mean[1],x.mean[2],x.mean[3]??255],typeof x.bias=="number"?A=[x.bias,x.bias,x.bias,x.bias]:A=[x.bias[0],x.bias[1],x.bias[2],x.bias[3]??0];let $=p.format!==void 0?p.format:"RGBA",D=p.tensorFormat!==void 0&&p.tensorFormat!==void 0?p.tensorFormat:"RGB",k=g*b,O=D==="RGBA"?new Float32Array(k*4):new Float32Array(k*3),R=4,V=0,F=1,z=2,G=3,X=0,K=k,q=k*2,te=-1;$==="RGB"&&(R=3,V=0,F=1,z=2,G=-1),D==="RGBA"?te=k*3:D==="RBG"?(X=0,q=k,K=k*2):D==="BGR"&&(q=0,K=k,X=k*2);for(let ee=0;ee<k;ee++,V+=R,z+=R,F+=R,G+=R)O[X++]=(c[V]+A[0])/S[0],O[K++]=(c[F]+A[1])/S[1],O[q++]=(c[z]+A[2])/S[2],te!==-1&&G!==-1&&(O[te++]=(c[G]+A[3])/S[3]);return D==="RGBA"?new _e("float32",O,[1,4,g,b]):new _e("float32",O,[1,3,g,b])},Ie=async(c,p)=>{let g=typeof HTMLImageElement<"u"&&c instanceof HTMLImageElement,b=typeof ImageData<"u"&&c instanceof ImageData,x=typeof ImageBitmap<"u"&&c instanceof ImageBitmap,S=typeof c=="string",A,$=p??{},D=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},k=O=>typeof HTMLCanvasElement<"u"&&O instanceof HTMLCanvasElement||O instanceof OffscreenCanvas?O.getContext("2d"):null;if(g){let O=D();O.width=c.width,O.height=c.height;let R=k(O);if(R!=null){let V=c.height,F=c.width;if(p!==void 0&&p.resizedHeight!==void 0&&p.resizedWidth!==void 0&&(V=p.resizedHeight,F=p.resizedWidth),p!==void 0){if($=p,p.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");$.tensorFormat="RGBA",$.height=V,$.width=F}else $.tensorFormat="RGBA",$.height=V,$.width=F;R.drawImage(c,0,0),A=R.getImageData(0,0,F,V).data}else throw new Error("Can not access image data")}else if(b){let O,R;if(p!==void 0&&p.resizedWidth!==void 0&&p.resizedHeight!==void 0?(O=p.resizedHeight,R=p.resizedWidth):(O=c.height,R=c.width),p!==void 0&&($=p),$.format="RGBA",$.height=O,$.width=R,p!==void 0){let V=D();V.width=R,V.height=O;let F=k(V);if(F!=null)F.putImageData(c,0,0),A=F.getImageData(0,0,R,O).data;else throw new Error("Can not access image data")}else A=c.data}else if(x){if(p===void 0)throw new Error("Please provide image config with format for Imagebitmap");let O=D();O.width=c.width,O.height=c.height;let R=k(O);if(R!=null){let V=c.height,F=c.width;return R.drawImage(c,0,0,F,V),A=R.getImageData(0,0,F,V).data,$.height=V,$.width=F,ce(A,$)}else throw new Error("Can not access image data")}else{if(S)return new Promise((O,R)=>{let V=D(),F=k(V);if(!c||!F)return R();let z=new Image;z.crossOrigin="Anonymous",z.src=c,z.onload=()=>{V.width=z.width,V.height=z.height,F.drawImage(z,0,0,V.width,V.height);let G=F.getImageData(0,0,V.width,V.height);$.height=V.height,$.width=V.width,O(ce(G.data,$))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(A!==void 0)return ce(A,$);throw new Error("Input data provided is not supported - aborted tensor creation")},be=(c,p)=>{let{width:g,height:b,download:x,dispose:S}=p,A=[1,b,g,4];return new _e({location:"texture",type:"float32",texture:c,dims:A,download:x,dispose:S})},ye=(c,p)=>{let{dataType:g,dims:b,download:x,dispose:S}=p;return new _e({location:"gpu-buffer",type:g??"float32",gpuBuffer:c,dims:b,download:x,dispose:S})},we=(c,p)=>{let{dataType:g,dims:b,download:x,dispose:S}=p;return new _e({location:"ml-tensor",type:g??"float32",mlTensor:c,dims:b,download:x,dispose:S})},fe=(c,p,g)=>new _e({location:"cpu-pinned",type:c,data:p,dims:g??[p.length]})}),Pe,Fe,Ue,Ge,Ze=u(()=>{Pe=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Fe=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Ue=!1,Ge=()=>{if(!Ue){Ue=!0;let c=typeof BigInt64Array<"u"&&BigInt64Array.from,p=typeof BigUint64Array<"u"&&BigUint64Array.from,g=globalThis.Float16Array,b=typeof g<"u"&&g.from;c&&(Pe.set("int64",BigInt64Array),Fe.set(BigInt64Array,"int64")),p&&(Pe.set("uint64",BigUint64Array),Fe.set(BigUint64Array,"uint64")),b?(Pe.set("float16",g),Fe.set(g,"float16")):Pe.set("float16",Uint16Array)}}}),je,Qe,he=u(()=>{ke(),je=c=>{let p=1;for(let g=0;g<c.length;g++){let b=c[g];if(typeof b!="number"||!Number.isSafeInteger(b))throw new TypeError(`dims[${g}] must be an integer, got: ${b}`);if(b<0)throw new RangeError(`dims[${g}] must be a non-negative integer, got: ${b}`);p*=b}return p},Qe=(c,p)=>{switch(c.location){case"cpu":return new _e(c.type,c.data,p);case"cpu-pinned":return new _e({location:"cpu-pinned",data:c.data,type:c.type,dims:p});case"texture":return new _e({location:"texture",texture:c.texture,type:c.type,dims:p});case"gpu-buffer":return new _e({location:"gpu-buffer",gpuBuffer:c.gpuBuffer,type:c.type,dims:p});case"ml-tensor":return new _e({location:"ml-tensor",mlTensor:c.mlTensor,type:c.type,dims:p});default:throw new Error(`tensorReshape: tensor location ${c.location} is not supported`)}}}),_e,ke=u(()=>{de(),De(),Ze(),he(),_e=class{constructor(c,p,g){Ge();let b,x;if(typeof c=="object"&&"location"in c)switch(this.dataLocation=c.location,b=c.type,x=c.dims,c.location){case"cpu-pinned":{let A=Pe.get(b);if(!A)throw new TypeError(`unsupported type "${b}" to create tensor from pinned buffer`);if(!(c.data instanceof A))throw new TypeError(`buffer should be of type ${A.name}`);this.cpuData=c.data;break}case"texture":{if(b!=="float32")throw new TypeError(`unsupported type "${b}" to create tensor from texture`);this.gpuTextureData=c.texture,this.downloader=c.download,this.disposer=c.dispose;break}case"gpu-buffer":{if(b!=="float32"&&b!=="float16"&&b!=="int32"&&b!=="int64"&&b!=="uint32"&&b!=="uint8"&&b!=="bool"&&b!=="uint4"&&b!=="int4")throw new TypeError(`unsupported type "${b}" to create tensor from gpu buffer`);this.gpuBufferData=c.gpuBuffer,this.downloader=c.download,this.disposer=c.dispose;break}case"ml-tensor":{if(b!=="float32"&&b!=="float16"&&b!=="int32"&&b!=="int64"&&b!=="uint32"&&b!=="uint64"&&b!=="int8"&&b!=="uint8"&&b!=="bool"&&b!=="uint4"&&b!=="int4")throw new TypeError(`unsupported type "${b}" to create tensor from MLTensor`);this.mlTensorData=c.mlTensor,this.downloader=c.download,this.disposer=c.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let A,$;if(typeof c=="string")if(b=c,$=g,c==="string"){if(!Array.isArray(p))throw new TypeError("A string tensor's data must be a string array.");A=p}else{let D=Pe.get(c);if(D===void 0)throw new TypeError(`Unsupported tensor type: ${c}.`);if(Array.isArray(p)){if(c==="float16"&&D===Uint16Array||c==="uint4"||c==="int4")throw new TypeError(`Creating a ${c} tensor from number array is not supported. Please use ${D.name} as data.`);c==="uint64"||c==="int64"?A=D.from(p,BigInt):A=D.from(p)}else if(p instanceof D)A=p;else if(p instanceof Uint8ClampedArray)if(c==="uint8")A=Uint8Array.from(p);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(c==="float16"&&p instanceof Uint16Array&&D!==Uint16Array)A=new globalThis.Float16Array(p.buffer,p.byteOffset,p.length);else throw new TypeError(`A ${b} tensor's data must be type of ${D}`)}else if($=p,Array.isArray(c)){if(c.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let D=typeof c[0];if(D==="string")b="string",A=c;else if(D==="boolean")b="bool",A=Uint8Array.from(c);else throw new TypeError(`Invalid element type of data array: ${D}.`)}else if(c instanceof Uint8ClampedArray)b="uint8",A=Uint8Array.from(c);else{let D=Fe.get(c.constructor);if(D===void 0)throw new TypeError(`Unsupported type for tensor data: ${c.constructor}.`);b=D,A=c}if($===void 0)$=[A.length];else if(!Array.isArray($))throw new TypeError("A tensor's dims must be a number array");x=$,this.cpuData=A,this.dataLocation="cpu"}let S=je(x);if(this.cpuData&&S!==this.cpuData.length&&!((b==="uint4"||b==="int4")&&Math.ceil(S/2)===this.cpuData.length))throw new Error(`Tensor's size(${S}) does not match data length(${this.cpuData.length}).`);this.type=b,this.dims=x,this.size=S}static async fromImage(c,p){return Ie(c,p)}static fromTexture(c,p){return be(c,p)}static fromGpuBuffer(c,p){return ye(c,p)}static fromMLTensor(c,p){return we(c,p)}static fromPinnedBuffer(c,p,g){return fe(c,p,g)}toDataURL(c){return Y(this,c)}toImageData(c){return ae(this,c)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(c){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let p=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=p,c&&this.disposer&&(this.disposer(),this.disposer=void 0),p}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(c){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Qe(this,c)}}}),ze,at=u(()=>{ke(),ze=_e}),xt,j,Q,ue,Ee=u(()=>{B(),xt=(c,p)=>{(typeof P.trace>"u"?!P.wasm.trace:!P.trace)||console.timeStamp(`${c}::ORT::${p}`)},j=(c,p)=>{var x;let g=((x=new Error().stack)==null?void 0:x.split(/\r\n|\r|\n/g))||[],b=!1;for(let S=0;S<g.length;S++){if(b&&!g[S].includes("TRACE_FUNC")){let A=`FUNC_${c}::${g[S].trim().split(" ")[1]}`;p&&(A+=`::${p}`),xt("CPU",A);return}g[S].includes("TRACE_FUNC")&&(b=!0)}},Q=c=>{(typeof P.trace>"u"?!P.wasm.trace:!P.trace)||j("BEGIN",c)},ue=c=>{(typeof P.trace>"u"?!P.wasm.trace:!P.trace)||j("END",c)}}),Se,Oe=u(()=>{T(),at(),Ee(),Se=class ek{constructor(p){this.handler=p}async run(p,g,b){Q();let x={},S={};if(typeof p!="object"||p===null||p instanceof ze||Array.isArray(p))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let A=!0;if(typeof g=="object"){if(g===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(g instanceof ze)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(g)){if(g.length===0)throw new TypeError("'fetches' cannot be an empty array.");A=!1;for(let k of g){if(typeof k!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(k)===-1)throw new RangeError(`'fetches' contains invalid output name: ${k}.`);x[k]=null}if(typeof b=="object"&&b!==null)S=b;else if(typeof b<"u")throw new TypeError("'options' must be an object.")}else{let k=!1,O=Object.getOwnPropertyNames(g);for(let R of this.outputNames)if(O.indexOf(R)!==-1){let V=g[R];(V===null||V instanceof ze)&&(k=!0,A=!1,x[R]=V)}if(k){if(typeof b=="object"&&b!==null)S=b;else if(typeof b<"u")throw new TypeError("'options' must be an object.")}else S=g}}else if(typeof g<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let k of this.inputNames)if(typeof p[k]>"u")throw new Error(`input '${k}' is missing in 'feeds'.`);if(A)for(let k of this.outputNames)x[k]=null;let $=await this.handler.run(p,x,S),D={};for(let k in $)if(Object.hasOwnProperty.call($,k)){let O=$[k];O instanceof ze?D[k]=O:D[k]=new ze(O.type,O.data,O.dims)}return ue(),D}async release(){return this.handler.dispose()}static async create(p,g,b,x){Q();let S,A={};if(typeof p=="string"){if(S=p,typeof g=="object"&&g!==null)A=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else if(p instanceof Uint8Array){if(S=p,typeof g=="object"&&g!==null)A=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else if(p instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&p instanceof SharedArrayBuffer){let O=p,R=0,V=p.byteLength;if(typeof g=="object"&&g!==null)A=g;else if(typeof g=="number"){if(R=g,!Number.isSafeInteger(R))throw new RangeError("'byteOffset' must be an integer.");if(R<0||R>=O.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${O.byteLength}).`);if(V=p.byteLength-R,typeof b=="number"){if(V=b,!Number.isSafeInteger(V))throw new RangeError("'byteLength' must be an integer.");if(V<=0||R+V>O.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${O.byteLength-R}].`);if(typeof x=="object"&&x!==null)A=x;else if(typeof x<"u")throw new TypeError("'options' must be an object.")}else if(typeof b<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof g<"u")throw new TypeError("'options' must be an object.");S=new Uint8Array(O,R,V)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[$,D]=await w(A),k=await $.createInferenceSessionHandler(S,D);return ue(),new ek(k)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Xe,qe=u(()=>{Oe(),Xe=Se}),Ye=u(()=>{}),We=u(()=>{}),Nt=u(()=>{}),Je=u(()=>{}),ct={};d(ct,{InferenceSession:()=>Xe,TRACE:()=>xt,TRACE_FUNC_BEGIN:()=>Q,TRACE_FUNC_END:()=>ue,Tensor:()=>ze,env:()=>U,registerBackend:()=>y});var dt=u(()=>{v(),Z(),qe(),at(),Ye(),We(),Ee(),Nt(),Je()}),Dt=u(()=>{}),qt={};d(qt,{default:()=>kn});var Ut,Bn,kn,Us=u(()=>{var c;f$(),bo(),vg(),Ut="ort-wasm-proxy-worker",Bn=((c=globalThis.self)==null?void 0:c.name)===Ut,Bn&&(self.onmessage=p=>{let{type:g,in:b}=p.data;try{switch(g){case"init-wasm":Dg(b.wasm).then(()=>{F0(b).then(()=>{postMessage({type:g})},x=>{postMessage({type:g,err:x})})},x=>{postMessage({type:g,err:x})});break;case"init-ep":{let{epName:x,env:S}=b;z0(S,x).then(()=>{postMessage({type:g})},A=>{postMessage({type:g,err:A})});break}case"copy-from":{let{buffer:x}=b,S=jh(x);postMessage({type:g,out:S});break}case"create":{let{model:x,options:S}=b;M0(x,S).then(A=>{postMessage({type:g,out:A})},A=>{postMessage({type:g,err:A})});break}case"release":W0(b),postMessage({type:g});break;case"run":{let{sessionId:x,inputIndices:S,inputs:A,outputIndices:$,options:D}=b;H0(x,S,A,$,new Array($.length).fill(null),D).then(k=>{k.some(O=>O[3]!=="cpu")?postMessage({type:g,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:g,out:k},G0([...A,...k]))},k=>{postMessage({type:g,err:k})});break}case"end-profiling":U0(b),postMessage({type:g});break;default:}}catch(x){postMessage({type:g,err:x})}}),kn=Bn?null:p=>new Worker(p??cs,{type:"classic",name:Ut})}),Hn,vi,cs,As,Gs,ju,Ux,Ag,Gx,Tg,qx,Sg,Kx,vg=u(()=>{Dt(),Hn=typeof location>"u"?void 0:location.origin,vi=()=>{var c,p;return typeof document<"u"?(c=document.currentScript)==null?void 0:c.src:typeof self<"u"?(p=self.location)==null?void 0:p.href:void 0},cs=vi(),As=()=>{if(cs&&!cs.startsWith("blob:"))return cs.substring(0,cs.lastIndexOf("/")+1)},Gs=(c,p)=>{try{let g=p??cs;return(g?new URL(c,g):new URL(c)).origin===Hn}catch{return!1}},ju=(c,p)=>{let g=p??cs;try{return(g?new URL(c,g):new URL(c)).href}catch{return}},Ux=(c,p)=>`${p??"./"}${c}`,Ag=async c=>{let p=await(await fetch(c,{credentials:"same-origin"})).blob();return URL.createObjectURL(p)},Gx=async c=>(await Xz(()=>import(c),[],import.meta.url)).default,Tg=(Us(),f(qt)).default,qx=async()=>{if(!cs)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Gs(cs))return[void 0,Tg()];let c=await Ag(cs);return[c,Tg(c)]},Sg=void 0,Kx=async(c,p,g)=>{if(!c&&!p&&Sg&&cs&&Gs(cs))return[void 0,Sg];{let b="ort-wasm-simd-threaded.jsep.mjs",x=c??ju(b,p),S=g&&x&&!Gs(x,p),A=S?await Ag(x):x??Ux(b,p);return[S?A:void 0,await Gx(A)]}}}),$g,Ch,Yu,_g,jx,Yx,Dg,ts,bo=u(()=>{vg(),Ch=!1,Yu=!1,_g=!1,jx=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Yx=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Dg=async c=>{if(Ch)return Promise.resolve();if(Yu)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(_g)throw new Error("previous call to 'initializeWebAssembly()' failed.");Yu=!0;let p=c.initTimeout,g=c.numThreads;if(!Yx())throw new Error("WebAssembly SIMD is not supported in the current environment.");let b=jx();g>1&&!b&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+g+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),c.numThreads=g=1);let x=c.wasmPaths,S=typeof x=="string"?x:void 0,A=x==null?void 0:x.mjs,$=(A==null?void 0:A.href)??A,D=x==null?void 0:x.wasm,k=(D==null?void 0:D.href)??D,O=c.wasmBinary,[R,V]=await Kx($,S,g>1),F=!1,z=[];if(p>0&&z.push(new Promise(G=>{setTimeout(()=>{F=!0,G()},p)})),z.push(new Promise((G,X)=>{let K={numThreads:g};if(O)K.wasmBinary=O;else if(k||S)K.locateFile=q=>k??S+q;else if($&&$.indexOf("blob:")!==0)K.locateFile=q=>new URL(q,$).href;else if(R){let q=As();q&&(K.locateFile=te=>q+te)}V(K).then(q=>{Yu=!1,Ch=!0,$g=q,G(),R&&URL.revokeObjectURL(R)},q=>{Yu=!1,_g=!0,X(q)})})),await Promise.race(z),F)throw new Error(`WebAssembly backend initializing failed due to timeout: ${p}ms`)},ts=()=>{if(Ch&&$g)return $g;throw new Error("WebAssembly is not initialized yet.")}}),Ts,Lh,nn,Eg=u(()=>{bo(),Ts=(c,p)=>{let g=ts(),b=g.lengthBytesUTF8(c)+1,x=g._malloc(b);return g.stringToUTF8(c,x,b),p.push(x),x},Lh=(c,p,g,b)=>{if(typeof c=="object"&&c!==null){if(g.has(c))throw new Error("Circular reference in options");g.add(c)}Object.entries(c).forEach(([x,S])=>{let A=p?p+x:x;if(typeof S=="object")Lh(S,A+".",g,b);else if(typeof S=="string"||typeof S=="number")b(A,S.toString());else if(typeof S=="boolean")b(A,S?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof S}`)})},nn=c=>{let p=ts(),g=p.stackSave();try{let b=p.PTR_SIZE,x=p.stackAlloc(2*b);p._OrtGetLastError(x,x+b);let S=Number(p.getValue(x,b===4?"i32":"i64")),A=p.getValue(x+b,"*"),$=A?p.UTF8ToString(A):"";throw new Error(`${c} ERROR_CODE: ${S}, ERROR_MESSAGE: ${$}`)}finally{p.stackRestore(g)}}}),Xx,tP=u(()=>{bo(),Eg(),Xx=c=>{let p=ts(),g=0,b=[],x=c||{};try{if((c==null?void 0:c.logSeverityLevel)===void 0)x.logSeverityLevel=2;else if(typeof c.logSeverityLevel!="number"||!Number.isInteger(c.logSeverityLevel)||c.logSeverityLevel<0||c.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${c.logSeverityLevel}`);if((c==null?void 0:c.logVerbosityLevel)===void 0)x.logVerbosityLevel=0;else if(typeof c.logVerbosityLevel!="number"||!Number.isInteger(c.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${c.logVerbosityLevel}`);(c==null?void 0:c.terminate)===void 0&&(x.terminate=!1);let S=0;return(c==null?void 0:c.tag)!==void 0&&(S=Ts(c.tag,b)),g=p._OrtCreateRunOptions(x.logSeverityLevel,x.logVerbosityLevel,!!x.terminate,S),g===0&&nn("Can't create run options."),(c==null?void 0:c.extra)!==void 0&&Lh(c.extra,"",new WeakSet,(A,$)=>{let D=Ts(A,b),k=Ts($,b);p._OrtAddRunConfigEntry(g,D,k)!==0&&nn(`Can't set a run config entry: ${A} - ${$}.`)}),[g,b]}catch(S){throw g!==0&&p._OrtReleaseRunOptions(g),b.forEach(A=>p._free(A)),S}}}),Zx,Qx,Jx,eN,tN,nP=u(()=>{bo(),Eg(),Zx=c=>{switch(c){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${c}`)}},Qx=c=>{switch(c){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${c}`)}},Jx=c=>{c.extra||(c.extra={}),c.extra.session||(c.extra.session={});let p=c.extra.session;p.use_ort_model_bytes_directly||(p.use_ort_model_bytes_directly="1"),c.executionProviders&&c.executionProviders.some(g=>(typeof g=="string"?g:g.name)==="webgpu")&&(c.enableMemPattern=!1)},eN=(c,p,g)=>{for(let b of p){let x=typeof b=="string"?b:b.name;switch(x){case"webnn":if(x="WEBNN",typeof b!="string"){let A=b==null?void 0:b.deviceType;if(A){let $=Ts("deviceType",g),D=Ts(A,g);ts()._OrtAddSessionConfigEntry(c,$,D)!==0&&nn(`Can't set a session config entry: 'deviceType' - ${A}.`)}}break;case"webgpu":if(x="JS",typeof b!="string"){let A=b;if(A!=null&&A.preferredLayout){if(A.preferredLayout!=="NCHW"&&A.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${A.preferredLayout}`);let $=Ts("preferredLayout",g),D=Ts(A.preferredLayout,g);ts()._OrtAddSessionConfigEntry(c,$,D)!==0&&nn(`Can't set a session config entry: 'preferredLayout' - ${A.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${x}`)}let S=Ts(x,g);ts()._OrtAppendExecutionProvider(c,S)!==0&&nn(`Can't append execution provider: ${x}.`)}},tN=c=>{let p=ts(),g=0,b=[],x=c||{};Jx(x);try{let S=Zx(x.graphOptimizationLevel??"all"),A=Qx(x.executionMode??"sequential"),$=typeof x.logId=="string"?Ts(x.logId,b):0,D=x.logSeverityLevel??2;if(!Number.isInteger(D)||D<0||D>4)throw new Error(`log serverity level is not valid: ${D}`);let k=x.logVerbosityLevel??0;if(!Number.isInteger(k)||k<0||k>4)throw new Error(`log verbosity level is not valid: ${k}`);let O=typeof x.optimizedModelFilePath=="string"?Ts(x.optimizedModelFilePath,b):0;if(g=p._OrtCreateSessionOptions(S,!!x.enableCpuMemArena,!!x.enableMemPattern,A,!!x.enableProfiling,0,$,D,k,O),g===0&&nn("Can't create session options."),x.executionProviders&&eN(g,x.executionProviders,b),x.enableGraphCapture!==void 0){if(typeof x.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${x.enableGraphCapture}`);let R=Ts("enableGraphCapture",b),V=Ts(x.enableGraphCapture.toString(),b);p._OrtAddSessionConfigEntry(g,R,V)!==0&&nn(`Can't set a session config entry: 'enableGraphCapture' - ${x.enableGraphCapture}.`)}if(x.freeDimensionOverrides)for(let[R,V]of Object.entries(x.freeDimensionOverrides)){if(typeof R!="string")throw new Error(`free dimension override name must be a string: ${R}`);if(typeof V!="number"||!Number.isInteger(V)||V<0)throw new Error(`free dimension override value must be a non-negative integer: ${V}`);let F=Ts(R,b);p._OrtAddFreeDimensionOverride(g,F,V)!==0&&nn(`Can't set a free dimension override: ${R} - ${V}.`)}return x.extra!==void 0&&Lh(x.extra,"",new WeakSet,(R,V)=>{let F=Ts(R,b),z=Ts(V,b);p._OrtAddSessionConfigEntry(g,F,z)!==0&&nn(`Can't set a session config entry: ${R} - ${V}.`)}),[g,b]}catch(S){throw g!==0&&p._OrtReleaseSessionOptions(g)!==0&&nn("Can't release session options."),b.forEach(A=>p._free(A)),S}}}),Ol,xo,No,kg,Oh,Cg,Lg,Og,vt=u(()=>{Ol=c=>{switch(c){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${c}`)}},xo=c=>{switch(c){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${c}`)}},No=(c,p)=>{let g=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][c],b=typeof p=="number"?p:p.reduce((x,S)=>x*S,1);return g>0?Math.ceil(b*g):void 0},kg=c=>{switch(c){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${c}`)}},Oh=c=>{switch(c){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${c}`)}},Cg=c=>c==="float32"||c==="float16"||c==="int32"||c==="int64"||c==="uint32"||c==="uint8"||c==="bool"||c==="uint4"||c==="int4",Lg=c=>c==="float32"||c==="float16"||c==="int32"||c==="int64"||c==="uint32"||c==="uint64"||c==="int8"||c==="uint8"||c==="bool"||c==="uint4"||c==="int4",Og=c=>{switch(c){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${c}`)}}}),Rg,nN=u(()=>{Dt(),Rg=async c=>{if(typeof c=="string"){let p=await fetch(c);if(!p.ok)throw new Error(`failed to load external data file: ${c}`);let g=p.headers.get("Content-Length"),b=g?parseInt(g,10):0;if(b<1073741824)return new Uint8Array(await p.arrayBuffer());{if(!p.body)throw new Error(`failed to load external data file: ${c}, no response body.`);let x=p.body.getReader(),S;try{S=new ArrayBuffer(b)}catch($){if($ instanceof RangeError){let D=Math.ceil(b/65536);S=new WebAssembly.Memory({initial:D,maximum:D}).buffer}else throw $}let A=0;for(;;){let{done:$,value:D}=await x.read();if($)break;let k=D.byteLength;new Uint8Array(S,A,k).set(D),A+=k}return new Uint8Array(S,0,b)}}else return c instanceof Blob?new Uint8Array(await c.arrayBuffer()):c instanceof Uint8Array?c:new Uint8Array(c)}}),sN,rN,iN,aN,Vg,oN,jt,Qi=u(()=>{vt(),sN=["V","I","W","E","F"],rN=(c,p)=>{console.log(`[${sN[c]},${new Date().toISOString()}]${p}`)},Vg=(c,p)=>{iN=c,aN=p},oN=(c,p)=>{let g=Oh(c),b=Oh(iN);g>=b&&rN(g,typeof p=="function"?p():p)},jt=(...c)=>{aN&&oN(...c)}}),Pg,lN=u(()=>{vt(),Pg=(c,p)=>new(kg(p))(c)}),Fg=u(()=>{}),zg,Rh,Vh,uN,cN,Mg,Wg,dN,hN,sP=u(()=>{Qi(),Fg(),zg=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Rh=[],Vh=c=>Math.ceil(Number(c)/16)*16,uN=c=>{for(let p=0;p<Rh.length;p++){let g=Rh[p];if(c<=g)return g}return Math.ceil(c/16)*16},cN=1,Mg=()=>cN++,Wg=async(c,p,g,b)=>{let x=Vh(g),S=c.device.createBuffer({size:x,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let A=c.getCommandEncoder();c.endComputePass(),A.copyBufferToBuffer(p,0,S,0,x),c.flush(),await S.mapAsync(GPUMapMode.READ);let $=S.getMappedRange();if(b){let D=b();return D.set(new Uint8Array($,0,g)),D}else return new Uint8Array($.slice(0,g))}finally{S.destroy()}},dN=class{constructor(c){this.backend=c,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[p]of zg)Rh.push(p),this.freeBuffers.set(p,[]),this.freeUniformBuffers.set(p,[]);this.sessionCount=0}upload(c,p){let g=p.buffer,b=p.byteOffset,x=p.byteLength,S=Vh(x),A=this.storageCache.get(c);if(!A)throw new Error("gpu data for uploading does not exist");if(Number(A.originalSize)!==x)throw new Error(`inconsistent data size. gpu data size=${A.originalSize}, data size=${x}`);let $=this.backend.device.createBuffer({mappedAtCreation:!0,size:S,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),D=$.getMappedRange();new Uint8Array(D).set(new Uint8Array(g,b,x)),$.unmap();let k=this.backend.device.createCommandEncoder();k.copyBufferToBuffer($,0,A.gpuData.buffer,0,S),this.backend.device.queue.submit([k.finish()]),$.destroy(),jt("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${c})`)}memcpy(c,p){let g=this.storageCache.get(c);if(!g)throw new Error("source gpu data for memcpy does not exist");let b=this.storageCache.get(p);if(!b)throw new Error("destination gpu data for memcpy does not exist");if(g.originalSize!==b.originalSize)throw new Error("inconsistent source and destination gpu data size");let x=Vh(g.originalSize),S=this.backend.getCommandEncoder();this.backend.endComputePass(),S.copyBufferToBuffer(g.gpuData.buffer,0,b.gpuData.buffer,0,x)}registerExternalBuffer(c,p,g){let b;if(g){if(b=g[0],c===g[1])return jt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${p}) => id=${b}, buffer is the same, skip.`),b;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else b=Mg();return this.storageCache.set(b,{gpuData:{id:b,type:0,buffer:c},originalSize:p}),jt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${p}) => id=${b}, registered.`),b}unregisterExternalBuffer(c){c!==void 0&&(this.storageCache.delete(c),jt("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${c}`))}create(c,p=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let g=uN(c),b,x=(p&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,S=(p&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(x||S){let $=(x?this.freeBuffers:this.freeUniformBuffers).get(g);$?$.length>0?b=$.pop():b=this.backend.device.createBuffer({size:g,usage:p}):b=this.backend.device.createBuffer({size:g,usage:p})}else b=this.backend.device.createBuffer({size:g,usage:p});let A={id:Mg(),type:0,buffer:b};return this.storageCache.set(A.id,{gpuData:A,originalSize:Number(c)}),jt("verbose",()=>`[WebGPU] GpuDataManager.create(size=${c}) => id=${A.id}`),A}get(c){var p;return(p=this.storageCache.get(c))==null?void 0:p.gpuData}release(c){let p=typeof c=="bigint"?Number(c):c,g=this.storageCache.get(p);if(!g){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return jt("verbose",()=>`[WebGPU] GpuDataManager.release(id=${p}), gpuDataId=${g.gpuData.id}`),this.storageCache.delete(p),this.buffersPending.push(g.gpuData.buffer),g.originalSize}async download(c,p){let g=this.storageCache.get(Number(c));if(!g)throw new Error("data does not exist");await Wg(this.backend,g.gpuData.buffer,g.originalSize,p)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let c of this.buffersPending){let p=zg.get(c.size);if((c.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let g=this.freeBuffers.get(c.size)||[];p===void 0||g.length>=p?c.destroy():g.push(c)}else if((c.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let g=this.freeUniformBuffers.get(c.size)||[];p===void 0||g.length>=p?c.destroy():g.push(c)}else c.destroy()}this.buffersPending=[]}else{let c=this.capturedPendingBuffers.get(this.backend.currentSessionId);c||(c=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,c));for(let p of this.buffersPending)c.push(p);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(c=>{c.forEach(p=>{p.destroy()})}),this.freeUniformBuffers.forEach(c=>{c.forEach(p=>{p.destroy()})}),this.storageCache.forEach(c=>{c.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(c=>{c.forEach(p=>{p.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(c){let p=this.capturedPendingBuffers.get(c);p&&(p.forEach(g=>{g.destroy()}),this.capturedPendingBuffers.delete(c)),this.sessionCount-=1,this.sessionCount===0&&(jt("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(g=>{g.gpuData.buffer.destroy()}),this.storageCache=new Map)}},hN=(...c)=>new dN(...c)}),pN,rn,Cn=u(()=>{pN=class{constructor(c){Object.assign(this,c)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(c=>`${this[c]}`).join(";")),this.key}},rn=c=>new pN(c)}),fN,Rl,Ae,Ph,mN,gN,IN,Et=u(()=>{fN=class{static calcMatMulShape(c,p){return c[1]!==p[0]?void 0:[c[0],p[1]]}},Rl=class{static calcShape(c,p,g=!1){let b=c.length,x=p.length;if(b===0)return p;if(x===0)return c;let S=Math.max(c.length,p.length),A=new Array(S);if(g){if(b<2||x<2)return;let $=fN.calcMatMulShape([c[b-2],c[b-1]],[p[x-2],p[x-1]]);if($===void 0)return;[A[S-2],A[S-1]]=$}for(let $=g?3:1;$<=S;$++){let D=b-$<0?1:c[b-$],k=x-$<0?1:p[x-$];if(D!==k&&D>1&&k>1)return;let O=Math.max(D,k);if(D&&k)A[S-$]=Math.max(D,k);else{if(O>1)return;A[S-$]=0}}return A}static isValidBroadcast(c,p){let g=c.length,b=p.length;if(g>b)return!1;for(let x=1;x<=g;x++)if(c[g-x]!==1&&c[g-x]!==p[b-x])return!1;return!0}},Ae=class wp{static size(p){return wp.getSizeFromDimensionRange(p,0,p.length)}static convertShape(p,g=4){let b=p.length;if(b===0)return[];let x=new Array(b),S=b-1;for(;S>=0;){if(p[S]%g===0){x[S]=p[S]/g;break}if(g%p[S]!==0)throw new Error("cannot convert shape");x[S]=1,g/=p[S],S--}for(S--;S>=0;S--)x[S]=p[S];return x}static sizeFromDimension(p,g){if(g<0||g>p.length)throw new Error(`invalid dimension of ${g} for sizeFromDimension as Tensor has ${p.length} dimensions.`);return wp.getSizeFromDimensionRange(p,g,p.length)}static sizeToDimension(p,g){if(g<0||g>p.length)throw new Error(`invalid dimension of ${g} for sizeToDimension as Tensor has ${p.length} dimensions.`);return wp.getSizeFromDimensionRange(p,0,g)}static getSizeFromDimensionRange(p,g,b){let x=1;for(let S=g;S<b;S++){if(p[S]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");x*=Number(p[S])}return x}static computeStrides(p){let g=p.length;if(g===0)return[];if(g===1)return[1];let b=new Array(g);b[g-1]=1,b[g-2]=p[g-1];for(let x=g-3;x>=0;--x)b[x]=b[x+1]*p[x+1];return b}static normalizeAxis(p,g){if(p<-g&&p>=g)throw new Error("unsupported axis for this operation.");return p<0?p+g:p}static normalizeAxes(p,g){return p.map(b=>this.normalizeAxis(b,g??p.length))}static sortBasedOnPerm(p,g){return g?g.map(b=>p[b]):p.slice().reverse()}static padShape(p,g){let b=p.length;return p.map((x,S)=>x+g[S]+g[S+b])}static areEqual(p,g){return p.length!==g.length?!1:p.every((b,x)=>b===g[x])}},Ph=class yc{static adjustPoolAttributes(p,g,b,x,S,A){if(!p&&b.length!==g.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(p)for(let $=0;$<g.length-2;$++)$>=b.length?b.push(g[$+2]):b[$]=g[$+2];for(let $=0;$<b.length;$++)if($<x.length){if(x[$]<0)throw new Error("strides should be greater than or equal to 1")}else x.push(1);for(let $=0;$<b.length;$++)if($<S.length){if(S[$]<0)throw new Error("dilations should be greater than or equal to 1")}else S.push(1);for(let $=0;$<b.length*2;$++)if($<A.length){if(A[$]<0)throw new Error("pad should be greater than or equal to 1")}else A.push(0);for(let $=0;$<b.length;$++){if(b[$]<=0)throw new Error("kernel shapes need to be greater than 0");if(A[$]>=b[$]||A[$+b.length]>=b[$])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(p,g,b,x,S,A,$){if($){if(S.length!==2*(p.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(g.length!==p.length-2)throw new Error("length of strides should be the length of data dimensions");if(x.length!==p.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let D=0;D<p.length-2;D++)yc.adjustPadAndReturnShape(p[D+(A?1:2)],g[D],b[D],x[D],S,D,D+p.length-2,$)}}static computePoolOutputShape(p,g,b,x,S,A,$){if(g.length<=0)throw new Error("input shape must be of size greater than 0");let D=[g[0],g[1]];return yc.computeShapeHelper(p,g,D,b,x,S,A,$),D}static computeConvOutputShape(p,g,b,x,S,A,$){if(p.length<=0||g.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let D=[p[0],g[0]];return yc.computeShapeHelper(!1,p,D,b,x,S,A,$),D}static computeShapeHelper(p,g,b,x,S,A,$,D){if(p)for(let k=0;k<g.length-2;k++)b.push(1);else for(let k=0;k<g.length-2;k++)b.push(yc.adjustPadAndReturnShape(g[k+2],x[k],S[k],A[k],$,k,k+g.length-2,D))}static adjustPadAndReturnShape(p,g,b,x,S,A,$,D){let k=b*(x-1)+1;if(D&&D!=="NOTSET")switch(D){case"VALID":return S[A]=0,S[$]=0,Math.floor((p-k)/g+1);case"SAME_LOWER":case"SAME_UPPER":if(b!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let O=((p+g-1)/g-1)*g+x-p;return S[A]=Math.floor(D==="SAME_LOWER"?(O+1)/2:O/2),S[$]=O-S[A],Math.floor((p+O-x)/g+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((p+S[A]+S[$]-k)/g+1)}},mN=class{static getShapeOfGemmResult(c,p,g,b,x){if(c.length!==2||g.length!==2)throw new Error("shape need to be of size 2");let S,A,$;p?(S=c[1],A=c[0]):(S=c[0],A=c[1]);let D=-1;if(b?($=g[0],D=1):($=g[1],D=0),g[D]!==A)throw new Error("dimension mismatch");if(S<=0||$<=0||A<=0)throw new Error("invalid shape specified");if(x&&!Rl.isValidBroadcast(x,[S,$]))throw new Error("gemm: invalid bias shape for broadcast");return[S,$,A]}},gN=-34028234663852886e22,IN=34028234663852886e22}),Vl,Fh,ns,Es,It,Sn,Bg,Pl,Ta,pt,Xu,Ce,ht,yN,Hg,bN,xN,Ct=u(()=>{vt(),Et(),Vl=64,Fh=(c,p)=>{if(p===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(c)){case 10:return p>1?`vec${p}<f16>`:"f16";case 1:return p>1?`vec${p}<f32>`:"f32";case 6:return p>1?`vec${p}<i32>`:"i32";case 12:return p>1?`vec${p}<u32>`:"u32";case 7:if(p>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(p>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(p!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${c}`)}},ns=(c,p=1)=>{let g=Fh(c,p);return typeof g=="string"?g:g[0]},Es=(c,p=1)=>{let g=Fh(c,p);return typeof g=="string"?g:g[1]},It=(...c)=>{let p=[];return c.forEach(g=>{g.length!==0&&p.push({type:12,data:g},{type:12,data:Ae.computeStrides(g)})}),p},Sn=c=>c%4===0?4:c%2===0?2:1,Bg=(c="f32",p,g="0")=>!p||p===1?`${c}(${g})`:`vec${p}<${c}>(${g})`,Pl=(c,p,g)=>c==="f32"?g:p===1?`f32(${g})`:`vec${p}<f32>(${g})`,Ta=(c,p)=>p===4?`(${c}.x + ${c}.y + ${c}.z + ${c}.w)`:p===2?`(${c}.x + ${c}.y)`:p===3?`(${c}.x + ${c}.y + ${c}.z)`:c,pt=(c,p,g,b)=>c.startsWith("uniforms.")&&g>4?typeof p=="string"?b==="f16"?`${c}[(${p}) / 8][(${p}) % 8 / 4][(${p}) % 8 % 4]`:`${c}[(${p}) / 4][(${p}) % 4]`:b==="f16"?`${c}[${Math.floor(p/8)}][${Math.floor(p%8/4)}][${p%8%4}]`:`${c}[${Math.floor(p/4)}][${p%4}]`:g>1?`${c}[${p}]`:c,Xu=(c,p,g,b,x)=>{let S=typeof g=="number",A=S?g:g.length,$=[...new Array(A).keys()],D=A<2?"u32":A<=4?`vec${A}<u32>`:`array<u32, ${A}>`,k=Fh(p,x),O=typeof k=="string"?k:k[1],R=typeof k=="string"?k:k[0],V={indices:D,value:O,storage:R,tensor:p},F=Be=>typeof Be=="string"?Be:`${Be}u`,z={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},G=S?"uniforms.":"",X=`${G}${c}_shape`,K=`${G}${c}_strides`,q="";for(let Be=0;Be<A-1;Be++)q+=`
    let dim${Be} = current / ${pt(K,Be,A)};
    let rest${Be} = current % ${pt(K,Be,A)};
    indices[${Be}] = dim${Be};
    current = rest${Be};
    `;q+=`indices[${A-1}] = current;`;let te=A<2?"":`
  fn o2i_${c}(offset: u32) -> ${V.indices} {
    var indices: ${V.indices};
    var current = offset;
    ${q}
    return indices;
  }`,ee=Be=>(z.offsetToIndices=!0,A<2?Be:`o2i_${c}(${Be})`),re=[];if(A>=2)for(let Be=A-1;Be>=0;Be--)re.push(`${pt(K,Be,A)} * (indices[${Be}])`);let me=A<2?"":`
  fn i2o_${c}(indices: ${V.indices}) -> u32 {
    return ${re.join("+")};
  }`,Ne=Be=>(z.indicesToOffset=!0,A<2?Be:`i2o_${c}(${Be})`),Ve=(...Be)=>A===0?"0u":`${V.indices}(${Be.map(F).join(",")})`,Ke=(Be,tt)=>A<2?`${Be}`:`${pt(Be,tt,A)}`,lt=(Be,tt,sn)=>A<2?`${Be}=${sn};`:`${pt(Be,tt,A)}=${sn};`,_t={},Ot=(Be,tt)=>{z.broadcastedIndicesToOffset=!0;let sn=`${tt.name}broadcastedIndicesTo${c}Offset`;if(sn in _t)return`${sn}(${Be})`;let Vn=[];for(let Or=A-1;Or>=0;Or--){let X0=tt.indicesGet("outputIndices",Or+tt.rank-A);Vn.push(`${Ke(K,Or)} * (${X0} % ${Ke(X,Or)})`)}return _t[sn]=`fn ${sn}(outputIndices: ${tt.type.indices}) -> u32 {
             return ${Vn.length>0?Vn.join("+"):"0u"};
           }`,`${sn}(${Be})`},Tt=(Be,tt)=>(()=>{if(V.storage===V.value)return`${c}[${Be}]=${tt};`;if(V.storage==="vec2<u32>"&&V.value==="i32")return`${c}[${Be}]=vec2<u32>(u32(${tt}), select(0u, 0xFFFFFFFFu, ${tt} < 0));`;if(V.storage==="vec2<u32>"&&V.value==="u32")return`${c}[${Be}]=vec2<u32>(u32(${tt}), 0u);`;if(V.storage==="u32"&&V.value==="vec4<bool>")return`${c}[${Be}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${tt}));`;throw new Error(`not supported combination of storage type ${V.storage} and value type ${V.value} yet`)})(),kt=Be=>(()=>{if(V.storage===V.value)return`${c}[${Be}]`;if(V.storage==="vec2<u32>"&&V.value==="i32")return`i32(${c}[${Be}].x)`;if(V.storage==="vec2<u32>"&&V.value==="u32")return`u32(${c}[${Be}].x)`;if(V.storage==="u32"&&V.value==="vec4<bool>")return`vec4<bool>(bool(${c}[${Be}] & 0xFFu), bool(${c}[${Be}] & 0xFF00u), bool(${c}[${Be}] & 0xFF0000u), bool(${c}[${Be}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${V.storage} and value type ${V.value} yet`)})(),Wt=A<2?"":`
  fn get_${c}ByIndices(indices: ${V.indices}) -> ${O} {
    return ${kt(`i2o_${c}(indices)`)};
  }`,it=A<2?"":(()=>{let Be=$.map(sn=>`d${sn}: u32`).join(", "),tt=$.map(sn=>`d${sn}`).join(", ");return`
  fn get_${c}(${Be}) -> ${O} {
    return get_${c}ByIndices(${Ve(tt)});
  }`})(),en=(...Be)=>{if(Be.length!==A)throw new Error(`indices length must be ${A}`);let tt=Be.map(F).join(",");return A===0?kt("0u"):A===1?kt(tt[0]):(z.get=!0,z.getByIndices=!0,z.indicesToOffset=!0,`get_${c}(${tt})`)},In=Be=>A<2?kt(Be):(z.getByIndices=!0,z.indicesToOffset=!0,`get_${c}ByIndices(${Be})`),yt=A<2?"":`
  fn set_${c}ByIndices(indices: ${V.indices}, value: ${O}) {
    ${Tt(`i2o_${c}(indices)`,"value")}
  }`,hn=A<2?"":(()=>{let Be=$.map(sn=>`d${sn}: u32`).join(", "),tt=$.map(sn=>`d${sn}`).join(", ");return`
  fn set_${c}(${Be}, value: ${O}) {
    set_${c}ByIndices(${Ve(tt)}, value);
  }`})();return{impl:()=>{let Be=[],tt=!1;return z.offsetToIndices&&(Be.push(te),tt=!0),z.indicesToOffset&&(Be.push(me),tt=!0),z.broadcastedIndicesToOffset&&(Object.values(_t).forEach(sn=>Be.push(sn)),tt=!0),z.set&&(Be.push(hn),tt=!0),z.setByIndices&&(Be.push(yt),tt=!0),z.get&&(Be.push(it),tt=!0),z.getByIndices&&(Be.push(Wt),tt=!0),!S&&tt&&Be.unshift(`const ${X} = ${V.indices}(${g.join(",")});`,`const ${K} = ${V.indices}(${Ae.computeStrides(g).join(",")});`),Be.join(`
`)},type:V,offsetToIndices:ee,indicesToOffset:Ne,broadcastedIndicesToOffset:Ot,indices:Ve,indicesGet:Ke,indicesSet:lt,set:(...Be)=>{if(Be.length!==A+1)throw new Error(`indices length must be ${A}`);let tt=Be[A];if(typeof tt!="string")throw new Error("value must be string");let sn=Be.slice(0,A).map(F).join(",");return A===0?Tt("0u",tt):A===1?Tt(sn[0],tt):(z.set=!0,z.setByIndices=!0,z.indicesToOffset=!0,`set_${c}(${sn}, ${tt})`)},setByOffset:Tt,setByIndices:(Be,tt)=>A<2?Tt(Be,tt):(z.setByIndices=!0,z.indicesToOffset=!0,`set_${c}ByIndices(${Be}, ${tt});`),get:en,getByOffset:kt,getByIndices:In,usage:b,name:c,strides:K,shape:X,rank:A}},Ce=(c,p,g,b=1)=>Xu(c,p,g,"input",b),ht=(c,p,g,b=1)=>Xu(c,p,g,"output",b),yN=(c,p,g)=>Xu(c,p,g,"atomicOutput",1),Hg=(c,p,g,b=1)=>Xu(c,p,g,"internal",b),bN=class{constructor(c,p){this.normalizedDispatchGroup=c,this.limits=p,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(c){return`if (global_idx >= ${typeof c=="number"?`${c}u`:c}) { return; }`}mainStart(c=Vl){let p=typeof c=="number"?c:c[0],g=typeof c=="number"?1:c[1],b=typeof c=="number"?1:c[2];if(p>this.limits.maxComputeWorkgroupSizeX||g>this.limits.maxComputeWorkgroupSizeY||b>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${p}, ${g}, ${b}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(p*g*b>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${p}, ${g}, ${b}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let x=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,S=x?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,A=x?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${p*g*b}u + local_idx;`;return`@compute @workgroup_size(${p}, ${g}, ${b})
  fn main(${S}) {
    ${A}
  `}appendVariableUniforms(c){c.rank!==0&&(c.shape.startsWith("uniforms.")&&this.uniforms.push({name:c.shape.replace("uniforms.",""),type:"u32",length:c.rank}),c.strides.startsWith("uniforms.")&&this.uniforms.push({name:c.strides.replace("uniforms.",""),type:"u32",length:c.rank}))}declareVariable(c,p){if(c.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(c),this.appendVariableUniforms(c);let g=c.usage==="input"?"read":"read_write",b=c.usage==="atomicOutput"?"atomic<i32>":c.type.storage;return`@group(0) @binding(${p}) var<storage, ${g}> ${c.name}: array<${b}>;`}declareVariables(...c){return c.map(p=>this.declareVariable(p,this.variableIndex++)).join(`
`)}registerInternalVariable(c){if(c.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(c),this.appendVariableUniforms(c)}registerInternalVariables(...c){return c.forEach(p=>this.registerInternalVariable(p)),this}registerUniform(c,p,g=1){return this.uniforms.push({name:c,type:p,length:g}),this}registerUniforms(c){return this.uniforms=this.uniforms.concat(c),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let c=[];for(let{name:p,type:g,length:b}of this.uniforms)if(b&&b>4)g==="f16"?c.push(`@align(16) ${p}:array<mat2x4<${g}>, ${Math.ceil(b/8)}>`):c.push(`${p}:array<vec4<${g}>, ${Math.ceil(b/4)}>`);else{let x=b==null||b===1?g:`vec${b}<${g}>`;c.push(`${p}:${x}`)}return`
      struct Uniforms { ${c.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(c=>c.impl()).join(`
`)+this.internalVariables.map(c=>c.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let c=p=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(p)];return this.uniforms.map(p=>[c(p.type),p.length??1])}},xN=(c,p)=>new bN(c,p)}),NN,Ug,wN,AN,TN,SN,Nr,vN,$N,Sa=u(()=>{vt(),Et(),Cn(),Ct(),NN=(c,p)=>{if(!c||c.length!==1)throw new Error("Transpose requires 1 input.");if(p.length!==0&&p.length!==c[0].dims.length)throw new Error(`perm size ${p.length} does not match input rank ${c[0].dims.length}`)},Ug=(c,p)=>p.length!==0?p:[...new Array(c).keys()].reverse(),wN=(c,p)=>Ae.sortBasedOnPerm(c,Ug(c.length,p)),AN=(c,p,g,b)=>{let x=`fn perm(i: ${b.type.indices}) -> ${g.type.indices} {
    var a: ${g.type.indices};`;for(let S=0;S<p;++S)x+=`a[${c[S]}]=i[${S}];`;return x+="return a;}"},TN=(c,p)=>{let g=[],b=[];for(let x=0;x<c.length;++x)c[x]!==1&&g.push(c[x]),c[p[x]]!==1&&b.push(p[x]);return{newShape:g,newPerm:b}},SN=(c,p)=>{let g=0;for(let b=0;b<c.length;++b)if(p[c[b]]!==1){if(c[b]<g)return!1;g=c[b]}return!0},Nr=(c,p)=>{let g=c.dataType,b=c.dims.length,x=Ug(b,p),S=wN(c.dims,x),A=c.dims,$=S,D=b<2||SN(x,c.dims),k;if(D)return k=z=>{let G=Ce("input",g,A,4),X=ht("output",g,$,4);return`
  ${z.registerUniform("output_size","u32").declareVariables(G,X)}
  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let z=Ae.size(S);return{outputs:[{dims:S,dataType:c.dataType}],dispatchGroup:{x:Math.ceil(z/64/4)},programUniforms:[{type:12,data:Math.ceil(z/4)}]}},getShaderSource:k};let{newShape:O,newPerm:R}=TN(c.dims,x),V=Ae.areEqual(R,[2,3,1]),F=Ae.areEqual(R,[3,1,2]);if(O.length===2||V||F){A=V?[O[0],O[1]*O[2]]:F?[O[0]*O[1],O[2]]:O,$=[A[1],A[0]];let z=16;return k=G=>{let X=Ce("a",g,A.length),K=ht("output",g,$.length);return`
  ${G.registerUniform("output_size","u32").declareVariables(X,K)}
  var<workgroup> tile : array<array<${K.type.value}, ${z+1}>, ${z}>;
  ${G.mainStart([z,z,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${z} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${z}u + local_id.x;
    let input_row = workgroup_id_x * ${z}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${X.getByIndices(`${X.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${z}u + local_id.x;
    let output_row = workgroup_id_y * ${z}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${K.setByIndices(`${K.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let G=Ae.size(S);return{outputs:[{dims:S,dataType:c.dataType}],dispatchGroup:{x:Math.ceil($[1]/z),y:Math.ceil($[0]/z)},programUniforms:[{type:12,data:G},...It(A,$)]}},getShaderSource:k}}return k=z=>{let G=Ce("a",g,A.length),X=ht("output",g,$.length);return`
  ${z.registerUniform("output_size","u32").declareVariables(G,X)}

  ${AN(x,b,G,X)}

  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${X.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${X.setByOffset("global_idx",G.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${p}`,inputDependencies:["rank"]},getRunData:()=>{let z=Ae.size(S);return{outputs:[{dims:S,dataType:c.dataType}],dispatchGroup:{x:Math.ceil(z/64)},programUniforms:[{type:12,data:z},...It(A,$)]}},getShaderSource:k}},vN=(c,p)=>{NN(c.inputs,p.perm),c.compute(Nr(c.inputs[0],p.perm))},$N=c=>rn({perm:c.perm})}),_N,DN,EN,kN,CN,LN,ON,RN,VN,PN,si,FN,zN,MN,WN,BN,HN,UN,GN,qN,KN,rP=u(()=>{vt(),Et(),Ct(),qg(),Sa(),_N={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},DN={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},EN={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},kN={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},CN=(c,p)=>{let g=[];for(let b=p-c;b<p;++b)g.push(b);return g},LN=(c,p)=>{let g=[],b=c.length;for(let S=0;S<b;S++)p.indexOf(S)===-1&&g.push(c[S]);let x=p.map(S=>c[S]);return[g,x]},ON=(c,p)=>{let g=c.length+p.length,b=[],x=0;for(let S=0;S<g;S++)p.indexOf(S)===-1?b.push(c[x++]):b.push(1);return b},RN=(c,p)=>{for(let g=0;g<c.length;++g)if(c[c.length-g-1]!==p-1-g)return!1;return!0},VN=(c,p)=>{let g=[];if(!RN(c,p)){for(let b=0;b<p;++b)c.indexOf(b)===-1&&g.push(b);c.forEach(b=>g.push(b))}return g},PN=(c,p,g,b,x,S,A)=>{let $=g[0].dims,D=Ae.size(S),k=Ae.size(A),O=Ce("_A",g[0].dataType,$),R=ht("output",x,S),V=64;D===1&&(V=256);let F=`
          var<workgroup> aBestValues : array<f32, ${V}>;
       `,z=G=>`
        ${G.registerUniform("reduceSize","u32").declareVariables(O,R)}
        ${F}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${G.mainStart(V)}

          let outputIndex = global_idx / ${V};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${EN[b]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${V}) {
           let candidate = f32(${O.getByOffset("offset + k")});
           bestValue = ${_N[b]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${V}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${DN[b]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${R.setByOffset("outputIndex",`${b==="mean"?`${R.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${R.type.storage}(${kN[b]})`}`)};
         }
        }`;return{name:c,shaderCache:{hint:`${p};${V}`,inputDependencies:["type"]},getShaderSource:z,getRunData:()=>({outputs:[{dims:S,dataType:x}],dispatchGroup:{x:D},programUniforms:[{type:12,data:k}]})}},si=(c,p,g,b)=>{let x=c.inputs.length===1?g:Gg(c.inputs,g),S=x.axes;S.length===0&&!x.noopWithEmptyAxes&&(S=c.inputs[0].dims.map((F,z)=>z));let A=Ae.normalizeAxes(S,c.inputs[0].dims.length),$=A,D=c.inputs[0],k=VN($,c.inputs[0].dims.length);k.length>0&&(D=c.compute(Nr(c.inputs[0],k),{inputs:[0],outputs:[-1]})[0],$=CN($.length,D.dims.length));let[O,R]=LN(D.dims,$),V=O;x.keepDims&&(V=ON(O,A)),c.compute(PN(p,x.cacheKey,[D],b,c.inputs[0].dataType,V,R),{inputs:[D]})},FN=(c,p)=>{si(c,"ReduceMeanShared",p,"mean")},zN=(c,p)=>{si(c,"ReduceL1Shared",p,"l1")},MN=(c,p)=>{si(c,"ReduceL2Shared",p,"l2")},WN=(c,p)=>{si(c,"ReduceLogSumExpShared",p,"logSumExp")},BN=(c,p)=>{si(c,"ReduceMaxShared",p,"max")},HN=(c,p)=>{si(c,"ReduceMinShared",p,"min")},UN=(c,p)=>{si(c,"ReduceProdShared",p,"prod")},GN=(c,p)=>{si(c,"ReduceSumShared",p,"sum")},qN=(c,p)=>{si(c,"ReduceSumSquareShared",p,"sumSquare")},KN=(c,p)=>{si(c,"ReduceLogSumShared",p,"logSum")}}),ri,jN,zh,Gg,ii,YN,XN,ZN,QN,JN,ew,tw,nw,sw,rw,ai,iw,aw,ow,lw,uw,cw,dw,hw,pw,fw,qg=u(()=>{vt(),Et(),Cn(),Ct(),rP(),ri=c=>{if(!c||c.length===0||c.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(c.length===2&&c[1].dims.length!==1)throw new Error("Invalid axes input dims.")},jN=c=>["","",`var value = ${c.getByIndices("input_indices")};`,""],zh=(c,p,g,b,x,S,A=!1,$=!1)=>{let D=[],k=g[0].dims,O=k.length,R=Ae.normalizeAxes(x,O),V=!$&&R.length===0;k.forEach((G,X)=>{V||R.indexOf(X)>=0?A&&D.push(1):D.push(G)});let F=D.length,z=Ae.size(D);return{name:c,shaderCache:p,getShaderSource:G=>{let X=[],K=Ce("_A",g[0].dataType,O),q=ht("output",S,F),te=b(K,q,R),ee=te[2];for(let re=0,me=0;re<O;re++)V||R.indexOf(re)>=0?(A&&me++,ee=`for(var j${re}: u32 = 0; j${re} < ${k[re]}; j${re}++) {
                  ${te[2].includes("last_index")?`let last_index = j${re};`:""}
                  ${K.indicesSet("input_indices",re,`j${re}`)}
                  ${ee}
                }`):(X.push(`${K.indicesSet("input_indices",re,q.indicesGet("output_indices",me))};`),me++);return`

        ${G.registerUniform("output_size","u32").declareVariables(K,q)}

        ${G.mainStart()}
          ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${K.type.indices};
          let output_indices = ${q.offsetToIndices("global_idx")};

          ${X.join(`
`)}
          ${te[0]}       // init ops for reduce max/min
          ${te[1]}
          ${ee}
          ${te[3]}
          ${te.length===4?q.setByOffset("global_idx","value"):te.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:D,dataType:S}],dispatchGroup:{x:Math.ceil(z/64)},programUniforms:[{type:12,data:z},...It(k,D)]})}},Gg=(c,p)=>{let g=[];return c[1].dims[0]>0&&c[1].getBigInt64Array().forEach(b=>g.push(Number(b))),rn({axes:g,keepDims:p.keepDims,noopWithEmptyAxes:p.noopWithEmptyAxes})},ii=(c,p,g,b)=>{let x=c.inputs,S=x.length===1?g:Gg(x,g);c.compute(zh(p,{hint:S.cacheKey,inputDependencies:["rank"]},[x[0]],S.noopWithEmptyAxes&&S.axes.length===0?jN:b,S.axes,x[0].dataType,S.keepDims,S.noopWithEmptyAxes),{inputs:[0]})},YN=(c,p)=>{ri(c.inputs),ii(c,"ReduceLogSum",p,(g,b)=>[`var value = ${b.type.storage}(0);`,"",`value += ${g.getByIndices("input_indices")};`,"value = log(value);"])},XN=(c,p)=>{ri(c.inputs),ii(c,"ReduceL1",p,(g,b)=>[`var value = ${b.type.storage}(0);`,"",`value += abs(${g.getByIndices("input_indices")});`,""])},ZN=(c,p)=>{ri(c.inputs),ii(c,"ReduceL2",p,(g,b)=>[`var t = ${b.type.value}(0); var value = ${b.type.value}(0);`,"",`t = ${g.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},QN=(c,p)=>{ri(c.inputs),ii(c,"ReduceLogSumExp",p,(g,b)=>[`var value = ${b.type.storage}(0);`,"",`value += exp(${g.getByIndices("input_indices")});`,"value = log(value);"])},JN=(c,p)=>{ri(c.inputs),ii(c,"ReduceMax",p,(g,b,x)=>{let S=[];for(let A=0;A<g.rank;A++)(x.indexOf(A)>=0||x.length===0)&&S.push(g.indicesSet("input_indices",A,0));return[`${S.join(`
`)}`,`var value = ${g.getByIndices("input_indices")};`,`value = max(value, ${g.getByIndices("input_indices")});`,""]})},ew=(c,p)=>{ri(c.inputs),ii(c,"ReduceMean",p,(g,b,x)=>{let S=1;for(let A=0;A<g.rank;A++)(x.indexOf(A)>=0||x.length===0)&&(S*=c.inputs[0].dims[A]);return["var sum = f32(0);","",`sum += f32(${g.getByIndices("input_indices")});`,`let value = ${b.type.value}(sum / ${S});`]})},tw=(c,p)=>{ri(c.inputs),ii(c,"ReduceMin",p,(g,b,x)=>{let S=[];for(let A=0;A<g.rank;A++)(x.indexOf(A)>=0||x.length===0)&&S.push(`input_indices[${A}] = 0;`);return[`${S.join(`
`)}`,`var value = ${g.getByIndices("input_indices")};`,`value = min(value, ${g.getByIndices("input_indices")});`,""]})},nw=(c,p)=>{ri(c.inputs),ii(c,"ReduceProd",p,(g,b)=>[`var value = ${b.type.storage}(1);`,"",`value *= ${g.getByIndices("input_indices")};`,""])},sw=(c,p)=>{ri(c.inputs),ii(c,"ReduceSum",p,(g,b)=>[`var value = ${b.type.storage}(0);`,"",`value += ${g.getByIndices("input_indices")};`,""])},rw=(c,p)=>{ri(c.inputs),ii(c,"ReduceSumSquare",p,(g,b)=>[`var t = ${b.type.value}(0); var value = ${b.type.value}(0);`,"",`t = ${g.getByIndices("input_indices")}; value += t * t;`,""])},ai=(c,p,g)=>{if(p.length===0)return g;let b=1,x=1;for(let S=0;S<p.length;S++)p.indexOf(S)===-1?b*=c[S]:x*=c[S];return x<32&&b>1024},iw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?ew(c,p):FN(c,p)},aw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?XN(c,p):zN(c,p)},ow=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?ZN(c,p):MN(c,p)},lw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?QN(c,p):WN(c,p)},uw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?JN(c,p):BN(c,p)},cw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?tw(c,p):HN(c,p)},dw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?nw(c,p):UN(c,p)},hw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?sw(c,p):GN(c,p)},pw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?rw(c,p):qN(c,p)},fw=(c,p)=>{ai(c.inputs[0].dims,p.axes,p.noopWithEmptyAxes)?YN(c,p):KN(c,p)}}),Kg,mw,gw,jg,iP=u(()=>{vt(),Cn(),qg(),Kg=c=>{if(!c||c.length===0||c.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(c[0].dataType!==1)throw new Error("Invalid input type.")},mw=(c,p)=>{Kg(c.inputs);let g=(b,x,S)=>{let A=[];for(let $=0;$<b.rank;$++)(S.indexOf($)>=0||S.length===0)&&A.push(`input_indices[${$}] = 0;`);return[`${A.join(`
`)}`,`var value = ${b.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${b.getByIndices("input_indices")} ${p.selectLastIndex>0?"<=":"<"} value) {
         value = ${b.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",x.setByOffset("global_idx","best_index")]};c.compute(zh("ArgMin",{hint:p.cacheKey,inputDependencies:["rank"]},[c.inputs[0]],g,[p.axis],7,p.keepDims),{inputs:[0]})},gw=(c,p)=>{Kg(c.inputs);let g=(b,x,S)=>{let A=[];for(let $=0;$<b.rank;$++)(S.indexOf($)>=0||S.length===0)&&A.push(`input_indices[${$}] = 0;`);return[`${A.join(`
`)}`,`var value = ${b.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${b.getByIndices("input_indices")} ${p.selectLastIndex>0?">=":">"} value) {
         value = ${b.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",x.setByOffset("global_idx","best_index")]};c.compute(zh("argMax",{hint:p.cacheKey,inputDependencies:["rank"]},[c.inputs[0]],g,[p.axis],7,p.keepDims),{inputs:[0]})},jg=c=>rn(c)}),Iw,Mh,yw,bw,xw,Zu,Nw,ww,Yg=u(()=>{vt(),Et(),Fg(),Ct(),Iw=(c,p)=>{let g=c[0],b=c[1],x=c[2],S=c[3],A=c[4],$=c[5];if(A&&$)throw new Error("Attention cannot have both past and attention_bias");if(g.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let D=g.dims[0],k=g.dims[1],O=g.dims[2];if(x.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(b.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(b.dims[0]!==O)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(x.dims[0]!==b.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let R=x.dims[0]/3,V=R,F=V;if(p.qkvHiddenSizes.length>0){if(p.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let te of p.qkvHiddenSizes)if(te%p.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");R=p.qkvHiddenSizes[0],V=p.qkvHiddenSizes[1],F=p.qkvHiddenSizes[2]}let z=k;if(R!==V)throw new Error("qkv_hidden_sizes first element should be same as the second");if(x.dims[0]!==R+V+F)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let G=0;if(A){if(V!==F)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(A.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(A.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(A.dims[1]!==D)throw new Error('Input "past" second dimension must be batch_size');if(A.dims[2]!==p.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(A.dims[4]!==V/p.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');p.pastPresentShareBuffer||(G=A.dims[3])}let X=z+G,K=-1,q=0;if(S)throw new Error("Mask not supported");if(A)throw new Error("past is not supported");if($){if($.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if($.dims[0]!==D||$.dims[1]!==p.numHeads||$.dims[2]!==k||$.dims[3]!==X)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:D,sequenceLength:k,pastSequenceLength:G,kvSequenceLength:z,totalSequenceLength:X,maxSequenceLength:K,inputHiddenSize:O,hiddenSize:R,vHiddenSize:F,headSize:Math.floor(R/p.numHeads),vHeadSize:Math.floor(F/p.numHeads),numHeads:p.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:p.maskFilterValue,maskType:q,scale:p.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Mh=(c,p,g)=>p&&c?`
      let total_sequence_length_input = u32(${p.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${c==null?void 0:c.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${g?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,yw=(c,p,g,b,x,S,A,$)=>{let D=Sn(A?1:S),k=64,O=S/D;O<k&&(k=32);let R=Math.ceil(S/D/k),V=[{type:12,data:p},{type:12,data:g},{type:12,data:b},{type:12,data:x},{type:12,data:O},{type:12,data:R}],F=ns(c.dataType,D),z=Es(1,D),G=["type"];A&&G.push("type"),$&&G.push("type");let X=K=>{let q=ht("x",c.dataType,c.dims,D),te=[q],ee=A?Ce("seq_lens",A.dataType,A.dims):void 0;ee&&te.push(ee);let re=$?Ce("total_sequence_length_input",$.dataType,$.dims):void 0;re&&te.push(re);let me=Es(c.dataType),Ne=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${k}>;
  var<workgroup> thread_sum: array<f32, ${k}>;
  ${K.registerUniforms(Ne).declareVariables(...te)}
  ${K.mainStart([k,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${Mh(ee,re,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${k}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${A?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${z}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${z}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(D){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${D}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${k}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${z}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${z}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(D){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${D}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${k}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${q.type.value}(${me}(1.0) / ${me}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${z}(x[offset + i]);
        x[offset + i] = ${q.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${A?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${q.type.value}(${me}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${k};${F};${D}`,inputDependencies:G},getShaderSource:X,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(S/k),y:x,z:p*g},programUniforms:V})}},bw=(c,p,g,b,x,S,A,$,D)=>{let k=A+S.kvSequenceLength,O=[S.batchSize,S.numHeads,S.sequenceLength,k],R=c>1&&b,V=S.kvNumHeads?S.kvNumHeads:S.numHeads,F=R?[S.batchSize,V,k,S.headSize]:void 0,z=S.nReps?S.nReps:1,G=S.scale===0?1/Math.sqrt(S.headSize):S.scale,X=Sn(S.headSize),K=S.headSize/X,q=12,te={x:Math.ceil(k/q),y:Math.ceil(S.sequenceLength/q),z:S.batchSize*S.numHeads},ee=[{type:12,data:S.sequenceLength},{type:12,data:K},{type:12,data:k},{type:12,data:S.numHeads},{type:12,data:S.headSize},{type:1,data:G},{type:12,data:A},{type:12,data:S.kvSequenceLength},{type:12,data:z}],re=R&&b&&Ae.size(b.dims)>0,me=["type","type"];re&&me.push("type"),x&&me.push("type"),$&&me.push("type"),D&&me.push("type");let Ne=[{dims:O,dataType:p.dataType,gpuDataType:0}];R&&Ne.push({dims:F,dataType:p.dataType,gpuDataType:0});let Ve=Ke=>{let lt=Ce("q",p.dataType,p.dims,X),_t=Ce("key",g.dataType,g.dims,X),Ot=[lt,_t];if(re){let yt=Ce("past_key",b.dataType,b.dims,X);Ot.push(yt)}x&&Ot.push(Ce("attention_bias",x.dataType,x.dims));let Tt=$?Ce("seq_lens",$.dataType,$.dims):void 0;Tt&&Ot.push(Tt);let kt=D?Ce("total_sequence_length_input",D.dataType,D.dims):void 0;kt&&Ot.push(kt);let Wt=ht("output",p.dataType,O),it=[Wt];R&&it.push(ht("present_key",p.dataType,F,X));let en=Es(1,X),In=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${q}u;

  var<workgroup> tileQ: array<${lt.type.storage}, ${q*q}>;
  var<workgroup> tileK: array<${lt.type.storage}, ${q*q}>;
  ${Ke.registerUniforms(In).declareVariables(...Ot,...it)}
  ${Ke.mainStart([q,q,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${z===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${z===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${Mh(Tt,kt,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${re&&R?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${R?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${en}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${re&&R?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${R?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${en}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(X){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${X}`)}})()};
        output[outputIdx] = ${Wt.type.value} (sum * uniforms.alpha) + ${x?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${X};${x!==void 0};${b!==void 0};${c}`,inputDependencies:me},getRunData:()=>({outputs:Ne,dispatchGroup:te,programUniforms:ee}),getShaderSource:Ve}},xw=(c,p,g,b,x,S,A=void 0,$=void 0)=>{let D=S+x.kvSequenceLength,k=x.nReps?x.nReps:1,O=x.vHiddenSize*k,R=c>1&&b,V=x.kvNumHeads?x.kvNumHeads:x.numHeads,F=R?[x.batchSize,V,D,x.headSize]:void 0,z=[x.batchSize,x.sequenceLength,O],G=12,X={x:Math.ceil(x.vHeadSize/G),y:Math.ceil(x.sequenceLength/G),z:x.batchSize*x.numHeads},K=[{type:12,data:x.sequenceLength},{type:12,data:D},{type:12,data:x.vHeadSize},{type:12,data:x.numHeads},{type:12,data:x.headSize},{type:12,data:O},{type:12,data:S},{type:12,data:x.kvSequenceLength},{type:12,data:k}],q=R&&b&&Ae.size(b.dims)>0,te=["type","type"];q&&te.push("type"),A&&te.push("type"),$&&te.push("type");let ee=[{dims:z,dataType:p.dataType,gpuDataType:0}];R&&ee.push({dims:F,dataType:p.dataType,gpuDataType:0});let re=me=>{let Ne=Ce("probs",p.dataType,p.dims),Ve=Ce("v",g.dataType,g.dims),Ke=[Ne,Ve];q&&Ke.push(Ce("past_value",b.dataType,b.dims));let lt=A?Ce("seq_lens",A.dataType,A.dims):void 0;A&&Ke.push(lt);let _t=$?Ce("total_sequence_length_input",$.dataType,$.dims):void 0;$&&Ke.push(_t);let Ot=[ht("output",p.dataType,z)];R&&Ot.push(ht("present_value",p.dataType,F));let Tt=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${G}u;
  var<workgroup> tileQ: array<${Ne.type.value}, ${G*G}>;
  var<workgroup> tileV: array<${Ne.type.value}, ${G*G}>;
  ${me.registerUniforms(Tt).declareVariables(...Ke,...Ot)}
  ${me.mainStart([G,G,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${k===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${k===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${Mh(lt,_t,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${q&&R?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${R?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${Ne.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${q&&R?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${R?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${b!==void 0};${c}`,inputDependencies:te},getRunData:()=>({outputs:ee,dispatchGroup:X,programUniforms:K}),getShaderSource:re}},Zu=(c,p,g,b,x,S,A,$,D,k,O=void 0,R=void 0)=>{let V=Math.min(c.outputCount,1+(A?1:0)+($?1:0)),F=V>1?k.pastSequenceLength:0,z=F+k.kvSequenceLength,G=D&&Ae.size(D.dims)>0?D:void 0,X=[p,g];V>1&&A&&Ae.size(A.dims)>0&&X.push(A),G&&X.push(G),O&&X.push(O),R&&X.push(R);let K=c.compute(bw(V,p,g,A,G,k,F,O,R),{inputs:X,outputs:V>1?[-1,1]:[-1]})[0];c.compute(yw(K,k.batchSize,k.numHeads,F,k.sequenceLength,z,O,R),{inputs:O&&R?[K,O,R]:[K],outputs:[]});let q=[K,b];V>1&&$&&Ae.size($.dims)>0&&q.push($),O&&q.push(O),R&&q.push(R),c.compute(xw(V,K,b,$,k,F,O,R),{inputs:q,outputs:V>1?[0,2]:[0]})},Nw=(c,p)=>{let g=[p.batchSize,p.numHeads,p.sequenceLength,p.headSize],b=p.sequenceLength,x=p.inputHiddenSize,S=p.headSize,A=12,$={x:Math.ceil(p.headSize/A),y:Math.ceil(p.sequenceLength/A),z:p.batchSize*p.numHeads},D=[c.inputs[0],c.inputs[1],c.inputs[2]],k=[{type:12,data:b},{type:12,data:x},{type:12,data:S},{type:12,data:p.numHeads},{type:12,data:p.headSize},{type:12,data:p.hiddenSize},{type:12,data:p.hiddenSize+p.hiddenSize+p.vHiddenSize}],O=R=>{let V=ht("output_q",D[0].dataType,g),F=ht("output_k",D[0].dataType,g),z=ht("output_v",D[0].dataType,g),G=Ce("input",D[0].dataType,D[0].dims),X=Ce("weight",D[1].dataType,D[1].dims),K=Ce("bias",D[2].dataType,D[2].dims),q=G.type.storage,te=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${A}u;
  var<workgroup> tileInput: array<${q}, ${A*A}>;
  var<workgroup> tileWeightQ: array<${q}, ${A*A}>;
  var<workgroup> tileWeightK: array<${q}, ${A*A}>;
  var<workgroup> tileWeightV: array<${q}, ${A*A}>;
  ${R.registerUniforms(te).declareVariables(G,X,K,V,F,z)}
  ${R.mainStart([A,A,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${q}(0);
    var valueK = ${q}(0);
    var valueV = ${q}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return c.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:g,dataType:c.inputs[0].dataType,gpuDataType:0},{dims:g,dataType:c.inputs[0].dataType,gpuDataType:0},{dims:g,dataType:c.inputs[0].dataType,gpuDataType:0}],dispatchGroup:$,programUniforms:k}),getShaderSource:O},{inputs:D,outputs:[-1,-1,-1]})},ww=(c,p)=>{let g=Iw(c.inputs,p),[b,x,S]=Nw(c,g);return Zu(c,b,x,S,c.inputs[4],void 0,void 0,void 0,c.inputs[5],g)}}),Aw,Tw,Sw,vw,aP=u(()=>{dt(),vt(),Et(),Cn(),Ct(),Aw=(c,p)=>{if(!c||c.length!==5)throw new Error("BatchNormalization requires 5 inputs");let g=(b,x,S)=>{let A=x.length;if(A!==b.length)throw new Error(`${S}: num dimensions != ${A}`);x.forEach(($,D)=>{if($!==b[D])throw new Error(`${S}: dim[${D}] do not match`)})};if(c[0].dims.length>1){let b=p.format==="NHWC"?p.spatial?c[0].dims.slice(-1):c[0].dims.slice(-1).concat(c[0].dims.slice(1,c[0].dims.length-1)):c[0].dims.slice(1,p.spatial?2:void 0);g(c[1].dims,b,"Invalid input scale"),g(c[2].dims,b,"Invalid input B"),g(c[3].dims,b,"Invalid input mean"),g(c[4].dims,b,"Invalid input var")}else g(c[1].dims,[1],"Invalid input scale"),g(c[2].dims,[1],"Invalid input B"),g(c[3].dims,[1],"Invalid input mean"),g(c[4].dims,[1],"Invalid input var")},Tw=(c,p)=>{let{epsilon:g,spatial:b,format:x}=p,S=c[0].dims,A=b?Sn(S[S.length-1]):1,$=x==="NHWC"&&S.length>1?A:1,D=Ae.size(S)/A,k=b,O=k?S.length:S,R=Ce("x",c[0].dataType,c[0].dims,A),V=Ce("scale",c[1].dataType,c[1].dims,$),F=Ce("bias",c[2].dataType,c[2].dims,$),z=Ce("inputMean",c[3].dataType,c[3].dims,$),G=Ce("inputVar",c[4].dataType,c[4].dims,$),X=ht("y",c[0].dataType,O,A),K=()=>{let te="";if(b)te=`let cOffset = ${S.length===1?"0u":x==="NHWC"?`outputIndices[${S.length-1}] / ${A}`:"outputIndices[1]"};`;else if(x==="NCHW")te=`
            ${X.indicesSet("outputIndices","0","0")}
            let cOffset = ${X.indicesToOffset("outputIndices")};`;else{te=`var cIndices = ${V.type.indices}(0);
                       cIndices[0] = outputIndices[${S.length-1}];`;for(let ee=1;ee<V.rank;ee++)te+=`cIndices[${ee}] = outputIndices[${ee}];`;te+=`let cOffset = ${V.indicesToOffset("cIndices")};`}return te},q=te=>`
  const epsilon = ${g};
  ${te.registerUniform("outputSize","u32").declareVariables(R,V,F,z,G,X)}
  ${te.mainStart()}
  ${te.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${X.offsetToIndices(`global_idx * ${A}`)};
    ${K()}
    let scale = ${V.getByOffset("cOffset")};
    let bias = ${F.getByOffset("cOffset")};
    let inputMean = ${z.getByOffset("cOffset")};
    let inputVar = ${G.getByOffset("cOffset")};
    let x = ${R.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${X.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${p.epsilon}_${p.format}_${b}_${A}`,inputDependencies:k?["rank","type","type","type","type"]:void 0},getShaderSource:q,getRunData:()=>({outputs:[{dims:c[0].dims,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(D/64)},programUniforms:k?[{type:12,data:D},...It(S)]:[{type:12,data:D}]})}},Sw=c=>rn(c),vw=(c,p)=>{let{inputs:g,outputCount:b}=c,x=Sw({...p,outputCount:b});if(U.webgpu.validateInputContent&&Aw(g,x),p.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");c.compute(Tw(g,x))}}),$w,_w,Dw,oP=u(()=>{Et(),Ct(),$w=c=>{if(c[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(c[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(c[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(c[0].dims[2]!==c[1].dims[0])throw new Error("last dimension of input and bias are not the same")},_w=c=>{let p=c[0].dims,g=c[0].dims[2],b=Ae.size(p)/4,x=c[0].dataType,S=Ce("input",x,p,4),A=Ce("bias",x,[g],4),$=Ce("residual",x,p,4),D=ht("output",x,p,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:p,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:k=>`
  const channels = ${g}u / 4;
  ${k.declareVariables(S,A,$,D)}

  ${k.mainStart()}
    ${k.guardAgainstOutOfBoundsWorkgroupSizes(b)}
    let value = ${S.getByOffset("global_idx")}
      + ${A.getByOffset("global_idx % channels")} + ${$.getByOffset("global_idx")};
    ${D.setByOffset("global_idx","value")}
  }`}},Dw=c=>{$w(c.inputs),c.compute(_w(c.inputs))}}),Ew,Jt,kw,Cw,Lw,Ow,Rw,Vw,Pw,Fw,zw,Mw,Ww,Bw,Hw,Uw,Qu,Gw,Wh,qw,Kw,jw,Yw,Xw,Zw,Qw,Jw,eA,tA,nA,sA,rA,iA,aA,oA,Xg,lA,Zg,Qg,uA,cA,dA,hA,pA,fA,Jg=u(()=>{vt(),Et(),Cn(),Ct(),Ew=(c,p,g,b,x,S,A)=>{let $=Math.ceil(p/4),D="";typeof x=="string"?D=`${x}(a)`:D=x("a");let k=Ce("inputData",g,[$],4),O=ht("outputData",b,[$],4),R=[{name:"vec_size",type:"u32"}];return A&&R.push(...A),`
      ${c.registerUniforms(R).declareVariables(k,O)}

  ${S??""}

  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${k.getByOffset("global_idx")};
    ${O.setByOffset("global_idx",D)}
  }`},Jt=(c,p,g,b,x,S=c.dataType,A,$)=>{let D=[{type:12,data:Math.ceil(Ae.size(c.dims)/4)}];return A&&D.push(...A),{name:p,shaderCache:{hint:x,inputDependencies:["type"]},getShaderSource:k=>Ew(k,Ae.size(c.dims),c.dataType,S,g,b,$),getRunData:k=>({outputs:[{dims:c.dims,dataType:S}],dispatchGroup:{x:Math.ceil(Ae.size(k[0].dims)/64/4)},programUniforms:D})}},kw=c=>{c.compute(Jt(c.inputs[0],"Abs","abs"))},Cw=c=>{c.compute(Jt(c.inputs[0],"Acos","acos"))},Lw=c=>{c.compute(Jt(c.inputs[0],"Acosh","acosh"))},Ow=c=>{c.compute(Jt(c.inputs[0],"Asin","asin"))},Rw=c=>{c.compute(Jt(c.inputs[0],"Asinh","asinh"))},Vw=c=>{c.compute(Jt(c.inputs[0],"Atan","atan"))},Pw=c=>{c.compute(Jt(c.inputs[0],"Atanh","atanh"))},Fw=c=>rn(c),zw=(c,p)=>{let g;switch(p.to){case 10:g="vec4<f16>";break;case 1:g="vec4<f32>";break;case 12:g="vec4<u32>";break;case 6:g="vec4<i32>";break;case 9:g="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${p.to}`)}c.compute(Jt(c.inputs[0],"Cast",g,void 0,p.cacheKey,p.to))},Mw=c=>{let p,g,b=c.length>=2&&c[1].data!==0,x=c.length>=3&&c[2].data!==0;switch(c[0].dataType){case 1:p=b?c[1].getFloat32Array()[0]:-34028234663852886e22,g=x?c[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:p=b?c[1].getUint16Array()[0]:64511,g=x?c[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return rn({min:p,max:g})},Ww=(c,p)=>{let g=p||Mw(c.inputs),b=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"Clip",x=>`clamp(${x}, vec4<${b}>(uniforms.min), vec4<${b}>(uniforms.max))`,void 0,g.cacheKey,void 0,[{type:c.inputs[0].dataType,data:g.min},{type:c.inputs[0].dataType,data:g.max}],[{name:"min",type:b},{name:"max",type:b}]),{inputs:[0]})},Bw=c=>{c.compute(Jt(c.inputs[0],"Ceil","ceil"))},Hw=c=>{c.compute(Jt(c.inputs[0],"Cos","cos"))},Uw=c=>{c.compute(Jt(c.inputs[0],"Cosh","cosh"))},Qu=c=>rn(c),Gw=(c,p)=>{let g=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"Elu",b=>`elu_vf32(${b})`,`
  const elu_alpha_ = ${g}(${p.alpha});

  fn elu_f32(a: ${g}) -> ${g} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${g}>) -> vec4<${g}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,p.cacheKey))},Wh=(c="f32")=>`
const r0: ${c} = 0.3275911;
const r1: ${c} = 0.254829592;
const r2: ${c} = -0.284496736;
const r3: ${c} = 1.421413741;
const r4: ${c} = -1.453152027;
const r5: ${c} = 1.061405429;

fn erf_vf32(v: vec4<${c}>) -> vec4<${c}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,qw=c=>{let p=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"Erf",g=>`erf_vf32(${g})`,Wh(p)))},Kw=c=>{c.compute(Jt(c.inputs[0],"Exp","exp"))},jw=c=>{c.compute(Jt(c.inputs[0],"Floor","floor"))},Yw=c=>{let p=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"Gelu",g=>`0.5 * ${g} * (1.0 + erf_vf32(${g} * 0.7071067811865475))`,Wh(p)))},Xw=(c,p)=>{let g=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"LeakyRelu",b=>`select(leaky_relu_alpha_ * ${b}, ${b}, ${b} >= vec4<${g}>(0.0))`,`const leaky_relu_alpha_ = ${g}(${p.alpha});`,p.cacheKey))},Zw=c=>{c.compute(Jt(c.inputs[0],"Not",p=>`!${p}`))},Qw=c=>{c.compute(Jt(c.inputs[0],"Neg",p=>`-${p}`))},Jw=c=>{c.compute(Jt(c.inputs[0],"Reciprocal",p=>`1.0/${p}`))},eA=c=>{let p=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"Relu",g=>`select(vec4<${p}>(0.0), ${g}, ${g} > vec4<${p}>(0.0))`))},tA=c=>{c.compute(Jt(c.inputs[0],"Sigmoid",p=>`(1.0 / (1.0 + exp(-${p})))`))},nA=c=>rn(c),sA=(c,p)=>{let g=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"HardSigmoid",b=>`max(vec4<${g}>(0.0), min(vec4<${g}>(1.0), ${p.alpha} * ${b} + vec4<${g}>(${p.beta})))`,void 0,p.cacheKey))},rA=c=>{c.compute(Jt(c.inputs[0],"Sin","sin"))},iA=c=>{c.compute(Jt(c.inputs[0],"Sinh","sinh"))},aA=c=>{c.compute(Jt(c.inputs[0],"Sqrt","sqrt"))},oA=c=>{c.compute(Jt(c.inputs[0],"Tan","tan"))},Xg=c=>`sign(${c}) * (1 - exp(-2 * abs(${c}))) / (1 + exp(-2 * abs(${c})))`,lA=c=>{c.compute(Jt(c.inputs[0],"Tanh",Xg))},Zg=(c="f32")=>`
const fast_gelu_a: ${c} = 0.5;
const fast_gelu_b: ${c} = 0.7978845608028654;
const fast_gelu_c: ${c} = 0.035677408136300125;

fn tanh_v(v: vec4<${c}>) -> vec4<${c}> {
  return ${Xg("v")};
}
`,Qg=c=>`(fast_gelu_a + fast_gelu_a * tanh_v(${c} * (fast_gelu_c * ${c} * ${c} + fast_gelu_b))) * ${c}`,uA=c=>{let p=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"FastGelu",Qg,Zg(p),void 0,c.inputs[0].dataType))},cA=(c,p)=>{let g=Es(c.inputs[0].dataType);return c.compute(Jt(c.inputs[0],"ThresholdedRelu",b=>`select(vec4<${g}>(0.0), ${b}, ${b} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${g}>(${p.alpha});`,p.cacheKey)),0},dA=c=>{c.compute(Jt(c.inputs[0],"Log","log"))},hA=(c,p)=>`
const alpha = vec4<${c}>(${p});
const one = ${c}(1.0);
const zero = ${c}(0.0);

fn quick_gelu_impl(x: vec4<${c}>) -> vec4<${c}> {
  let v = x *alpha;
  var x1 : vec4<${c}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,pA=c=>`quick_gelu_impl(${c})`,fA=(c,p)=>{let g=Es(c.inputs[0].dataType);c.compute(Jt(c.inputs[0],"QuickGelu",pA,hA(g,p.alpha),p.cacheKey,c.inputs[0].dataType))}}),mA,gA,IA,lP=u(()=>{Et(),Ct(),Jg(),mA=c=>{if(c[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(c[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(c[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(c[0].dims[2]!==c[1].dims[0])throw new Error("last dimension of input and bias are not the same")},gA=c=>{let p=c[0].dims.slice();p[2]=p[2]/2;let g=Ce("input",c[0].dataType,c[0].dims,4),b=Ce("bias",c[0].dataType,[c[0].dims[2]],4),x=ht("output",c[0].dataType,p,4),S=Ae.size(p)/4,A=ns(c[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:p,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)}}),getShaderSource:$=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${c[0].dims[2]/4/2}u;

  ${$.declareVariables(g,b,x)}

  ${Wh(A)}

  ${$.mainStart()}
    ${$.guardAgainstOutOfBoundsWorkgroupSizes(S)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${x.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},IA=c=>{mA(c.inputs),c.compute(gA(c.inputs))}}),yA,bA,oi,xA,NA,wA,AA,TA,SA,vA,$A,_A,DA,uP=u(()=>{vt(),Et(),Ct(),yA=(c,p,g,b,x,S,A,$,D,k,O,R)=>{let V,F;typeof $=="string"?V=F=(q,te)=>`${$}((${q}),(${te}))`:typeof $=="function"?V=F=$:(V=$.scalar,F=$.vector);let z=ht("outputData",O,b.length,4),G=Ce("aData",D,p.length,4),X=Ce("bData",k,g.length,4),K;if(x)if(S){let q=Ae.size(p)===1,te=Ae.size(g)===1,ee=p.length>0&&p[p.length-1]%4===0,re=g.length>0&&g[g.length-1]%4===0;q||te?K=z.setByOffset("global_idx",F(q?`${G.type.value}(${G.getByOffset("0")}.x)`:G.getByOffset("global_idx"),te?`${X.type.value}(${X.getByOffset("0")}.x)`:X.getByOffset("global_idx"))):K=`
            let outputIndices = ${z.offsetToIndices("global_idx * 4u")};
            let offsetA = ${G.broadcastedIndicesToOffset("outputIndices",z)};
            let offsetB = ${X.broadcastedIndicesToOffset("outputIndices",z)};
            ${z.setByOffset("global_idx",F(A||ee?G.getByOffset("offsetA / 4u"):`${G.type.value}(${G.getByOffset("offsetA / 4u")}[offsetA % 4u])`,A||re?X.getByOffset("offsetB / 4u"):`${X.type.value}(${X.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else K=z.setByOffset("global_idx",F(G.getByOffset("global_idx"),X.getByOffset("global_idx")));else{if(!S)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let q=(te,ee,re="")=>{let me=`aData[indexA${ee}][componentA${ee}]`,Ne=`bData[indexB${ee}][componentB${ee}]`;return`
            let outputIndices${ee} = ${z.offsetToIndices(`global_idx * 4u + ${ee}u`)};
            let offsetA${ee} = ${G.broadcastedIndicesToOffset(`outputIndices${ee}`,z)};
            let offsetB${ee} = ${X.broadcastedIndicesToOffset(`outputIndices${ee}`,z)};
            let indexA${ee} = offsetA${ee} / 4u;
            let indexB${ee} = offsetB${ee} / 4u;
            let componentA${ee} = offsetA${ee} % 4u;
            let componentB${ee} = offsetB${ee} % 4u;
            ${te}[${ee}] = ${re}(${V(me,Ne)});
          `};O===9?K=`
            var data = vec4<u32>(0);
            ${q("data",0,"u32")}
            ${q("data",1,"u32")}
            ${q("data",2,"u32")}
            ${q("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:K=`
            ${q("outputData[global_idx]",0)}
            ${q("outputData[global_idx]",1)}
            ${q("outputData[global_idx]",2)}
            ${q("outputData[global_idx]",3)}
          `}return`
        ${c.registerUniform("vec_size","u32").declareVariables(G,X,z)}

        ${R??""}

        ${c.mainStart()}
        ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${K}
      }`},bA=(c,p,g,b,x,S,A=g.dataType)=>{let $=g.dims.map(G=>Number(G)??1),D=b.dims.map(G=>Number(G)??1),k=!Ae.areEqual($,D),O=$,R=Ae.size($),V=!1,F=!1,z=[k];if(k){let G=Rl.calcShape($,D,!1);if(!G)throw new Error("Can't perform binary op on the given tensors");O=G.slice(),R=Ae.size(O);let X=Ae.size($)===1,K=Ae.size(D)===1,q=$.length>0&&$[$.length-1]%4===0,te=D.length>0&&D[D.length-1]%4===0;z.push(X),z.push(K),z.push(q),z.push(te);let ee=1;for(let re=1;re<O.length;re++){let me=$[$.length-re],Ne=D[D.length-re];if(me===Ne)ee*=me;else break}ee%4===0?(F=!0,V=!0):(X||K||q||te)&&(V=!0)}else V=!0;return z.push(V),{name:c,shaderCache:{hint:p+z.map(G=>G.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:G=>yA(G,$,D,O,V,k,F,x,g.dataType,b.dataType,A,S),getRunData:()=>({outputs:[{dims:O,dataType:A}],dispatchGroup:{x:Math.ceil(R/64/4)},programUniforms:[{type:12,data:Math.ceil(Ae.size(O)/4)},...It($,D,O)]})}},oi=(c,p,g,b,x,S)=>{c.compute(bA(p,x??"",c.inputs[0],c.inputs[1],g,b,S))},xA=c=>{oi(c,"Add",(p,g)=>`${p}+${g}`)},NA=c=>{oi(c,"Div",(p,g)=>`${p}/${g}`)},wA=c=>{oi(c,"Equal",{scalar:(p,g)=>`u32(${p}==${g})`,vector:(p,g)=>`vec4<u32>(${p}==${g})`},void 0,void 0,9)},AA=c=>{oi(c,"Mul",(p,g)=>`${p}*${g}`)},TA=c=>{let p=Ce("input",c.inputs[0].dataType,c.inputs[0].dims).type.value;oi(c,"Pow",{scalar:(g,b)=>`pow_custom(${g},${b})`,vector:(g,b)=>`pow_vector_custom(${g},${b})`},`
    fn pow_custom(a : ${p}, b : ${p}) -> ${p} {
      if (b == ${p}(0.0)) {
        return ${p}(1.0);
      } else if (a < ${p}(0.0) && f32(b) != floor(f32(b))) {
        return ${p}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${p}(1.0), round(f32(abs(b) % ${p}(2.0))) != 1.0) * ${p}(${p==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${p}>, b : vec4<${p}>) -> vec4<${p}> {
      // TODO: implement vectorized pow
      return vec4<${p}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},SA=c=>{oi(c,"Sub",(p,g)=>`${p}-${g}`)},vA=c=>{oi(c,"Greater",{scalar:(p,g)=>`u32(${p}>${g})`,vector:(p,g)=>`vec4<u32>(${p}>${g})`},void 0,void 0,9)},$A=c=>{oi(c,"Less",{scalar:(p,g)=>`u32(${p}<${g})`,vector:(p,g)=>`vec4<u32>(${p}<${g})`},void 0,void 0,9)},_A=c=>{oi(c,"GreaterOrEqual",{scalar:(p,g)=>`u32(${p}>=${g})`,vector:(p,g)=>`vec4<u32>(${p}>=${g})`},void 0,void 0,9)},DA=c=>{oi(c,"LessOrEqual",{scalar:(p,g)=>`u32(${p}<=${g})`,vector:(p,g)=>`vec4<u32>(${p}<=${g})`},void 0,void 0,9)}}),EA,kA,CA,LA,OA,RA,cP=u(()=>{vt(),Et(),Cn(),Ct(),EA=(c,p)=>{if(!c||c.length<1)throw new Error("too few inputs");let g=0,b=c[g],x=b.dataType,S=b.dims.length;c.forEach((A,$)=>{if($!==g){if(A.dataType!==x)throw new Error("input tensors should be one type");if(A.dims.length!==S)throw new Error("input tensors should have the same shape");A.dims.forEach((D,k)=>{if(k!==p&&D!==b.dims[k])throw new Error("non concat dimensions must match")})}})},kA=(c,p)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${c}u>(${p});
    for (var i: u32 = 0u; i < ${c}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${c}u;
  }`,CA=(c,p)=>{let g=c.length,b=[];for(let x=0;x<g;++x){let S=p.setByOffset("global_idx",c[x].getByIndices("indices"));g===1?b.push(S):x===0?b.push(`if (inputIndex == ${x}u) { ${S} }`):x===g-1?b.push(`else { ${S} }`):b.push(`else if (inputIndex == ${x}) { ${S} }`)}return b.join(`
`)},LA=(c,p,g,b)=>{let x=Ae.size(g),S=new Array(c.length),A=new Array(c.length),$=0,D=[],k=[],O=[{type:12,data:x}];for(let G=0;G<c.length;++G)$+=c[G].dims[p],S[G]=$,k.push(c[G].dims.length),A[G]=Ce(`input${G}`,b,k[G]),D.push("rank"),O.push({type:12,data:S[G]});for(let G=0;G<c.length;++G)O.push(...It(c[G].dims));O.push(...It(g));let R=ht("output",b,g.length),V=R.indicesGet("indices",p),F=Array.from(Array(S.length).keys()).map(G=>`uniforms.sizeInConcatAxis${G}`).join(","),z=G=>`

  ${(()=>{G.registerUniform("outputSize","u32");for(let X=0;X<c.length;X++)G.registerUniform(`sizeInConcatAxis${X}`,"u32");return G.declareVariables(...A,R)})()}

  ${kA(S.length,F)}

  ${G.mainStart()}
    ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${R.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${V});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${S.length}u>(${F});
      ${V} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${CA(A,R)}
  }`;return{name:"Concat",shaderCache:{hint:`${p}`,inputDependencies:D},getRunData:()=>({outputs:[{dims:g,dataType:b}],dispatchGroup:{x:Math.ceil(x/64)},programUniforms:O}),getShaderSource:z}},OA=(c,p)=>{let g=c.inputs,b=g[0].dims,x=Ae.normalizeAxis(p.axis,b.length);EA(g,x);let S=b.slice();S[x]=g.reduce(($,D)=>$+(D.dims.length>x?D.dims[x]:0),0);let A=g.filter($=>Ae.size($.dims)>0);c.compute(LA(A,x,S,g[0].dataType),{inputs:A})},RA=c=>rn({axis:c.axis})}),wo,Ao,To,e0,So=u(()=>{vt(),Et(),wo=(c,p,g="f32")=>{switch(c.activation){case"Relu":return`value = max(value, ${p}(0.0));`;case"Sigmoid":return`value = (${p}(1.0) / (${p}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${p}(${g}(uniforms.clip_min)), ${p}(${g}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${p}(0.0), min(${p}(1.0), ${g}(uniforms.alpha) * value + ${g}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${g}(uniforms.alpha) * value, value, value >= ${p}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${c.activation}`)}},Ao=(c,p)=>{c.activation==="Clip"?p.push({type:1,data:c.clipMax},{type:1,data:c.clipMin}):c.activation==="HardSigmoid"?p.push({type:1,data:c.alpha},{type:1,data:c.beta}):c.activation==="LeakyRelu"&&p.push({type:1,data:c.alpha})},To=(c,p)=>{c.activation==="Clip"?p.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):c.activation==="HardSigmoid"?p.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):c.activation==="LeakyRelu"&&p.push({name:"alpha",type:"f32"})},e0=c=>{let p=(c==null?void 0:c.activation)||"";if(p==="HardSigmoid"){let[g,b]=(c==null?void 0:c.activation_params)||[.2,.5];return{activation:p,alpha:g,beta:b}}else if(p==="Clip"){let[g,b]=(c==null?void 0:c.activation_params)||[gN,IN];return{activation:p,clipMax:b,clipMin:g}}else if(p==="LeakyRelu"){let[g]=(c==null?void 0:c.activation_params)||[.01];return{activation:p,alpha:g}}return{activation:p}}}),ds,VA,t0=u(()=>{ds=(c,p)=>{switch(c){case 1:return p;case 2:return`vec2<${p}>`;case 3:return`vec3<${p}>`;case 4:return`vec4<${p}>`;default:throw new Error(`${c}-component is not supported.`)}},VA=c=>`
      ${c?"value = value + getBiasByOutputCoords(coords);":""}
      `}),PA,dP=u(()=>{PA=c=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${c}.x), i32(${c}.y), i32(${c}.z), 1));
}
`}),Ju,n0,s0=u(()=>{vt(),Et(),Ct(),So(),Ju=(c,p,g,b,x)=>{let S=b-g;return`
      ${Array.from({length:g}).map((A,$)=>`
      if (${pt(p.shape,$,p.rank)} != 1) {
        ${p.indicesSet(c,$,pt(x,$+S,b))}
      } else {
        ${p.indicesSet(c,$,0)}
      }`).join("")}
`},n0=(c,p,g,b,x=!1,S)=>{let A=c[0].dims,$=c[1].dims,D=A[A.length-2],k=$[$.length-1],O=A[A.length-1],R=Sn(k),V=Sn(O),F=Sn(D),z=Ae.size(g)/R/F,G=c.length>2,X=b?b.slice(0,-2):g.slice(0,-2),K=[Ae.size(X),D,k],q=[{type:12,data:z},{type:12,data:D},{type:12,data:k},{type:12,data:O}];Ao(p,q),q.push(...It(X,A,$)),G&&q.push(...It(c[2].dims)),q.push(...It(K));let te=ee=>{let re=Hg("batch_dims",c[0].dataType,X.length),me=Ce("a",c[0].dataType,A.length,V),Ne=Ce("b",c[1].dataType,$.length,R),Ve=ht("output",c[0].dataType,K.length,R),Ke=ns(Ve.type.tensor),lt=wo(p,Ve.type.value,Ke),_t=[me,Ne],Ot="";if(G){let Wt=x?R:1;_t.push(Ce("bias",c[2].dataType,c[2].dims.length,Wt)),Ot=`${x?`value += bias[col / ${Wt}];`:`value += ${Ve.type.value}(bias[row + i]);`}`}let Tt=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];To(p,Tt);let kt=()=>{let Wt=`var a_data: ${me.type.value};`;for(let it=0;it<V;it++)Wt+=`
              let b_data${it} = b[(b_offset + (k + ${it}) * uniforms.N + col) / ${R}];`;for(let it=0;it<F;it++){Wt+=`a_data = a[(a_offset + (row + ${it}) * uniforms.K + k) / ${V}];`;for(let en=0;en<V;en++)Wt+=`
            values[${it}] = fma(${Ne.type.value}(a_data${V===1?"":`[${en}]`}), b_data${en}, values[${it}]);
`}return Wt};return`
  ${ee.registerUniforms(Tt).registerInternalVariables(re).declareVariables(..._t,Ve)}
  ${ee.mainStart()}
    ${ee.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${R})) * ${R};
    var index1 = global_idx / (uniforms.N / ${R});
    let stride1 = uniforms.M / ${F};
    let row = (index1 % stride1) * ${F};
    let batch = index1 / stride1;

    ${g.length===2?"":`let batch_indices = ${re.offsetToIndices("batch")};`}

    var a_indices: ${me.type.indices};
    ${Ju("a_indices",me,me.rank-2,re.rank,"batch_indices")}
    ${me.indicesSet("a_indices",me.rank-2,0)}
    ${me.indicesSet("a_indices",me.rank-1,0)}
    let a_offset = ${me.indicesToOffset("a_indices")};

    var b_indices: ${Ne.type.indices};
    ${Ju("b_indices",Ne,Ne.rank-2,re.rank,"batch_indices")}
    ${Ne.indicesSet("b_indices",Ne.rank-2,0)}
    ${Ne.indicesSet("b_indices",Ne.rank-1,0)}
    let b_offset = ${Ne.indicesToOffset("b_indices")};
    var values: array<${Ve.type.value}, ${F}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${V}) {
      ${kt()}
    }
    for (var i = 0u; i < ${F}u; i++) {
      var value = values[i];
      ${Ot}
      ${lt}
      let cur_indices = ${Ve.type.indices}(batch, row + i, col);
      let offset = ${Ve.indicesToOffset("cur_indices")};
      ${Ve.setByOffset(`offset / ${R}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${p.activation};${R};${V};${F};${x}`,inputDependencies:G?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:S?S(g):g,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(z/64)},programUniforms:q}),getShaderSource:te}}}),FA,zA,r0,i0,MA,a0,WA,Bh,o0=u(()=>{vt(),Et(),Ct(),So(),s0(),t0(),FA=(c,p)=>c?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${p?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${p?", batchIndices":""});
        `,zA=(c,p)=>c?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${p===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${p===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${p===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,r0=(c,p,g="f32",b,x=!1,S=32,A=!1,$=32)=>{let D=p[1]*c[1],k=p[0]*c[0],O=x?D:S,R=x?S:D,V=O/p[0],F=S/p[1];if(!((x&&V===4&&c[1]===4||!x&&(V===3||V===4))&&O%p[0]===0&&S%p[1]===0&&c[0]===4))throw new Error(`If transposeA ${x} is true, innerElementSize ${V} and workPerThread[1] ${c[1]} must be 4.
      Otherwise, innerElementSize ${V} must be 3 or 4.
  tileAWidth ${O} must be divisible by workgroupSize[0]${p[0]}. tileInner ${S} must be divisible by workgroupSize[1] ${p[1]}. colPerThread ${c[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${V}<${g}>, ${O/V}>, ${R}>;
var<workgroup> mm_Bsub: array<array<vec4<${g}>, ${k/c[0]}>, ${S}>;

const rowPerThread = ${c[1]};
const colPerThread = ${c[0]};
const innerElementSize = ${V};
const tileInner = ${S};

@compute @workgroup_size(${p[0]}, ${p[1]}, ${p[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${A?"0":"i32(globalId.z)"};
  ${b?`let batchIndices = ${b.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${D};

  let num_tiles = ${A?`${Math.ceil($/S)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${A?`i32(globalId.z) * ${$}`:"0"};

  var acc: array<vec4<${g}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${F};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${FA(x,b)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${F}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${b?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${V===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${zA(x,V)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},i0=(c,p)=>c?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${p?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${p?", batchIndices":""});
            `,MA=c=>c?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",a0=(c,p,g="f32",b,x=!1,S=32,A=!1,$=32,D=!1)=>{let k=c[1]*p[1],O=c[0]*p[0],R=x?k:S,V=x?S:k;if(!(V%p[1]===0&&R%p[0]===0&&S%p[1]===0))throw new Error(`tileAHight ${V} must be divisible by workgroupSize[1]${p[1]}, tileAWidth ${R} must be divisible by workgroupSize[0]${p[0]}, tileInner ${S} must be divisible by workgroupSize[1]${p[1]}`);let F=V/p[1],z=R/p[0],G=S/p[1],X=D?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${k};
    let globalColStart = i32(workgroupId.x) * ${O};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${V}; inputRow = inputRow + ${p[1]}) {
        for (var inputCol = localCol; inputCol < ${R}; inputCol = inputCol + ${p[0]}) {
          ${i0(x,b)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${S}; inputRow = inputRow + ${p[1]}) {
            for (var inputCol = localCol; inputCol < ${O}; inputCol = inputCol + ${p[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${b?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${g}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${p[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${x?`mm_Asub[k][localRow + innerRow * ${p[1]}];`:`mm_Asub[localRow + innerRow * ${p[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${p[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${p[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${k};

let tileRowA = i32(localId.y) * ${F};
let tileColA = i32(localId.x) * ${z};
let tileRowB = i32(localId.y) * ${G};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${F}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${z}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${i0(x,b)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${G}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${b?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${g}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${MA(x)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${g}, ${R}>, ${V}>;
  var<workgroup> mm_Bsub : array<array<${g}, ${O}>, ${S}>;
  const rowPerThread = ${c[1]};
  const colPerThread = ${c[0]};
  const tileInner = ${S};

@compute @workgroup_size(${p[0]}, ${p[1]}, ${p[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${A?"0":"i32(globalId.z)"};
    ${b?`let batchIndices = ${b.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${A?`${Math.ceil($/S)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${A?`i32(globalId.z) * ${$}`:"0"};

    var acc : array<array<${g}, colPerThread>, rowPerThread>;
    ${X}
  }
`},WA=(c,p,g,b,x=!1)=>{let[S,A,$,D]=b,k=ns(b[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${S.type.indices}) -> ${ds(c,k)} {
      var value = ${ds(c,k)}(0.0);
      let col = colIn * ${c};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${A.type.indices};
        ${Ju("aIndices",A,A.rank-2,S.rank,"batchIndices")}
        ${A.indicesSet("aIndices",A.rank-2,"u32(row)")}
        ${A.indicesSet("aIndices",A.rank-1,"u32(colIn)")}
        value = ${A.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${S.type.indices}) -> ${ds(c,k)} {
      var value = ${ds(c,k)}(0.0);
      let col = colIn * ${c};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${$.type.indices};
        ${Ju("bIndices",$,$.rank-2,S.rank,"batchIndices")}
        ${$.indicesSet("bIndices",$.rank-2,"u32(row)")}
        ${$.indicesSet("bIndices",$.rank-1,"u32(colIn)")}
        value = ${$.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ds(c,k)}) {
      let col = colIn * ${c};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${p?`value = value + ${x?"bias[colIn]":`${ds(c,k)}(bias[row])`};`:""}
        ${g}
        ${D.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Bh=(c,p,g,b,x=!1,S)=>{let A=c[0].dims,$=c[1].dims,D=A.slice(0,-2),k=$.slice(0,-2),O=b?b.slice(0,-2):g.slice(0,-2),R=Ae.size(O),V=A[A.length-2],F=A[A.length-1],z=$[$.length-1],G=F%4===0&&z%4===0,X=V<=8?[4,1,1]:[4,4,1],K=[8,8,1],q=[Math.ceil(z/K[0]/X[0]),Math.ceil(V/K[1]/X[1]),Math.ceil(R/K[2]/X[2])],te=G?4:1,ee=[...D,V,F/te],re=ee.length,me=[...k,F,z/te],Ne=me.length,Ve=[R,V,z/te],Ke=[{type:6,data:V},{type:6,data:z},{type:6,data:F}];Ao(p,Ke),Ke.push(...It(O,ee,me));let lt=["rank","rank"],_t=c.length>2;_t&&(Ke.push(...It(c[2].dims)),lt.push("rank")),Ke.push(...It(Ve));let Ot=Tt=>{let kt=O.length,Wt=Hg("batchDims",c[0].dataType,kt,1),it=ns(c[0].dataType),en=Ce("a",c[0].dataType,re,te),In=Ce("b",c[1].dataType,Ne,te),yt=ht("result",c[0].dataType,Ve.length,te),hn=[en,In];if(_t){let Or=x?te:1;hn.push(Ce("bias",c[2].dataType,c[2].dims.length,Or))}let Be=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];To(p,Be);let tt=ns(yt.type.tensor),sn=wo(p,yt.type.value,tt),Vn=WA(te,_t,sn,[Wt,en,In,yt],x);return`
  ${Tt.registerUniforms(Be).registerInternalVariables(Wt).declareVariables(...hn,yt)}
  ${Vn}
  ${G?r0(X,K,it,Wt):a0(X,K,it,Wt)}
                   `};return{name:"MatMul",shaderCache:{hint:`${X};${p.activation};${G};${x}`,inputDependencies:lt},getRunData:()=>({outputs:[{dims:S?S(g):g,dataType:c[0].dataType}],dispatchGroup:{x:q[0],y:q[1],z:q[2]},programUniforms:Ke}),getShaderSource:Ot}}}),BA,HA,hP=u(()=>{vt(),Qi(),Ct(),So(),t0(),dP(),o0(),BA=(c,p,g,b,x=!1,S,A=4,$=4,D=4,k="f32")=>{let O=Ke=>{switch(Ke){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${k}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Ke} is not supported.`)}},R=Ke=>{switch(Ke){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Ke} is not supported.`)}},V=c?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,F=c?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,z=c?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",G=c?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",X=c?"row":"col",K=c?"col":"row",q=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${c?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${X} / outWidth;
    let outCol = ${X} % outWidth;

    let WRow = ${K} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${K} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${K} % inChannels;
    var resData = ${ds(A,k)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${z} && xCol >= 0 && xCol < ${G}) {
      ${V}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${O(A)}
    }
    return resData;`,te=c?p&&b?`
    let col = colIn * ${A};
    ${q}`:`
    let col = colIn * ${A};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${q}
    }
    return ${ds(A,k)}(0.0);`:b&&g?`
    let col = colIn * ${A};
    ${q}`:`
    let col = colIn * ${A};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${q}
    }
    return ${ds(A,k)}(0.0);`,ee=c?b&&g?R($):`
    let col = colIn * ${$};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${R($)}
    }
    return ${ds($,k)}(0.0);`:`
    let col = colIn * ${$};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${R($)}
    }
    return ${ds($,k)}(0.0);`,re=ds(D,k),me=ds(c?A:$,k),Ne=ds(c?$:A,k),Ve=wo(S,re,k);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${me} {
      ${c?te:ee}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Ne} {
      ${c?ee:te}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${re}) {
      let col = colIn * ${D};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${c?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${F}
      ${VA(x)}
      ${Ve}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},HA=(c,p,g,b,x,S,A,$,D)=>{let k=p.format==="NHWC",O=k?c[0].dims[3]:c[0].dims[1],R=g[0],V=k?g[2]:g[3],F=k?g[1]:g[2],z=k?g[3]:g[1],G=k&&(O%4===0||O%3===0)&&z%4===0,X=k?z:V*F,K=k?V*F:z,q=[8,8,1],te=b<=8?[4,1,1]:[4,4,1],ee=[Math.ceil(X/q[0]/te[0]),Math.ceil(K/q[1]/te[1]),Math.ceil(R/q[2]/te[2])];jt("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${ee}`);let re=G?k&&O%4!==0?3:4:1,me=q[1]*te[1],Ne=q[0]*te[0],Ve=Math.max(q[0]*re,q[1]),Ke=b%me===0,lt=x%Ne===0,_t=S%Ve===0,Ot=G?[re,4,4]:[1,1,1],Tt=[{type:6,data:b},{type:6,data:x},{type:6,data:S},{type:6,data:[p.pads[0],p.pads[1]]},{type:6,data:p.strides},{type:6,data:p.dilations}];Ao(p,Tt),Tt.push(...It(c[0].dims,c[1].dims));let kt=["rank","rank"];A&&(Tt.push(...It(c[2].dims)),kt.push("rank")),Tt.push(...It(g));let Wt=it=>{let en=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];To(p,en);let In=G?4:1,yt=ns(c[0].dataType),hn=`
      fn setOutputAtIndex(flatIndex : i32, value : ${G?`vec4<${yt}>`:yt}) {
        result[flatIndex] = ${G?`vec4<${yt}>`:yt}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${G?`vec4<${yt}>`:yt}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${G?"/ 4":""}, value);
      }`,Be=Ce("x",c[0].dataType,c[0].dims.length,re===3?1:re),tt=Ce("w",c[1].dataType,c[1].dims.length,In),sn=[Be,tt],Vn=ht("result",c[0].dataType,g.length,In);if(A){let Or=Ce("bias",c[2].dataType,c[2].dims.length,In);sn.push(Or),hn+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${G?`vec4<${yt}>`:yt} {
          return bias[coords.${k?"w":"y"}${G?"/ 4":""}];
        }`}return`
        ${PA("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${it.registerUniforms(en).declareVariables(...sn,Vn)}
        ${hn}
        ${BA(k,Ke,lt,_t,A,p,Ot[0],Ot[1],Ot[2],yt)}
        ${G?r0(te,q,yt,void 0,!k,Ve):a0(te,q,yt,void 0,!k,Ve,!1,void 0,$)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${p.cacheKey};${re};${G};${Ke};${lt};${_t};${me};${Ne};${Ve}`,inputDependencies:kt},getRunData:()=>({outputs:[{dims:D?D(g):g,dataType:c[0].dataType}],dispatchGroup:{x:ee[0],y:ee[1],z:ee[2]},programUniforms:Tt}),getShaderSource:Wt}}}),UA,l0,ec,GA,u0,qA,KA,jA,pP=u(()=>{vt(),Qi(),Et(),Ct(),So(),t0(),UA=c=>{let p=1;for(let g=0;g<c.length;g++)p*=c[g];return p},l0=c=>typeof c=="number"?[c,c,c]:c,ec=(c,p)=>p<=1?c:c+(c-1)*(p-1),GA=(c,p,g,b=1)=>{let x=ec(p,b);return Math.floor((c[0]*(g-1)-g+x)/2)},u0=(c,p,g,b,x)=>{x==null&&(x=GA(c,p[0],b[0]));let S=[0,0,0,g];for(let A=0;A<3;A++)c[A]+2*x>=p[A]&&(S[A]=Math.trunc((c[A]-p[A]+2*x)/b[A]+1));return S},qA=(c,p,g,b,x,S,A,$,D,k)=>{let O,R,V,F;if(c==="VALID"&&(c=0),typeof c=="number"){O={top:c,bottom:c,left:c,right:c,front:c,back:c};let z=u0([p,g,b,1],[$,D,k],1,[x,S,A],c);R=z[0],V=z[1],F=z[2]}else if(Array.isArray(c)){if(!c.every((G,X,K)=>G===K[0]))throw Error(`Unsupported padding parameter: ${c}`);O={top:c[0],bottom:c[1],left:c[2],right:c[3],front:c[4],back:c[5]};let z=u0([p,g,b,1],[$,D,k],1,[x,S,A],c[0]);R=z[0],V=z[1],F=z[2]}else if(c==="SAME_UPPER"){R=Math.ceil(p/x),V=Math.ceil(g/S),F=Math.ceil(b/A);let z=(R-1)*x+$-p,G=(V-1)*S+D-g,X=(F-1)*A+k-b,K=Math.floor(z/2),q=z-K,te=Math.floor(G/2),ee=G-te,re=Math.floor(X/2),me=X-re;O={top:te,bottom:ee,left:re,right:me,front:K,back:q}}else throw Error(`Unknown padding parameter: ${c}`);return{padInfo:O,outDepth:R,outHeight:V,outWidth:F}},KA=(c,p,g,b,x,S=!1,A="channelsLast")=>{let $,D,k,O,R;if(A==="channelsLast")[$,D,k,O,R]=c;else if(A==="channelsFirst")[$,R,D,k,O]=c;else throw new Error(`Unknown dataFormat ${A}`);let[V,,F,z,G]=p,[X,K,q]=l0(g),[te,ee,re]=l0(b),me=ec(F,te),Ne=ec(z,ee),Ve=ec(G,re),{padInfo:Ke,outDepth:lt,outHeight:_t,outWidth:Ot}=qA(x,D,k,O,X,K,q,me,Ne,Ve),Tt=S?V*R:V,kt=[0,0,0,0,0];return A==="channelsFirst"?kt=[$,Tt,lt,_t,Ot]:A==="channelsLast"&&(kt=[$,lt,_t,Ot,Tt]),{batchSize:$,dataFormat:A,inDepth:D,inHeight:k,inWidth:O,inChannels:R,outDepth:lt,outHeight:_t,outWidth:Ot,outChannels:Tt,padInfo:Ke,strideDepth:X,strideHeight:K,strideWidth:q,filterDepth:F,filterHeight:z,filterWidth:G,effectiveFilterDepth:me,effectiveFilterHeight:Ne,effectiveFilterWidth:Ve,dilationDepth:te,dilationHeight:ee,dilationWidth:re,inShape:c,outShape:kt,filterShape:p}},jA=(c,p,g,b,x,S)=>{let A=S==="channelsLast";A?c[0].dims[3]:c[0].dims[1];let $=[64,1,1],D={x:g.map((X,K)=>K)},k=[Math.ceil(UA(D.x.map(X=>g[X]))/$[0]),1,1];jt("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${k}`);let O=1,R=Ae.size(g),V=[{type:12,data:R},{type:12,data:b},{type:12,data:x},{type:12,data:p.strides},{type:12,data:p.dilations}];Ao(p,V),V.push(...It(c[0].dims,c[1].dims));let F=["rank","rank"],z=c.length===3;z&&(V.push(...It(c[2].dims)),F.push("rank")),V.push(...It(g));let G=X=>{let K=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:b.length},{name:"pads",type:"u32",length:x.length},{name:"strides",type:"u32",length:p.strides.length},{name:"dilations",type:"u32",length:p.dilations.length}];To(p,K);let q=1,te=ns(c[0].dataType),ee=Ce("x",c[0].dataType,c[0].dims.length,O),re=Ce("W",c[1].dataType,c[1].dims.length,q),me=[ee,re],Ne=ht("result",c[0].dataType,g.length,q),Ve="";if(z){let _t=Ce("bias",c[2].dataType,c[2].dims.length,q);me.push(_t),Ve+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${te} {
          return bias[${A?pt("coords",4,5):pt("coords",1,5)}];
        }`}let Ke=ds(O,te),lt=wo(p,Ke,te);return`
            ${Ve}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${ee.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${re.getByIndices("aIndices")};
            }
          ${X.registerUniforms(K).declareVariables(...me,Ne)}
          ${X.mainStart()}
          ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${Ne.offsetToIndices("global_idx")};
              let batch = ${pt("coords",0,ee.rank)};
              let d2 = ${A?pt("coords",ee.rank-1,ee.rank):pt("coords",1,ee.rank)};
              let xFRCCorner = vec3<u32>(${A?pt("coords",1,ee.rank):pt("coords",2,ee.rank)},
              ${A?pt("coords",2,ee.rank):pt("coords",3,ee.rank)},
              ${A?pt("coords",3,ee.rank):pt("coords",4,ee.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${A?pt("uniforms.x_shape",1,ee.rank):pt("uniforms.x_shape",2,ee.rank)};
              let xShapeZ = ${A?pt("uniforms.x_shape",2,ee.rank):pt("uniforms.x_shape",3,ee.rank)};
              let xShapeW = ${A?pt("uniforms.x_shape",3,ee.rank):pt("uniforms.x_shape",4,ee.rank)};
              let xShapeU = ${A?pt("uniforms.x_shape",4,ee.rank):pt("uniforms.x_shape",1,ee.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${A?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${A?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${A?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${A?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${z?"value = value + getBiasByOutputCoords(coords)":""};
              ${lt}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${p.cacheKey};${A};${O};${z}`,inputDependencies:F},getRunData:()=>({outputs:[{dims:g,dataType:c[0].dataType}],dispatchGroup:{x:k[0],y:k[1],z:k[2]},programUniforms:V}),getShaderSource:G}}}),YA,XA,fP=u(()=>{vt(),Et(),Ct(),So(),YA=(c,p,g,b)=>{let x=c.length>2,S=x?"value += b[output_channel];":"",A=c[0].dims,$=c[1].dims,D=p.format==="NHWC",k=D?g[3]:g[1],O=k/p.group,R=D&&O>=4?Sn(k):1,V=Ae.size(g)/R,F=[{type:12,data:V},{type:12,data:p.dilations},{type:12,data:[p.strides[0],p.strides[1]]},{type:12,data:[p.pads[0],p.pads[1]]},{type:12,data:O}];Ao(p,F),F.push(...It(A,[$[0],$[1],$[2],$[3]/R]));let z=x?["rank","rank","rank"]:["rank","rank"];F.push(...It([g[0],g[1],g[2],g[3]/R]));let G=X=>{let K=ht("output",c[0].dataType,g.length,R),q=ns(K.type.tensor),te=wo(p,K.type.value,q),ee=Ce("x",c[0].dataType,A.length),re=Ce("w",c[1].dataType,$.length,R),me=[ee,re];x&&me.push(Ce("b",c[2].dataType,c[2].dims,R));let Ne=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:p.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];To(p,Ne);let Ve=D?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${ee.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${re.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${ee.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${re.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${X.registerUniforms(Ne).declareVariables(...me,K)}

  ${X.mainStart()}
    ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${K.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${D?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${D?1:2}], outputIndices[${D?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${R} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${D?2:1}];

    var value: ${K.type.value} = ${K.type.value}(0);
    ${Ve}
    ${S}
    ${te}
    ${K.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${p.cacheKey}_${R}`,inputDependencies:z},getRunData:()=>({outputs:[{dims:b?b(g):g,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(V/64)},programUniforms:F}),getShaderSource:G}},XA=(c,p,g,b)=>{let x=c.length>2,S=Sn(g[3]),A=Sn(g[2]),$=Ae.size(g)/S/A,D=[c[0].dims[0],c[0].dims[1],c[0].dims[2],c[0].dims[3]/S],k=[c[1].dims[0],c[1].dims[1],c[1].dims[2],c[1].dims[3]/S],O=[g[0],g[1],g[2],g[3]/S],R=[{type:12,data:$},{type:6,data:[p.strides[0],p.strides[1]]},{type:6,data:[p.pads[0],p.pads[1]]}];Ao(p,R),R.push(...It(D,k,O));let V=(A-1)*p.strides[1]+k[1],F=z=>{let G=ht("output",c[0].dataType,O.length,S),X=ns(G.type.tensor),K=wo(p,G.type.value,X),q=Ce("x",c[0].dataType,D.length,S),te=Ce("w",c[1].dataType,k.length,S),ee=[q,te];x&&ee.push(Ce("b",c[2].dataType,c[2].dims,S));let re=x?"value += b[output_channel];":"",me=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return To(p,me),`
  ${z.registerUniforms(me).declareVariables(...ee,G)}
  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${A}u;
    let col = (index1 % width1) * ${A}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${q.type.value}, ${V}>;
    var values: array<${G.type.value}, ${A}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${k[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${V}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${q.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${q.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${k[1]}; w_width++) {
          let w_val = ${te.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${A}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${A}u; i++) {
      var value = values[i];
      ${re}
      ${K}
      ${G.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${p.cacheKey};${S};${A};${V};${k[0]};${k[1]}`,inputDependencies:x?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:b?b(g):g,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:R}),getShaderSource:F}}}),ZA,Hh,QA,Uh,c0,d0,JA,eT,h0,mP=u(()=>{Et(),hP(),pP(),o0(),fP(),So(),s0(),Sa(),ZA=(c,p,g,b,x,S)=>{let A=c[0],$=c.slice(S?1:2,S?3:4),D=$.length,k=p[0],O=p.slice(2).map((V,F)=>V+(V-1)*(g[F]-1)),R=$.map((V,F)=>V+b[F]+b[F+D]).map((V,F)=>Math.floor((V-O[F]+x[F])/x[F]));return R.splice(0,0,A),R.splice(S?3:1,0,k),R},Hh=[2,3,1,0],QA=(c,p)=>{if(!c||c.length!==2&&c.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(c[0].dims.length>5)throw new Error("greater than 5D is not supported");if(c[0].dims.length!==c[1].dims.length)throw new Error("filter does not have same dimension as input");let g=c[0].dims[p.format==="NHWC"?c[0].dims.length-1:1],b=c[1].dims[1]*p.group;if(g!==b)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(c.length===3&&(c[2].dims.length!==1||c[1].dims[0]!==c[2].dims[0]))throw new Error("invalid bias");let x=c[0].dims.length-2;if(p.dilations.length!==x)throw new Error(`dilations should be ${x}D`);if(p.strides.length!==x)throw new Error(`strides should be ${x}D`);if(p.pads.length!==x*2)throw new Error(`pads should be ${x*2}D`);if(p.kernelShape.length!==0&&p.kernelShape.length!==c[1].dims.length-2)throw new Error("invalid kernel shape")},Uh=(c,p)=>{let g=c.kernelShape.slice();g.length<p[1].dims.length-2&&g.push(...Array(p[1].dims.length-2-g.length).fill(0));for(let S=2;S<p[1].dims.length;++S)g[S-2]===0&&(g[S-2]=p[1].dims[S]);let b=c.pads.slice();Ph.adjustPadsBasedOnAutoPad(p[0].dims,c.strides,c.dilations,g,b,c.format==="NHWC",c.autoPad);let x=Object.assign({},c);return Object.assign(x,{kernelShape:g,pads:b}),x},c0=c=>{let p=e0(c),g=c.format,b=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][c.auto_pad],x=c.dilations,S=c.group,A=c.kernel_shape,$=c.pads,D=c.strides,k=c.w_is_const();return{autoPad:b,format:g,dilations:x,group:S,kernelShape:A,pads:$,strides:D,wIsConst:k,...p,cacheKey:`${c.format};${p.activation};`}},d0=(c,p,g,b)=>{let x=g.format==="NHWC",S=ZA(p[0].dims,p[1].dims,g.dilations,g.pads,g.strides,x);if(g.group!==1){let me=[p[0]];if(x){let Ne=c.kernelCustomData.wT??c.compute(Nr(p[1],Hh),{inputs:[1],outputs:[g.wIsConst?-2:-1]})[0];g.wIsConst&&!c.kernelCustomData.wT&&(c.kernelCustomData.wT=Ne),me.push(Ne)}else me.push(p[1]);p.length===3&&me.push(p[2]),!c.adapterInfo.isArchitecture("ampere")&&x&&p[1].dims[0]===g.group&&p[1].dims[1]===1&&g.dilations[0]===1&&g.dilations[1]===1?c.compute(XA(me,g,S,b),{inputs:me}):c.compute(YA(me,g,S,b),{inputs:me});return}let A=p.length===3,$=p[0].dims[x?1:2],D=p[0].dims[x?2:3],k=p[0].dims[x?3:1],O=p[1].dims[2],R=p[1].dims[3],V=S[x?1:2],F=S[x?2:3],z=S[x?3:1],G=x&&O===$&&R===D&&g.pads[0]===0&&g.pads[1]===0;if(G||O===1&&R===1&&g.dilations[0]===1&&g.dilations[1]===1&&g.strides[0]===1&&g.strides[1]===1&&g.pads[0]===0&&g.pads[1]===0){let me=S[0],Ne,Ve,Ke,lt=[];if(x){let Tt=c.kernelCustomData.wT??c.compute(Nr(p[1],Hh),{inputs:[1],outputs:[g.wIsConst?-2:-1]})[0];if(g.wIsConst&&!c.kernelCustomData.wT&&(c.kernelCustomData.wT=Tt),G){let kt=$*D*k;Ne=p[0].reshape([1,me,kt]),Ve=Tt.reshape([1,kt,z]),Ke=[1,me,z]}else Ne=p[0].reshape([me,$*D,k]),Ve=Tt.reshape([1,k,z]),Ke=[me,V*F,z];lt.push(Ne),lt.push(Ve)}else Ne=p[0].reshape([me,k,$*D]),Ve=p[1].reshape([1,z,k]),Ke=[me,z,V*F],lt.push(Ve),lt.push(Ne);A&&lt.push(p[2]);let _t=Ke[2],Ot=lt[0].dims[lt[0].dims.length-1];_t<8&&Ot<8?c.compute(n0(lt,g,S,Ke,x,b),{inputs:lt}):c.compute(Bh(lt,g,S,Ke,x,b),{inputs:lt});return}let X=!0,K=c.kernelCustomData.wT??c.compute(Nr(p[1],Hh),{inputs:[1],outputs:[g.wIsConst?-2:-1]})[0];g.wIsConst&&!c.kernelCustomData.wT&&(c.kernelCustomData.wT=K);let q=[p[0],K];A&&q.push(p[2]);let te=x?V*F:z,ee=x?z:V*F,re=O*R*k;c.compute(HA(q,g,S,te,ee,re,A,X,b),{inputs:q})},JA=(c,p)=>{let g=p.format==="NHWC",b=[c.inputs[0].reshape(g?[c.inputs[0].dims[0],1,c.inputs[0].dims[1],c.inputs[0].dims[2]]:[c.inputs[0].dims[0],c.inputs[0].dims[1],1,c.inputs[0].dims[2]]),c.inputs[1].reshape([c.inputs[1].dims[0],c.inputs[1].dims[1],1,c.inputs[1].dims[2]])];c.inputs.length===3&&b.push(c.inputs[2]);let x=[0,p.pads[0],0,p.pads[1]],S=[1].concat(p.strides),A=[1].concat(p.dilations),$=[1].concat(p.kernelShape),D=Uh({...p,pads:x,strides:S,dilations:A,kernelShape:$},b);d0(c,b,D,k=>g?[k[0],k[2],k[3]]:[k[0],k[1],k[3]])},eT=(c,p,g)=>{let b=g.format==="NHWC"?"channelsLast":"channelsFirst",x=Uh(g,p),S=g.autoPad==="NOTSET"?g.pads:g.autoPad,A=KA(p[0].dims,p[1].dims,g.strides,g.dilations,S,!1,b);c.compute(jA(p,x,A.outShape,[A.filterDepth,A.filterHeight,A.filterWidth],[A.padInfo.front,A.padInfo.top,A.padInfo.left],b))},h0=(c,p)=>{if(QA(c.inputs,p),c.inputs[0].dims.length===3)JA(c,p);else if(c.inputs[0].dims.length===5)eT(c,c.inputs,p);else{let g=Uh(p,c.inputs);d0(c,c.inputs,g)}}}),tT,gP=u(()=>{vt(),Qi(),Et(),Ct(),tT=(c,p,g)=>{let b=c.length>2,x=p.outputShape,S=p.format==="NHWC",A=p.group,$=c[1].dims,D=$[2]/A,k=$[3],O=S?Sn(D):1,R=S?Sn(k):1,V=S?k===1?O:R:1,F=Ae.size(x)/R,z=[Math.ceil(F/64),1,1];jt("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${z}`);let G=["rank","rank"],X=[p.strides[0],p.strides[1]],K=[p.kernelShape[S?1:2],p.kernelShape[S?2:3]],q=[p.dilations[0],p.dilations[1]],te=[K[0]+(p.dilations[0]<=1?0:(p.kernelShape[S?1:2]-1)*(p.dilations[0]-1)),K[1]+(p.dilations[1]<=1?0:(p.kernelShape[S?2:3]-1)*(p.dilations[1]-1))],ee=[te[0]-1-Math.floor((p.pads[0]+p.pads[2])/2),te[1]-1-Math.floor((p.pads[1]+p.pads[3])/2)],re=[{type:12,data:F},{type:12,data:X},{type:12,data:K},{type:12,data:q},{type:12,data:te},{type:6,data:ee},{type:12,data:D},{type:12,data:k},...It(c[0].dims,c[1].dims)];b&&(re.push(...It(c[2].dims)),G.push("rank")),re.push(...It(x));let me=Ne=>{let Ve=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:X.length},{name:"filter_dims",type:"u32",length:K.length},{name:"dilations",type:"u32",length:K.length},{name:"effective_filter_dims",type:"u32",length:te.length},{name:"pads",type:"i32",length:ee.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],Ke=ns(c[0].dataType),lt=S?1:2,_t=S?2:3,Ot=S?3:1,Tt=Ce("W",c[1].dataType,c[1].dims.length,V),kt=Ce("Dy",c[0].dataType,c[0].dims.length,O),Wt=[kt,Tt];b&&Wt.push(Ce("bias",c[2].dataType,[x[Ot]].length,R));let it=ht("result",c[0].dataType,x.length,R),en=()=>{let yt="";if(O===1)yt+=`
        let w_offset = ${Tt.indicesToOffset(`${Tt.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
        let wValue = ${Tt.getByOffset(`w_offset / ${V}`)};
        dotProd = dotProd + xValue * wValue;`;else if(k===1)yt+=`
          let wValue = ${Tt.getByOffset(`${Tt.indicesToOffset(`${Tt.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${V}`)};
          dotProd = dotProd + dot(xValue, wValue);`;else for(let hn=0;hn<O;hn++)yt+=`
            let wValue${hn} = ${Tt.getByOffset(`${Tt.indicesToOffset(`${Tt.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${hn}, wOutChannel)`)} / ${V}`)};
            dotProd = dotProd + xValue[${hn}] * wValue${hn};`;return yt},In=`
            let outputIndices = ${it.offsetToIndices(`global_idx * ${R}`)};
            let batch = ${it.indicesGet("outputIndices",0)};
            let d1 = ${it.indicesGet("outputIndices",Ot)};
            let r = ${it.indicesGet("outputIndices",lt)};
            let c = ${it.indicesGet("outputIndices",_t)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${it.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${Ke}(dyRCorner) + ${Ke}(wR)) / ${Ke}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${Ke}(uniforms.Dy_shape[${lt}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }

              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${Ke}(dyCCorner) + ${Ke}(wC)) / ${Ke}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${Ke}(uniforms.Dy_shape[${_t}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${O}) {
                  let xValue = ${S?kt.getByOffset(`${kt.indicesToOffset(`${kt.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${O}`):kt.get("batch","inputChannel","idyR","idyC")};
                  ${en()}
                  inputChannel = inputChannel + ${O};
                }
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${b?` + bias[d1 / ${R}]`:""};
            ${it.setByOffset("global_idx","value")};
          `;return`
    ${Ne.registerUniforms(Ve).declareVariables(...Wt,it)}
      ${Ne.mainStart()}
      ${Ne.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${In}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${p.cacheKey};${O}${V}${R}${k===1}`,inputDependencies:G},getRunData:()=>({dispatchGroup:{x:z[0],y:z[1],z:z[2]},outputs:[{dims:g?g(x):x,dataType:c[0].dataType}],programUniforms:re}),getShaderSource:me}}}),nT,sT,rT,p0,iT,aT,f0,oT,lT,IP=u(()=>{gP(),So(),Sa(),nT=(c,p,g,b,x,S)=>(c-1)*p+g+(b-1)*x+1-S,sT=(c,p,g,b,x)=>{let S=Math.floor(c/2);p==="SAME_UPPER"?(g[b]=S,g[x]=c-S):p==="SAME_LOWER"&&(g[b]=c-S,g[x]=S)},rT=(c,p,g,b,x,S,A,$,D,k)=>{let O=c.length-2,R=k.length===0;D.length<O&&D.push(...Array(O-D.length).fill(0));let V=c[0],F=p[$?3:1]*x;for(let z=0,G=c.length-O-($?1:0);z<O;++z,++G){let X=c[G],K=R?X*A[z]:k[z],q=nT(X,A[z],S[z],p[G],g[z],K);sT(q,b,S,z,z+O),R&&k.push(A[z]*(X-1)+D[z]+(p[G]-1)*g[z]+1-S[z]-S[z+O])}k.splice(0,0,V),k.splice($?3:1,0,F)},p0=(c,p)=>{let g=c.kernelShape.slice();if(c.kernelShape.length===0||c.kernelShape.reduce((R,V)=>R*V,1)===0){g.length=0;for(let R=2;R<p[1].dims.length;++R)g.push(p[1].dims[R])}let b=c.format==="NHWC";g.splice(0,0,p[1].dims[0]),g.splice(b?3:1,0,p[1].dims[1]);let x=c.pads.slice(),S=c.outputShape.slice(),A=c.outputPadding.slice(),$=p[0].dims,D=c.dilations.slice();if(D.reduce((R,V)=>R+V,0)===0){let R=p[0].dims.length-2;D=new Array(R).fill(1)}let k=c.strides.slice();if(k.reduce((R,V)=>R+V,0)===0){let R=p[0].dims.length-2;k=new Array(R).fill(1)}rT($,g,D,c.autoPad,c.group,x,k,b,A,S);let O=Object.assign({},c);return Object.assign(O,{kernelShape:g,pads:x,outputPadding:A,outputShape:S,dilations:D,strides:k}),O},iT=c=>{let p=e0(c),g=c.format,b=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof c.autoPad>"u"?0:c.autoPad],x=c.dilations,S=c.group,A=c.kernelShape,$=c.pads,D=c.strides,k=c.wIsConst(),O=c.outputPadding,R=c.outputShape;return{autoPad:b,format:g,dilations:x,group:S,kernelShape:A,outputPadding:O,outputShape:R,pads:$,strides:D,wIsConst:k,...p,cacheKey:`${c.format};${p.activation};`}},aT=(c,p)=>{if(!c||c.length!==2&&c.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(c[0].dims.length!==4&&c[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(c[0].dims.length!==c[1].dims.length)throw new Error("filter does not have same dimension as input");let g=c[0].dims[p.format==="NHWC"?c[0].dims.length-1:1],b=c[1].dims[0];if(g!==b)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let x=c[1].dims[1]*p.group;if(c.length===3&&(c[2].dims.length!==1||c[2].dims[0]!==x))throw new Error("invalid bias");let S=c[0].dims.length-2;if(p.dilations.reduce((A,$)=>A+$,0)>0&&p.dilations.length!==S)throw new Error(`dilations should be ${S}D`);if(p.strides.reduce((A,$)=>A+$,0)>0&&p.strides.length!==S)throw new Error(`strides should be ${S}D`);if(p.pads.reduce((A,$)=>A+$,0)>0&&p.pads.length!==S*2)throw new Error(`pads should be ${S*2}D`);if(p.outputPadding.length!==S&&p.outputPadding.length!==0)throw new Error(`output_padding should be ${S}D`);if(p.kernelShape.reduce((A,$)=>A+$,0)>0&&p.kernelShape.length!==0&&p.kernelShape.length!==c[1].dims.length-2)throw new Error("invalid kernel shape");if(p.outputShape.length!==0&&p.outputShape.length!==c[0].dims.length-2)throw new Error("invalid output shape")},f0=(c,p,g,b)=>{let x=c.kernelCustomData.wT??c.compute(Nr(p[1],[2,3,0,1]),{inputs:[1],outputs:[g.wIsConst?-2:-1]})[0];g.wIsConst&&!c.kernelCustomData.wT&&(c.kernelCustomData.wT=x);let S=[p[0],x];p.length===3&&S.push(p[2]),c.compute(tT(S,g,b),{inputs:S})},oT=(c,p)=>{let g=p.format==="NHWC",b=[c.inputs[0].reshape(g?[c.inputs[0].dims[0],1,c.inputs[0].dims[1],c.inputs[0].dims[2]]:[c.inputs[0].dims[0],c.inputs[0].dims[1],1,c.inputs[0].dims[2]]),c.inputs[1].reshape([c.inputs[1].dims[0],c.inputs[1].dims[1],1,c.inputs[1].dims[2]])];c.inputs.length===3&&b.push(c.inputs[2]);let x=p.kernelShape;(x.length===0||x[0]===0)&&(x=[c.inputs[1].dims[2]]);let S=p.dilations;(S.length===0||S[0]===0)&&(S=[1]);let A=p.strides;(A.length===0||A[0]===0)&&(A=[1]);let $=p.pads;$.length===0&&($=[0,0]),$=[0,$[0],0,$[1]],A=[1].concat(A),S=[1].concat(S),x=[1].concat(x);let D=p.outputPadding;D=[0].concat(D);let k=p0({...p,pads:$,strides:A,dilations:S,kernelShape:x,outputPadding:D},b);f0(c,b,k,O=>g?[O[0],O[2],O[3]]:[O[0],O[1],O[3]])},lT=(c,p)=>{if(aT(c.inputs,p),c.inputs[0].dims.length===3)oT(c,p);else{let g=p0(p,c.inputs);f0(c,c.inputs,g)}}}),uT,cT,dT,yP=u(()=>{vt(),Et(),Cn(),Ct(),uT=(c,p,g,b)=>{let x=Ae.size(p),S=p.length,A=Ce("input",c,S),$=ht("output",c,S),D=g.dataType===6?g.getInt32Array()[0]:Number(g.getBigInt64Array()[0]),k=Ae.normalizeAxis(D,S),O=R=>{let V=` i32(${A.indicesGet("inputIndices","uniforms.axis")}) `,F=pt("uniforms.input_shape","uniforms.axis",S),z=b.reverse?V+(b.exclusive?" + 1":""):"0",G=b.reverse?F:V+(b.exclusive?"":" + 1");return`
                ${R.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(A,$)}
                ${R.mainStart()}
                  ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${$.offsetToIndices("global_idx")};
                  var sum = ${$.type.value}(0);
                  let first : i32 = ${z};
                  let last : i32 = ${G};
                  for (var i : i32 = first; i < last; i++) {
                    ${A.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${A.getByIndices("inputIndices")};
                  }
                  ${$.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:b.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:p,dataType:c}],dispatchGroup:{x:Math.ceil(x/64)},programUniforms:[{type:12,data:x},{type:12,data:k},...It(p,p)]}),getShaderSource:O}},cT=(c,p)=>{let g=c.inputs[0].dims,b=c.inputs[0].dataType,x=c.inputs[1];c.compute(uT(b,g,x,p),{inputs:[0]})},dT=c=>{let p=c.exclusive===1,g=c.reverse===1;return rn({exclusive:p,reverse:g})}}),hT,pT,fT,mT,gT,bP=u(()=>{vt(),Et(),Cn(),Ct(),hT=c=>{if(!c||c.length!==1)throw new Error("DepthToSpace requires 1 input.");if(c[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},pT=(c,p,g,b)=>{let x=[];x.push(`fn perm(i: ${b.type.indices}) -> ${g.type.indices} {
    var a: ${g.type.indices};`);for(let S=0;S<p;++S)x.push(g.indicesSet("a",c[S],`i[${S}]`));return x.push("return a;}"),x.join(`
`)},fT=(c,p)=>{let g,b,x,S,A,$,D=p.format==="NHWC",k=p.blocksize,O=p.mode==="DCR";D?([g,b,x,S]=c.dims,A=O?[g,b,x,k,k,S/k**2]:[g,b,x,S/k**2,k,k],$=O?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([g,b,x,S]=[c.dims[0],c.dims[2],c.dims[3],c.dims[1]],A=O?[g,k,k,S/k**2,b,x]:[g,S/k**2,k,k,b,x],$=O?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let R=c.reshape(A),V=R.dims.length,F=c.dataType,z=Ce("a",F,V),G=ht("output",F,V),X=K=>`
  ${K.registerUniform("output_size","u32").declareVariables(z,G)}

  ${pT($,V,z,G)}

  ${K.mainStart()}
    ${K.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${G.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${G.setByOffset("global_idx",z.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${c.dims};${p.blocksize};${p.mode}`,inputDependencies:["rank"]},getRunData:K=>{let q=D?[g,b*k,x*k,S/k**2]:[g,S/k**2,b*k,x*k],te=Ae.size(q),ee=R.dims,re=Ae.sortBasedOnPerm(ee,$);return{outputs:[{dims:q,dataType:K[0].dataType}],dispatchGroup:{x:Math.ceil(te/64)},programUniforms:[{type:12,data:te},...It(ee,re)]}},getShaderSource:X}},mT=(c,p)=>{hT(c.inputs),c.compute(fT(c.inputs[0],p))},gT=c=>rn({blocksize:c.blocksize,mode:c.mode,format:c.format})}),Gh,tc,m0,IT,yT,bT,xT,g0,NT,wT,AT,xP=u(()=>{vt(),Et(),Cn(),Ct(),Gh="[a-zA-Z]|\\.\\.\\.",tc="("+Gh+")+",m0="^"+tc+"$",IT="("+tc+",)*"+tc,yT="^"+IT+"$",bT=class{constructor(c=-1){this.symbolToIndices=new Map,this.inputIndex=c}addSymbol(c,p){let g=this.symbolToIndices.get(c);g===void 0?g=[p]:g.push(p),this.symbolToIndices.set(c,g)}},xT=class{constructor(c,p){var x;this.equation=p,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[g,b]=p.includes("->")?p.split("->",2):[p,""];if(!g.match(RegExp(yT)))throw new Error("Invalid LHS term");if(g.split(",").forEach((S,A)=>{let $=c[A].dims.slice();if(!S.match(RegExp(m0)))throw new Error("Invalid LHS term");let D=this.processTerm(S,!0,$,A);this.lhs.push(D)}),b==="")b+=[...this.symbolToInfo.entries()].filter(([S,A])=>A.count===1||S==="...").map(([S])=>S).join("");else if(!b.match(RegExp(tc)))throw new Error("Invalid RHS");(x=b.match(RegExp(Gh,"g")))==null||x.forEach(S=>{if(S==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let A=this.symbolToInfo.get(S);if(A===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(A.dimValue)}}),this.rhs=this.processTerm(b,!1,this.outputDims)}addSymbol(c,p,g){let b=this.symbolToInfo.get(c);if(b!==void 0){if(b.dimValue!==p&&b.count!==1)throw new Error("Dimension mismatch");b.count++,b.inputIndices.push(g)}else b={count:1,dimValue:p,inputIndices:[g]};this.symbolToInfo.set(c,b)}processTerm(c,p,g,b=-1){let x=g.length,S=!1,A=[],$=0;if(!c.match(RegExp(m0))&&!p&&c!=="")throw new Error("Invalid LHS term");let D=c.match(RegExp(Gh,"g")),k=new bT(b);return D==null||D.forEach((O,R)=>{if(O==="..."){if(S)throw new Error("Only one ellipsis is allowed per input term");S=!0;let V=x-D.length+1;if(V<0)throw new Error("Ellipsis out of bounds");if(A=g.slice($,$+V),this.hasEllipsis){if(this.ellipsisDims.length!==A.length||this.ellipsisDims.toString()!==A.toString())throw new Error("Ellipsis dimensions mismatch")}else if(p)this.hasEllipsis=!0,this.ellipsisDims=A;else throw new Error("Ellipsis must be specified in the LHS");for(let F=0;F<A.length;F++){let z=String.fromCharCode(48+F);k.addSymbol(z,R+F),this.addSymbol(z,g[$++],b)}}else k.addSymbol(O,R+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(O,g[$++],b)}),k}},g0=c=>c+"_max",NT=(c,p,g,b)=>{let x=c.map(k=>k.length).map((k,O)=>Ce(`input${O}`,p,k)),S=Ae.size(b),A=ht("output",p,b.length),$=[...g.symbolToInfo.keys()].filter(k=>!g.rhs.symbolToIndices.has(k)),D=k=>{let O=[],R="var prod = 1.0;",V="var sum = 0.0;",F="sum += prod;",z=[],G=[],X=[],K=[],q=g.symbolToInfo.size===g.rhs.symbolToIndices.size;g.symbolToInfo.forEach((ee,re)=>{var me;if(g.rhs.symbolToIndices.has(re)){let Ne=(me=g.rhs.symbolToIndices.get(re))==null?void 0:me[0];Ne!==void 0&&g.lhs.forEach((Ve,Ke)=>{if(ee.inputIndices.includes(Ke)){let lt=Ve.symbolToIndices.get(re);if(lt===void 0)throw new Error("Invalid symbol error");lt.forEach(_t=>{O.push(`${x[Ke].indicesSet(`input${Ke}Indices`,_t,A.indicesGet("outputIndices",Ne))}`)})}})}else g.lhs.forEach((Ne,Ve)=>{if(ee.inputIndices.includes(Ve)){let Ke=Ne.symbolToIndices.get(re);if(Ke===void 0)throw new Error("Invalid symbol error");Ke.forEach(lt=>{z.push(`${x[Ve].indicesSet(`input${Ve}Indices`,lt,`${re}`)}`)}),K.push(`prod *= ${x[Ve].getByIndices(`input${Ve}Indices`)};`)}}),G.push(`for(var ${re}: u32 = 0; ${re} < uniforms.${g0(re)}; ${re}++) {`),X.push("}")});let te=q?[...O,`let sum = ${x.map((ee,re)=>ee.getByIndices(`input${re}Indices`)).join(" * ")};`]:[...O,V,...G,...z,R,...K,F,...X];return`
            ${k.registerUniforms($.map(ee=>({name:`${g0(ee)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...x,A)}

            ${k.mainStart()}
            ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${A.offsetToIndices("global_idx")};
            ${x.map((ee,re)=>`var input${re}Indices: ${x[re].type.indices};`).join(`
`)}
            ${te.join(`
`)};
            ${A.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:g.equation,inputDependencies:c.map(()=>"rank")},getRunData:()=>{let k=$.filter(R=>g.symbolToInfo.has(R)).map(R=>{var V;return{type:12,data:((V=g.symbolToInfo.get(R))==null?void 0:V.dimValue)||0}});k.push({type:12,data:S});let O=c.map((R,V)=>[...It(R)]).reduce((R,V)=>R.concat(V),k);return O.push(...It(b)),{outputs:[{dims:b,dataType:p}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:O}},getShaderSource:D}},wT=(c,p)=>{let g=new xT(c.inputs,p.equation),b=g.outputDims,x=c.inputs.map((S,A)=>S.dims);c.compute(NT(x,c.inputs[0].dataType,g,b))},AT=c=>{let p=c.equation.replace(/\s+/g,"");return rn({equation:p})}}),TT,I0,ST,vT,$T,NP=u(()=>{vt(),Et(),Ct(),TT=c=>{if(!c||c.length!==2)throw new Error("Expand requires 2 input.");let p=c[0].dims,g=Array.from(c[1].getBigInt64Array(),Number),b=g.length<p.length?0:g.length-p.length,x=p.length<g.length?0:p.length-g.length;for(;b<g.length&&x<p.length;++b,++x)if(g[b]!==p[x]&&g[b]!==1&&p[x]!==1)throw new Error("Expand requires shape to be broadcastable to input")},I0=(c,p)=>{let g=c.length-p.length,b=[];for(let x=0;x<g;++x)b.push(c[x]);for(let x=0;x<p.length;++x)b.push(p[x]===1?c[x+g]:p[x]);return b},ST=(c,p)=>c.length>p.length?I0(c,p):I0(p,c),vT=c=>{let p=c[0].dims,g=Array.from(c[1].getBigInt64Array(),Number),b=ST(p,g),x=c[0].dataType,S=x===9||Ae.size(p)===1,A=x===9||p.length>0&&p[p.length-1]%4===0?4:1,$=S||b.length>0&&b[b.length-1]%4===0?4:1,D=Math.ceil(Ae.size(b)/$),k=R=>{let V=Ce("input",x,p.length,A),F=ht("output",x,b.length,$),z;if(x===9){let G=(X,K,q="")=>`
          let outputIndices${K} = ${F.offsetToIndices(`outputOffset + ${K}u`)};
          let offset${K} = ${V.broadcastedIndicesToOffset(`outputIndices${K}`,F)};
          let index${K} = offset${K} / 4u;
          let component${K} = offset${K} % 4u;
          ${X}[${K}] = ${q}(${V.getByOffset(`index${K}`)}[component${K}]);
        `;z=`
        let outputOffset = global_idx * ${$};
        var data = vec4<u32>(0);
        ${G("data",0,"u32")}
        ${G("data",1,"u32")}
        ${G("data",2,"u32")}
        ${G("data",3,"u32")}
        ${F.setByOffset("global_idx","data")}
      }`}else z=`
        let outputIndices = ${F.offsetToIndices(`global_idx * ${$}`)};
        let inputOffset = ${V.broadcastedIndicesToOffset("outputIndices",F)};
        let data = ${F.type.value}(${V.getByOffset(`inputOffset / ${A}`)});
        ${F.setByOffset("global_idx","data")}
      }`;return`
    ${R.registerUniform("vec_size","u32").declareVariables(V,F)}
    ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${z}`},O=[{type:12,data:D},...It(p,b)];return{name:"Expand",shaderCache:{hint:`${b.length};${A}${$}`,inputDependencies:["rank"]},getShaderSource:k,getRunData:()=>({outputs:[{dims:b,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(D/64)},programUniforms:O})}},$T=c=>{TT(c.inputs),c.compute(vT(c.inputs),{inputs:[0]})}}),_T,DT,wP=u(()=>{vt(),Et(),Ct(),Jg(),_T=c=>{let p=c[0].dataType,g=Ae.size(c[0].dims),b=Ae.size(c[1].dims),x=b%4===0,S=A=>{let $=Ce("x",p,[1],4),D=Ce("bias",p,[1],4),k=ht("y",p,[1],4),O=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],R=F=>`
      let bias${F}_offset: u32 = (global_idx * 4 + ${F}) % uniforms.bias_size;
      let bias${F} = ${D.getByOffset(`bias${F}_offset / 4`)}[bias${F}_offset % 4];`,V=x?`
      let bias = ${D.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${R(0)}${R(1)}${R(2)}${R(3)}
      let bias = ${$.type.value}(bias0, bias1, bias2, bias3);`;return`${A.registerUniforms(O).declareVariables($,D,k)}

    ${Zg(Es(p))}

    ${A.mainStart(Vl)}
      ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${$.getByOffset("global_idx")};
      ${V}
      let x_in = x + bias;
      ${k.setByOffset("global_idx",Qg("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${x}`,inputDependencies:["type","type"]},getShaderSource:S,getRunData:A=>({outputs:[{dims:A[0].dims,dataType:A[0].dataType}],programUniforms:[{type:12,data:Math.ceil(g/4)},{type:12,data:b}],dispatchGroup:{x:Math.ceil(g/Vl/4)}})}},DT=c=>{c.inputs.length<2||Ae.size(c.inputs[1].dims)===0?uA(c):c.compute(_T(c.inputs))}}),ET,kT,CT,LT,AP=u(()=>{vt(),Et(),Cn(),Ct(),ET=c=>{if(!c||c.length!==2)throw new Error("Gather requires 2 inputs.")},kT=(c,p)=>{let g=c[0].dims,b=c[1].dims,x=g.length,S=Ae.normalizeAxis(p.axis,x),A=g.slice(0);A.splice(S,1,...b);let $=g[S],D=c[0].dataType===9?4:1,k=Math.ceil(Ae.size(A)/D),O=[{type:12,data:k},{type:6,data:$},{type:12,data:S},...It(c[0].dims,c[1].dims,A)],R=V=>{let F=Ce("data",c[0].dataType,c[0].dims.length,D),z=Ce("inputIndices",c[1].dataType,c[1].dims.length),G=ht("output",c[0].dataType,A.length,D),X=q=>{let te=b.length,ee=`var indicesIndices${q}  = ${z.type.indices}(0);`;for(let re=0;re<te;re++)ee+=`${te>1?`indicesIndices${q}[${re}]`:`indicesIndices${q}`} = ${A.length>1?`outputIndices${q}[uniforms.axis + ${re}]`:`outputIndices${q}`};`;ee+=`
          var idx${q} = ${z.getByIndices(`indicesIndices${q}`)};
          if (idx${q} < 0) {
            idx${q} = idx${q} + uniforms.axisDimLimit;
          }
          var dataIndices${q} : ${F.type.indices};
        `;for(let re=0,me=0;re<x;re++)re===S?(ee+=`${x>1?`dataIndices${q}[${re}]`:`dataIndices${q}`} = u32(idx${q});`,me+=te):(ee+=`${x>1?`dataIndices${q}[${re}]`:`dataIndices${q}`} = ${A.length>1?`outputIndices${q}[${me}]`:`outputIndices${q}`};`,me++);return ee},K;if(c[0].dataType===9){let q=(te,ee,re="")=>`
          let outputIndices${ee} = ${G.offsetToIndices(`outputOffset + ${ee}u`)};
          ${X(ee)};
          let offset${ee} = ${F.indicesToOffset(`dataIndices${ee}`)};
          let index${ee} = offset${ee} / 4u;
          let component${ee} = offset${ee} % 4u;
          ${te}[${ee}] = ${re}(${F.getByOffset(`index${ee}`)}[component${ee}]);
        `;K=`
        let outputOffset = global_idx * ${D};
        var value = vec4<u32>(0);
        ${q("value",0,"u32")}
        ${q("value",1,"u32")}
        ${q("value",2,"u32")}
        ${q("value",3,"u32")}
        ${G.setByOffset("global_idx","value")}
      `}else K=`
      let outputIndices = ${G.offsetToIndices("global_idx")};
      ${X("")};
      let value = ${F.getByIndices("dataIndices")};
      ${G.setByOffset("global_idx","value")};
      `;return`
      ${V.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(F,z,G)}
      ${V.mainStart()}
        ${V.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${K}
      }`};return{name:"Gather",shaderCache:{hint:p.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:A,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(k/64)},programUniforms:O}),getShaderSource:R}},CT=c=>rn({axis:c.axis}),LT=(c,p)=>{let g=c.inputs;ET(g),c.compute(kT(c.inputs,p))}}),OT,RT,VT,TP=u(()=>{vt(),Et(),Ct(),OT=(c,p,g,b,x,S,A,$,D)=>{let k=[{type:12,data:S},{type:12,data:b},{type:12,data:x},{type:12,data:g},{type:12,data:A},{type:12,data:$},{type:12,data:D}],O=[S];k.push(...It(p.dims,O));let R=V=>{let F=Ce("indices_data",p.dataType,p.dims.length),z=ht("input_slice_offsets_data",12,1,1),G=[F,z],X=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:x.length},{name:"sizes_from_slice_dims_data",type:"u32",length:g.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${V.registerUniforms(X).declareVariables(...G)}
  ${V.mainStart()}
    ${V.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${x.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${g.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return c.compute({name:"computeSliceOffsets",shaderCache:{hint:`${x.length}_${g.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:O,dataType:c.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:k}),getShaderSource:R},{inputs:[p],outputs:[-1]})[0]},RT=(c,p)=>{let g=c.inputs,b=g[0].dims,x=g[0].dataType,S=g[1].dims,A=S[S.length-1],$=Ae.sizeToDimension(S,S.length-1),D=Ae.sizeFromDimension(b,p.batchDims+A),k=Ae.sizeToDimension(b,p.batchDims),O=Ae.sizeFromDimension(b,p.batchDims),R=$/k,V=new Array(A),F=D;for(let ee=0;ee<A;++ee)V[A-1-ee]=F,F*=b[p.batchDims+A-1-ee];let z=OT(c,g[1],V,p.batchDims,b,$,R,O,A),G=p.batchDims+A;if(G>b.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let X=S.slice(0,-1).concat(b.slice(G)),K=Ae.size(X),q=[{type:12,data:K},{type:12,data:D},...It(g[0].dims,z.dims,X)],te=ee=>{let re=Ce("data",g[0].dataType,g[0].dims.length),me=Ce("slice_offsets",12,z.dims.length),Ne=ht("output",g[0].dataType,X.length);return`
          ${ee.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(re,me,Ne)}
            ${ee.mainStart()}
            ${ee.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};c.compute({name:"GatherND",shaderCache:{hint:p.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:X,dataType:x}],dispatchGroup:{x:Math.ceil(K/64)},programUniforms:q}),getShaderSource:te},{inputs:[g[0],z]})},VT=c=>({batchDims:c.batch_dims,cacheKey:""})}),PT,FT,zT,MT,SP=u(()=>{vt(),Et(),Cn(),Ct(),PT=(c,p)=>{if(c.length<3||c.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let g=Ae.normalizeAxis(p.quantizeAxis,c[0].dims.length),b=p.blockSize,x=c[0],S=c[2],A=c.length===4?c[3]:void 0;if(S.dims.length!==x.dims.length||!x.dims.map(($,D)=>D===g?Math.ceil($/b)===S.dims[D]:$===S.dims[D]).reduce(($,D)=>$&&D,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(A){if(A.dataType!==x.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(A.dims.length!==S.dims.length||!A.dims.map(($,D)=>$===S.dims[D]).reduce(($,D)=>$&&D,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},FT=(c,p)=>{let g=c[0].dims,b=c[1].dims,x=g.length,S=Ae.normalizeAxis(p.gatherAxis,x),A=Ae.normalizeAxis(p.quantizeAxis,x),$=g.slice(0);$.splice(S,1,...b);let D=Ae.size($),k=c[2].dataType,O=c[0].dataType===22,R=[{type:12,data:D},{type:12,data:A},{type:12,data:S},{type:12,data:p.blockSize},...It(...c.map((F,z)=>F.dims),$)],V=F=>{let z=Ce("data",c[0].dataType,c[0].dims.length),G=Ce("inputIndices",c[1].dataType,c[1].dims.length),X=Ce("scales",c[2].dataType,c[2].dims.length),K=c.length>3?Ce("zeroPoint",c[3].dataType,c[3].dims.length):void 0,q=ht("output",k,$.length),te=[z,G,X];K&&te.push(K);let ee=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${F.registerUniforms(ee).declareVariables(...te,q)}
        ${F.mainStart()}
        let output_indices = ${q.offsetToIndices("global_idx")};
        var indices_indices = ${G.type.indices}(0);
        ${b.length>1?`
          for (var i: u32 = 0; i < ${b.length}; i++) {
            let index = ${q.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${G.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${q.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${z.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${q.indicesGet("output_indices","i")};
          ${z.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${G.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${g[S]};
        }
        ${z.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${$.length}; i++) {
          let index = ${q.indicesGet("output_indices",`i + ${b.length} - 1`)};
          ${z.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${z.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${z.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${O?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${X.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${X.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${X.getByIndices("scale_indices")};
        ${K?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${K.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${K.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${O?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Es(k)}(quantized_data - zero_point) * scale;
        ${q.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${p.cacheKey};${c.filter((F,z)=>z!==1).map(F=>F.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:c.length},(F,z)=>"rank")},getRunData:()=>({outputs:[{dims:$,dataType:k}],dispatchGroup:{x:Math.ceil(D/64)},programUniforms:R}),getShaderSource:V}},zT=(c,p)=>{let g=c.inputs;PT(g,p),c.compute(FT(c.inputs,p))},MT=c=>rn({blockSize:c.blockSize,gatherAxis:c.gatherAxis,quantizeAxis:c.quantizeAxis})}),WT,BT,HT,UT,vP=u(()=>{vt(),Et(),Cn(),Ct(),WT=c=>{if(!c||c.length!==2)throw new Error("GatherElements requires 2 inputs.");if(c[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(c[0].dims.length!==c[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},BT=(c,p)=>{let g=c[0].dims,b=c[0].dataType,x=g.length,S=c[1].dims,A=c[1].dataType,$=Ae.normalizeAxis(p.axis,x),D=g[$],k=S.slice(0),O=Ae.size(k),R=Ce("input",b,x),V=Ce("indicesInput",A,S.length),F=ht("output",b,k.length),z=[{type:12,data:O},{type:6,data:D},{type:12,data:$}];return z.push(...It(g,S,k)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:k,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(O/64)},programUniforms:z}),getShaderSource:G=>`
      ${G.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(R,V,F)}
      ${G.mainStart()}
      ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${F.offsetToIndices("global_idx")};

      var idx = ${V.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${R.type.indices}(outputIndices);
      ${R.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${R.getByIndices("inputIndices")};

      ${F.setByOffset("global_idx","value")};
  }`}},HT=c=>rn({axis:c.axis}),UT=(c,p)=>{let g=c.inputs;WT(g),c.compute(BT(c.inputs,p))}}),GT,qT,KT,jT,$P=u(()=>{vt(),Et(),Ct(),GT=c=>{if(!c)throw new Error("Input is missing");if(c.length<2||c.length>3)throw new Error("Invaid input number.");if(c.length===3&&c[2].dims.length>2)throw new Error("Invalid input shape of C");if(c[0].dataType!==c[1].dataType||c.length===3&&c[0].dataType!==c[2].dataType)throw new Error("Input types are mismatched")},qT=(c,p)=>{let g=c[0].dims.slice(),b=c[1].dims.slice(),[x,S,A]=mN.getShapeOfGemmResult(g,p.transA,b,p.transB,c.length===3?c[2].dims:void 0),$=[x,S];if(!$)throw new Error("Can't use gemm on the given tensors");let D=16,k=Math.ceil(S/D),O=Math.ceil(x/D),R=!0,V=Ae.size($),F=[{type:12,data:R?k:V},{type:12,data:x},{type:12,data:S},{type:12,data:A},{type:1,data:p.alpha},{type:1,data:p.beta}],z=["type","type"];c.length===3&&(F.push(...It(c[2].dims)),z.push("rank")),F.push(...It($));let G=K=>{let q="";p.transA&&p.transB?q="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":p.transA&&!p.transB?q="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!p.transA&&p.transB?q="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!p.transA&&!p.transB&&(q="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let te=p.alpha===1?"":"value *= uniforms.alpha;",ee=Ce("a",c[0].dataType,c[0].dims),re=Ce("b",c[1].dataType,c[1].dims),me=ee.type.value,Ne=null,Ve=[ee,re];c.length===3&&(Ne=Ce("c",c[2].dataType,c[2].dims.length),Ve.push(Ne));let Ke=ht("output",c[0].dataType,$.length);Ve.push(Ke);let lt=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${K.registerUniforms(lt).declareVariables(...Ve)}

  ${K.mainStart()}
    ${K.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${me}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${q}
    }

    ${te}
    ${Ne!=null?`let cOffset = ${Ne.broadcastedIndicesToOffset("vec2(m, n)",Ke)}; value += ${me}(uniforms.beta) * ${Ne.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},X=K=>{let q=Ce("a",c[0].dataType,c[0].dims),te=Ce("b",c[1].dataType,c[1].dims),ee=null,re=[q,te];c.length===3&&(ee=Ce("c",c[2].dataType,c[2].dims.length),re.push(ee));let me=ht("output",c[0].dataType,$.length);re.push(me);let Ne=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],Ve="",Ke="";p.transA&&p.transB?(Ke=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${q.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${te.type.value}(0);
      }
      `,Ve="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):p.transA&&!p.transB?(Ke=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${q.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${te.type.value}(0);
      }
      `,Ve="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!p.transA&&p.transB?(Ke=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${q.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${te.type.value}(0);
      }
      `,Ve="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!p.transA&&!p.transB&&(Ke=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${q.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${te.type.value}(0);
      }
      `,Ve="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let lt=p.alpha===1?"":"value *= uniforms.alpha;";return`
  ${K.registerUniforms(Ne).declareVariables(...re)}
  var<workgroup> tile_a: array<array<${q.type.storage}, ${D}>, ${D}>;
  var<workgroup> tile_b: array<array<${te.type.storage}, ${D}>, ${D}>;
  ${K.mainStart([D,D,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${D};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${D};
    let num_tiles = (uniforms.K - 1) / ${D} + 1;
    var k_start = 0u;
    var value = ${me.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${Ke}
      k_start = k_start + ${D};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${D}; k++) {
        ${Ve}
      }
      workgroupBarrier();
    }

    ${lt}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${ee!=null?`let cOffset = ${ee.broadcastedIndicesToOffset("vec2(m, n)",me)}; value += ${me.type.value}(uniforms.beta) * ${ee.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return R?{name:"GemmShared",shaderCache:{hint:`${p.cacheKey}`,inputDependencies:z},getRunData:()=>({outputs:[{dims:$,dataType:c[0].dataType}],dispatchGroup:{x:k*O},programUniforms:F}),getShaderSource:X}:{name:"Gemm",shaderCache:{hint:`${p.cacheKey}`,inputDependencies:z},getRunData:()=>({outputs:[{dims:$,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(V/64)},programUniforms:F}),getShaderSource:G}},KT=c=>{let p=c.transA,g=c.transB,b=c.alpha,x=c.beta;return{transA:p,transB:g,alpha:b,beta:x,cacheKey:`${c.transA};${c.transB};${c.alpha===1}`}},jT=(c,p)=>{GT(c.inputs),c.compute(qT(c.inputs,p))}}),$i,Ji,vo,$o,YT,XT,ZT,QT,JT,eS,tS,nS,sS,rS,_P=u(()=>{vt(),Et(),Cn(),Ct(),[$i,Ji,vo,$o]=[0,1,2,3],YT=c=>{if(c[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(c[0].dims.length!==c[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(c[0].dims.length-2!==c[1].dims[c[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${c[0].dims.length-2}`);if(c[0].dims[0]!==c[1].dims[0])throw new Error("grid batch size must match input batch size")},XT=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,ZT=c=>`
  fn gs_bicubic_interpolate(p: mat4x4<${c}>, x: f32, y: f32) -> ${c} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${c}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,QT=c=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${c.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,JT=c=>`
  ${c.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,eS=(c,p,g)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${p} {
     var pixel = ${p}(0);
     var indices = vec4<u32>(0);
     indices[${$i}] = batch;
     indices[${Ji}] = channel;`+(()=>{switch(g.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${vo}] = u32(r);
            indices[${$o}] = u32(c);
          }
        `;case"border":return`
          indices[${vo}] = u32(clamp(r, 0, H - 1));
          indices[${$o}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${vo}] = gs_reflect(r, border[1], border[3]);
          indices[${$o}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${g.paddingMode} is not supported`)}})()+`
    return ${c.getByIndices("indices")};
  }
`,tS=(c,p,g)=>(()=>{switch(g.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${$i}], indices[${Ji}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${$i}], indices[${Ji}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${$i}], indices[${Ji}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${$i}], indices[${Ji}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${$i}], indices[${Ji}], border);

          let dx2 = ${p}(f32(x2) - x);
          let dx1 = ${p}(x - f32(x1));
          let dy2 = ${p}(f32(y2) - y);
          let dy1 = ${p}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${p}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${$i}], indices[${Ji}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${g.mode} is not supported`)}})()+`${c.setByOffset("global_idx","result")}`,nS=(c,p)=>{let g=Ce("x",c[0].dataType,c[0].dims.length),b=[c[1].dims[0],c[1].dims[1],c[1].dims[2]],x=Ce("grid",c[1].dataType,b.length,2),S=[c[0].dims[0],c[0].dims[1],c[1].dims[1],c[1].dims[2]];p.format==="NHWC"&&(S=[c[0].dims[0],c[1].dims[1],c[1].dims[2],c[0].dims[3]],[$i,Ji,vo,$o]=[0,3,1,2]);let A=ht("output",c[0].dataType,S.length),$=g.type.value,D=Ae.size(S),k=[{type:12,data:D},...It(c[0].dims,b,S)],O=R=>`
  ${R.registerUniform("output_size","u32").declareVariables(g,x,A)}
  ${XT}
  ${ZT($)}
  ${QT(p)}
  ${JT(p)}
  ${eS(g,$,p)}

  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${vo}]);
      let W_in = i32(uniforms.x_shape[${$o}]);

      ${p.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${A.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${$i}], indices[${vo}], indices[${$o}]);
      let nxy = ${x.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${tS(A,$,p)}
  }`;return{name:"GridSample",shaderCache:{hint:`${p.cacheKey}`,inputDependencies:["type","type"]},getRunData:R=>{let V=Ae.size(S);return{outputs:[{dims:S,dataType:R[0].dataType}],dispatchGroup:{x:Math.ceil(V/64)},programUniforms:k}},getShaderSource:O}},sS=(c,p)=>{YT(c.inputs),c.compute(nS(c.inputs,p))},rS=c=>rn({alignCorners:c.align_corners,mode:c.mode,paddingMode:c.padding_mode,format:c.format})}),qs,iS,aS,y0,oS,nc,lS,uS=u(()=>{vt(),Et(),Cn(),Fg(),Yg(),Ct(),Sa(),qs=(c,p)=>c.length>p&&c[p].dims.length>0?c[p]:void 0,iS=(c,p)=>{let g=c[0],b=qs(c,1),x=qs(c,2),S=qs(c,3),A=qs(c,4),$=qs(c,5),D=qs(c,6),k=qs(c,7);if(g.dims.length!==3&&g.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let O=g.dims[0],R=g.dims[1],V=g.dims.length===3?g.dims[2]:p.numHeads*g.dims[4],F=R,z=0,G=0,X=Math.floor(V/p.numHeads);if(D&&k&&Ae.size(D.dims)&&Ae.size(k.dims)){if(D.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(D.dims[0]!==O||D.dims[1]!==p.numHeads||D.dims[3]!==X)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(k.dims[0]!==O||k.dims[1]!==p.numHeads||k.dims[3]!==X)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(D.dims[2]!==k.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(k.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');z=D.dims[2],G=D.dims[2]}else if(D&&Ae.size(D.dims)||k&&Ae.size(k.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let K;if(b&&Ae.size(b.dims)>0){if(g.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(b.dims.length<3||b.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(g.dims[0]!==b.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(b.dims.length===3){if(b.dims[2]!==g.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');K=2,F=b.dims[1]}else if(b.dims.length===5){if(b.dims[2]!==p.numHeads||b.dims[3]!==2||b.dims[4]!==X)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(x)throw new Error('Expect "value" be none when "key" has packed kv format.');K=5,F=b.dims[1]}else{if(b.dims[1]!==p.numHeads||b.dims[3]!==X)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');K=0,F=b.dims[2]}}else{if(g.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(g.dims[2]!==p.numHeads||g.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');K=3}if(S&&Ae.size(S.dims)>0){if(S.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(b&&b.dims.length===5&&b.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let q=z+F,te=0;if(A&&Ae.size(A.dims)>0){te=8;let Ne=A.dims;throw Ne.length===1?Ne[0]===O?te=1:Ne[0]===3*O+2&&(te=3):Ne.length===2&&Ne[0]===O&&Ne[1]===q&&(te=5),te===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let ee=!1,re=V;if(x&&Ae.size(x.dims)>0){if(x.dims.length!==3&&x.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(g.dims[0]!==x.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(x.dims.length===3){if(F!==x.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');re=x.dims[2]}else{if(F!==x.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');re=x.dims[1]*x.dims[3],ee=!0}}let me=!1;if(A&&Ae.size(A.dims)>0)throw new Error("Key padding mask is not supported");if($&&Ae.size($.dims)>0){if($.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if($.dims[0]!==O||$.dims[1]!==p.numHeads||$.dims[2]!==R||$.dims[3]!==q)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:O,sequenceLength:R,pastSequenceLength:z,kvSequenceLength:F,totalSequenceLength:q,maxSequenceLength:G,inputHiddenSize:0,hiddenSize:V,vHiddenSize:re,headSize:X,vHeadSize:Math.floor(re/p.numHeads),numHeads:p.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:p.maskFilterValue,maskType:te,scale:p.scale,broadcastResPosBias:me,passPastInKv:ee,qkvFormat:K}},aS=c=>rn({...c}),y0=rn({perm:[0,2,1,3]}),oS=(c,p,g,b,x,S,A)=>{let $=[b,x,S],D=Ae.size($),k=[{type:12,data:D},{type:12,data:A},{type:12,data:S}],O=R=>{let V=ht("qkv_with_bias",p.dataType,$),F=Ce("qkv",p.dataType,$),z=Ce("bias",g.dataType,$),G=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${R.registerUniforms(G).declareVariables(F,z,V)}
  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return c.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:$,dataType:p.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(D/64)},programUniforms:k}),getShaderSource:O},{inputs:[p,g],outputs:[-1]})[0]},nc=(c,p,g,b,x,S,A,$)=>{let D=S;if(A&&Ae.size(A.dims)>0){if(b===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return D=oS(c,S,A,p,b,g*x,$),D=D.reshape([p,b,g,x]),g===1||b===1?D:c.compute(Nr(D,y0.perm),{inputs:[D],outputs:[-1]})[0]}else return S.dims.length===3&&(D=S.reshape([p,b,g,x])),g===1||b===1?D:c.compute(Nr(D,y0.perm),{inputs:[D],outputs:[-1]})[0]},lS=(c,p)=>{let g=iS(c.inputs,p),b=c.inputs[0],x=qs(c.inputs,1),S=qs(c.inputs,2),A=qs(c.inputs,3),$=qs(c.inputs,4),D=qs(c.inputs,5),k=qs(c.inputs,6),O=qs(c.inputs,7);if(b.dims.length===5)throw new Error("Packed QKV is not implemented");if((x==null?void 0:x.dims.length)===5)throw new Error("Packed KV is not implemented");let R=x&&S&&x.dims.length===4&&S.dims.length===4,V=nc(c,g.batchSize,g.numHeads,g.sequenceLength,g.headSize,b,A,0);if(R)return Zu(c,V,x,S,$,void 0,k,O,D,g);if(!x||!S)throw new Error("key and value must be provided");let F=nc(c,g.batchSize,g.numHeads,g.kvSequenceLength,g.headSize,x,A,g.hiddenSize),z=nc(c,g.batchSize,g.numHeads,g.kvSequenceLength,g.vHeadSize,S,A,2*g.hiddenSize);Zu(c,V,F,z,$,void 0,k,O,D,g)}}),cS,dS,hS,pS,b0,fS,mS,gS=u(()=>{vt(),Et(),Cn(),Ct(),cS=c=>{if(!c||c.length<1)throw new Error("too few inputs")},dS=(c,p)=>{let g=[],b=p.numOutputs;return c[1].dims[0]>0&&(c[1].getBigInt64Array().forEach(x=>g.push(Number(x))),b=g.length),rn({numOutputs:b,axis:p.axis,splitSizes:g})},hS=c=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${c}u; i += 1u ) {
    if (index < ${pt("uniforms.size_in_split_axis","i",c)}) {
        return i;
    }
    }
    return ${c}u;
}`,pS=c=>{let p=c.length,g=[];for(let b=0;b<p;++b){let x=c[b].setByIndices("indices","input[global_idx]");p===1?g.push(x):b===0?g.push(`if (output_number == ${b}u) { ${x} }`):b===p-1?g.push(`else { ${x} }`):g.push(`else if (output_number == ${b}) { ${x} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${c[0].type.indices}, global_idx: u32) {
        ${g.join(`
`)}
      }`},b0=(c,p)=>{let g=c[0].dims,b=Ae.size(g),x=c[0].dataType,S=Ae.normalizeAxis(p.axis,g.length),A=new Array(p.numOutputs),$=Ce("input",x,g.length),D=new Array(p.numOutputs),k=[],O=[],R=0,V=[{type:12,data:b}];for(let z=0;z<p.numOutputs;z++){R+=p.splitSizes[z],D[z]=R;let G=g.slice();G[S]=p.splitSizes[z],O.push(G),A[z]=ht(`output${z}`,x,G.length),k.push({dims:O[z],dataType:c[0].dataType})}V.push({type:12,data:D},...It(g,...O));let F=z=>`
  ${z.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",D.length).declareVariables($,...A)}
  ${hS(D.length)}
  ${pS(A)}

  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${$.offsetToIndices("global_idx")};
    var index = ${$.indicesGet("indices",S)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${pt("uniforms.size_in_split_axis","output_number - 1u",D.length)};
      ${$.indicesSet("indices",S,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:p.cacheKey,inputDependencies:["rank"]},getShaderSource:F,getRunData:()=>({outputs:k,dispatchGroup:{x:Math.ceil(b/64)},programUniforms:V})}},fS=(c,p)=>{cS(c.inputs);let g=c.inputs.length===1?p:dS(c.inputs,p);c.compute(b0(c.inputs,g),{inputs:[0]})},mS=c=>{let p=c.axis,g=c.splitSizes,b=c.numOutputs<0?g.length:c.numOutputs;if(b!==g.length)throw new Error("numOutputs and splitSizes lengh must be equal");return rn({axis:p,numOutputs:b,splitSizes:g})}}),IS,yS,x0,bS,DP=u(()=>{Cn(),Yg(),uS(),gS(),Sa(),IS=(c,p)=>{if(p.doRotary)throw new Error("GroupQuerryAttention do_rotary attribute is not supported");if(p.doRotary&&c.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let g=c[0],b=c[1],x=c[2],S=c[3],A=c[4];if(p.localWindowSize!==-1)throw new Error("Local attention is not supported");if(p.softcap!==0)throw new Error("Softcap is not supported");if(p.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(p.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(g.dims.length!==3&&g.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let $=!1,D=g.dims[0],k=g.dims[1],O=g.dims.length===3?$?g.dims[2]/3:g.dims[2]:p.numHeads*g.dims[4],R=k,V=0,F=!b||b.dims.length===0,z=Math.floor(F?O/(p.numHeads+2*p.kvNumHeads):O/p.numHeads);F&&(O=z*p.numHeads);let G=S&&S.dims.length!==0,X=A&&A.dims.length!==0;if(G&&S.dims.length===4&&S.dims[0]===D&&S.dims[1]!==p.kvNumHeads&&S.dims[2]===p.kvNumHeads&&S.dims[3]===z)throw new Error("BSNH pastKey/pastValue is not supported");if(G&&X){if(S.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(A.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');V=S.dims[2]}else if(G||X)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let K=1;if(b&&b.dims.length>0){if(g.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(b.dims.length<3||b.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(g.dims[0]!==b.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(b.dims.length===3){if(g.dims[2]%b.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');R=b.dims[1]}else if(b.dims.length===5){if(b.dims[2]!==p.numHeads||b.dims[3]!==2||b.dims[4]!==z)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(x)throw new Error('Expect "value" be none when "key" has packed kv format.');R=b.dims[1]}else{if(b.dims[1]!==p.numHeads||b.dims[3]!==z)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');R=b.dims[2]}}else{if(g.dims.length!==3&&g.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(g.dims.length===5&&(g.dims[2]!==p.numHeads||g.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');K=3}let q=0,te=!1,ee=p.kvNumHeads?z*p.kvNumHeads:O;if(x&&x.dims.length>0){if(x.dims.length!==3&&x.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(g.dims[0]!==x.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(x.dims.length===3){if(R!==x.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');ee=x.dims[2]}else{if(R!==x.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');ee=x.dims[1]*x.dims[3],te=!0}}let re=c.length>4?c[5]:void 0;if(re&&re.dims.length!==1&&re.dims[0]!==D)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:D,sequenceLength:k,pastSequenceLength:V,kvSequenceLength:R,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:O,vHiddenSize:ee,headSize:z,vHeadSize:Math.floor(ee/p.kvNumHeads),numHeads:p.numHeads,kvNumHeads:p.kvNumHeads,nReps:p.numHeads/p.kvNumHeads,pastPresentShareBuffer:!1,maskType:q,scale:p.scale,broadcastResPosBias:!1,passPastInKv:te,qkvFormat:K}},yS=rn({perm:[0,2,1,3]}),x0=(c,p,g)=>{let b=p,x=g.kvNumHeads;return p.dims.length===3&&g.kvSequenceLength!==0&&(b=p.reshape([g.batchSize,g.kvSequenceLength,x,g.headSize]),b=c.compute(Nr(b,yS.perm),{inputs:[b],outputs:[-1]})[0]),b},bS=(c,p)=>{var X;let g=IS(c.inputs,p);if(c.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((X=c.inputs[1])==null?void 0:X.dims.length)===5)throw new Error("Packed KV is not implemented");let b=c.inputs[0],x=c.inputs[1]&&c.inputs[1].dims.length>0?c.inputs[1]:void 0,S=c.inputs[2]&&c.inputs[2].dims.length>0?c.inputs[2]:void 0,A=c.inputs[3]&&c.inputs[3].dims.length!==0?c.inputs[3]:void 0,$=c.inputs[4]&&c.inputs[4].dims.length!==0?c.inputs[4]:void 0,D=c.inputs.length>4?c.inputs[5]:void 0,k=c.inputs.length>5?c.inputs[6]:void 0,O=g.kvNumHeads?g.kvNumHeads:g.numHeads,R=rn({axis:2,numOutputs:3,splitSizes:[g.numHeads*g.headSize,O*g.headSize,O*g.headSize]}),[V,F,z]=!x&&!S?c.compute(b0([b],R),{inputs:[b],outputs:[-1,-1,-1]}):[b,x,S],G=nc(c,g.batchSize,g.numHeads,g.sequenceLength,g.headSize,V,void 0,0);Zu(c,G,x0(c,F,g),x0(c,z,g),void 0,void 0,A,$,void 0,g,D,k)}}),N0,xS,NS,wS,EP=u(()=>{vt(),Et(),Sa(),Ct(),N0=(c,p,g,b,x,S,A,$)=>{let D=Sn(S),k=D===1?"f32":`vec${D}f`,O=D===1?"vec2f":`mat2x${D}f`,R=x*A,V=64;R===1&&(V=256);let F=[x,A,S/D],z=[x,A,2],G=["rank","type","type"],X=[];X.push(...It(F,z));let K=q=>{let te=Ce("x",p.dataType,3,D),ee=Ce("scale",g.dataType,g.dims),re=Ce("bias",b.dataType,b.dims),me=ht("output",1,3,2),Ne=[te,ee,re,me];return`
  var<workgroup> workgroup_shared : array<${O}, ${V}>;
  const workgroup_size = ${V}u;
  ${q.declareVariables(...Ne)}
  ${q.mainStart(V)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${k}(0);
    var squared_sum = ${k}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${k}(${te.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${O}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Ta("workgroup_shared[0][0]",D)} / f32(hight * ${D});
      let squared_sum_final = ${Ta("workgroup_shared[0][1]",D)} / f32(hight * ${D});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${$}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return c.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${D};${$};${V}`,inputDependencies:G},getRunData:()=>({outputs:[{dims:z,dataType:1}],dispatchGroup:{x:R},programUniforms:X}),getShaderSource:K},{inputs:[p,g,b],outputs:[-1]})[0]},xS=(c,p,g)=>{let b=p[0].dims,x=b,S=2,A=b[0],$=b[1],D=Ae.sizeFromDimension(b,S),k=Sn(D),O=Ae.size(x)/k,R=N0(c,p[0],p[1],p[2],A,D,$,g.epsilon),V=[A,$,D/k],F=[A,$],z=["type","none"],G=X=>{let K=Ce("x",p[0].dataType,V.length,k),q=Ce("scale_shift",1,F.length,2),te=ht("output",p[0].dataType,V.length,k),ee=[K,q,te];return`
  ${X.registerUniform("output_size","u32").declareVariables(...ee)}
  ${X.mainStart()}
  ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${te.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${q.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${K.getByOffset("global_idx")} * ${te.type.value}(scale_shift.x) + ${te.type.value}(scale_shift.y);
      ${te.setByOffset("global_idx","value")};
  }`};c.compute({name:"InstanceNormalization",shaderCache:{hint:`${k}`,inputDependencies:z},getRunData:()=>({outputs:[{dims:x,dataType:p[0].dataType}],dispatchGroup:{x:Math.ceil(O/64)},programUniforms:[{type:12,data:O},...It(V,F,V)]}),getShaderSource:G},{inputs:[p[0],R]})},NS=(c,p,g)=>{let b=p[0].dims,x=b,S=b[0],A=b[b.length-1],$=Ae.sizeFromDimension(b,1)/A,D=Sn(A),k=Ae.size(x)/D,O=[{type:12,data:$},{type:12,data:Math.floor(A/D)}],R=["type","type"],V=!1,F=[0,b.length-1];for(let K=0;K<b.length-2;K++)V=V||b[K+1]!==1,F.push(K+1);V=V&&b[b.length-1]!==1;let z=V?c.compute(Nr(c.inputs[0],F),{inputs:[c.inputs[0]],outputs:[-1]})[0]:c.inputs[0].reshape(Array.from({length:b.length},(K,q)=>b[F[q]])),G=N0(c,z,p[1],p[2],S,$,A,g.epsilon),X=K=>{let q=ns(p[0].dataType),te=D===1?"vec2f":`mat${D}x2f`,ee=Ne=>{let Ve=Ne===0?"x":"y",Ke=D===1?"f32":`vec${D}f`;switch(D){case 1:return`${q}(${Ke}(scale.${Ve}))`;case 2:return`vec2<${q}>(${Ke}(scale[0].${Ve}, scale[1].${Ve}))`;case 4:return`vec4<${q}>(${Ke}(scale[0].${Ve}, scale[1].${Ve}, scale[2].${Ve}, scale[3].${Ve}))`;default:throw new Error(`Not supported compoents ${D}`)}},re=Ce("input",p[0].dataType,p[0].dims,D),me=ht("output",p[0].dataType,x,D);return`
  @group(0) @binding(0) var<storage, read> input : array<${re.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${te}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${me.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${K.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${ee(0)}, ${ee(1)});
  }`};c.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${D}`,inputDependencies:R},getRunData:()=>({outputs:[{dims:x,dataType:p[0].dataType}],dispatchGroup:{x:Math.ceil(k/64)},programUniforms:O}),getShaderSource:X},{inputs:[p[0],G]})},wS=(c,p)=>{p.format==="NHWC"?NS(c,c.inputs,p):xS(c,c.inputs,p)}}),AS,TS,SS,kP=u(()=>{vt(),Et(),Ct(),AS=c=>{if(!c||c.length<2)throw new Error("layerNorm requires at least 2 inputs.")},TS=(c,p,g)=>{let b=p.simplified,x=c[0].dims,S=c[1],A=!b&&c[2],$=x,D=Ae.normalizeAxis(p.axis,x.length),k=Ae.sizeToDimension(x,D),O=Ae.sizeFromDimension(x,D),R=Ae.size(S.dims),V=A?Ae.size(A.dims):0;if(R!==O||A&&V!==O)throw new Error(`Size of X.shape()[axis:] == ${O}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${R} and bias size of ${V}`);let F=[];for(let re=0;re<x.length;++re)re<D?F.push(x[re]):F.push(1);let z=Sn(O),G=["type","type"],X=[{type:12,data:k},{type:1,data:O},{type:12,data:Math.floor(O/z)},{type:1,data:p.epsilon}];A&&G.push("type");let K=g>1,q=g>2,te=re=>{let me=ns(c[0].dataType),Ne=[Ce("x",c[0].dataType,c[0].dims,z),Ce("scale",S.dataType,S.dims,z)];A&&Ne.push(Ce("bias",A.dataType,A.dims,z)),Ne.push(ht("output",c[0].dataType,$,z)),K&&Ne.push(ht("mean_data_output",1,F)),q&&Ne.push(ht("inv_std_output",1,F));let Ve=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${re.registerUniforms(Ve).declareVariables(...Ne)}
  ${re.mainStart()}
    ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Bg("f32",z)};
    var mean_square_vector = ${Bg("f32",z)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Pl(me,z,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Ta("mean_vector",z)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Ta("mean_square_vector",z)} / uniforms.norm_size ${b?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Pl(me,z,"x[j + offset]")};
      let f32scale = ${Pl(me,z,"scale[j]")};
      output[j + offset] = ${Ne[0].type.value}((f32input ${b?"":"- mean"}) * inv_std_dev * f32scale
        ${A?`+ ${Pl(me,z,"bias[j]")}`:""}
      );
    }

    ${K?"mean_data_output[global_idx] = mean":""};
    ${q?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},ee=[{dims:$,dataType:c[0].dataType}];return K&&ee.push({dims:F,dataType:1}),q&&ee.push({dims:F,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${z};${g};${b}`,inputDependencies:G},getRunData:()=>({outputs:ee,dispatchGroup:{x:Math.ceil(k/64)},programUniforms:X}),getShaderSource:te}},SS=(c,p)=>{AS(c.inputs),c.compute(TS(c.inputs,p,c.outputCount))}}),vS,$S,CP=u(()=>{Et(),s0(),o0(),vS=c=>{if(!c||c.length!==2)throw new Error("MatMul requires 2 inputs.");if(c[0].dims[c[0].dims.length-1]!==c[1].dims[c[1].dims.length-2])throw new Error("shared dimension does not match.")},$S=c=>{vS(c.inputs);let p=Rl.calcShape(c.inputs[0].dims,c.inputs[1].dims,!0);if(!p)throw new Error("Can't use matmul on the given tensors");let g=p[p.length-1],b=c.inputs[0].dims[c.inputs[0].dims.length-1];if(g<8&&b<8)c.compute(n0(c.inputs,{activation:""},p));else{let x=p[p.length-2],S=Ae.size(c.inputs[0].dims.slice(0,-2)),A=Ae.size(c.inputs[1].dims.slice(0,-2));if(S!==1&&x===1&&A===1){let $=c.inputs[0].reshape([1,S,b]),D=c.inputs[1].reshape([1,b,g]),k=[1,S,g],O=[$,D];c.compute(Bh(O,{activation:""},p,k),{inputs:O})}else c.compute(Bh(c.inputs,{activation:""},p))}}}),_S,DS,ES,kS,CS,LP=u(()=>{vt(),Et(),Cn(),Ct(),_S=(c,p)=>{if(c.length<3||c.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let g=c[0],b=g.dims.length;if(g.dims[b-1]!==p.k)throw new Error("The last dim of input shape does not match the k value");let x=Math.floor((p.k+p.blockSize-1)/p.blockSize),S=p.blockSize/8*p.bits,A=c[1];if(!Ae.areEqual(A.dims,[p.n,x,S]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let $=c[2].dims;if(Ae.size($)!==p.n*x)throw new Error("scales input size error.");if(c.length===4){let D=c[3].dims,k=p.bits>4?p.n*x:p.n*Math.floor((x+1)/2);if(Ae.size(D)!==k)throw new Error("zeroPoints input size error.")}},DS=(c,p)=>{let g=c[0].dims,b=g.length,x=g[b-2],S=p.k,A=p.n,$=g.slice(0,b-2),D=Ae.size($),k=c[1].dims[2]/4,O=c[0].dataType,R=Sn(p.k),V=Sn(k),F=Sn(A),z=$.concat([x,A]),G=x>1&&A/F%2===0?2:1,X=Ae.size(z)/F/G,K=64,q=[],te=[D,x,S/R],ee=Ae.convertShape(c[1].dims).slice();ee.splice(-1,1,k/V),q.push(...It(te)),q.push(...It(ee)),q.push(...It(c[2].dims)),c.length===4&&q.push(...It(Ae.convertShape(c[3].dims)));let re=[D,x,A/F];q.push(...It(re));let me=Ne=>{let Ve=te.length,Ke=Ce("a",c[0].dataType,Ve,R),lt=Ce("b",12,ee.length,V),_t=Ce("scales",c[2].dataType,c[2].dims.length),Ot=[Ke,lt,_t],Tt=c.length===4?Ce("zero_points",12,c[3].dims.length):void 0;Tt&&Ot.push(Tt);let kt=re.length,Wt=ht("output",c[0].dataType,kt,F),it=ns(c[0].dataType),en=(()=>{switch(R){case 1:return`array<${it}, 8>`;case 2:return`mat4x2<${it}>`;case 4:return`mat2x4<${it}>`;default:throw new Error(`${R}-component is not supported.`)}})(),In=()=>{let Be=`
          // reuse a data
            var input_offset = ${Ke.indicesToOffset(`${Ke.type.indices}(batch, row, word_offset)`)};
            var a_data: ${en};
            for (var j: u32 = 0; j < ${8/R}; j++) {
              a_data[j] = ${Ke.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let tt=0;tt<F*G;tt++)Be+=`
            b_value = ${V===1?`b${tt}_data`:`b${tt}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${en}(${Array.from({length:4},(sn,Vn)=>`${it}(b_value_lower[${Vn}]), ${it}(b_value_upper[${Vn}])`).join(", ")});
            b_dequantized_values = ${R===1?`${en}(${Array.from({length:8},(sn,Vn)=>`(b_quantized_values[${Vn}] - ${Tt?`zero_point${tt}`:"zero_point"}) * scale${tt}`).join(", ")});`:`(b_quantized_values - ${en}(${Array(8).fill(`${Tt?`zero_point${tt}`:"zero_point"}`).join(",")})) * scale${tt};`};
            workgroup_shared[local_id.x * ${G} + ${Math.floor(tt/F)}]${F>1?`[${tt%F}]`:""} += ${Array.from({length:8/R},(sn,Vn)=>`${R===1?`a_data[${Vn}] * b_dequantized_values[${Vn}]`:`dot(a_data[${Vn}], b_dequantized_values[${Vn}])`}`).join(" + ")};
          `;return Be},yt=()=>{let Be=`
            var col_index = col * ${F};
            ${Tt?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${it}(8);`}
            `;for(let tt=0;tt<F*G;tt++)Be+=`
            let scale${tt} = ${_t.getByOffset("col_index * nBlocksPerCol + block")};
            ${Tt?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${Tt.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${tt} = ${it}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return Be},hn=()=>{let Be=`col_index = col * ${F};`;for(let tt=0;tt<F*G;tt++)Be+=`
            let b${tt}_data = ${lt.getByIndices(`${lt.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return Be+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${en};
            var b_dequantized_values: ${en};`,Be};return`
        var<workgroup> workgroup_shared: array<${Wt.type.value}, ${G*K}>;
        ${Ne.declareVariables(...Ot,Wt)}
        ${Ne.mainStart([K,1,1])}
          let output_indices = ${Wt.offsetToIndices(`(global_idx / ${K}) * ${G}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${K}) {
            //process one block
            var word_offset: u32 = block * ${p.blockSize/R};
            ${yt()}
            for (var word: u32 = 0; word < ${k}; word += ${V}) {
              ${hn()}
              for (var i: u32 = 0; i < ${V}; i++) {
                ${In()}
                word_offset += ${8/R};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${G}) {
            var output_value: ${Wt.type.value} = ${Wt.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${K}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${G};
            }
            ${Wt.setByIndices(`${Wt.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${p.blockSize};${p.bits};${R};${V};${F};${G};${K}`,inputDependencies:Array(c.length).fill("rank")},getRunData:()=>({outputs:[{dims:z,dataType:O}],dispatchGroup:{x:X},programUniforms:q}),getShaderSource:me}},ES=(c,p)=>{let g=c[0].dims,b=g.length,x=g[b-2],S=p.k,A=p.n,$=g.slice(0,b-2),D=Ae.size($),k=c[1].dims[2]/4,O=c[0].dataType,R=Sn(p.k),V=Sn(k),F=$.concat([x,A]),z=128,G=A%8===0?8:A%4===0?4:1,X=z/G,K=X*V*8,q=K/R,te=K/p.blockSize,ee=Ae.size(F)/G,re=[],me=[D,x,S/R],Ne=Ae.convertShape(c[1].dims).slice();Ne.splice(-1,1,k/V),re.push(...It(me)),re.push(...It(Ne)),re.push(...It(c[2].dims)),c.length===4&&re.push(...It(Ae.convertShape(c[3].dims)));let Ve=[D,x,A];re.push(...It(Ve));let Ke=lt=>{let _t=me.length,Ot=Ce("a",c[0].dataType,_t,R),Tt=Ce("b",12,Ne.length,V),kt=Ce("scales",c[2].dataType,c[2].dims.length),Wt=[Ot,Tt,kt],it=c.length===4?Ce("zero_points",12,c[3].dims.length):void 0;it&&Wt.push(it);let en=Ve.length,In=ht("output",c[0].dataType,en),yt=ns(c[0].dataType),hn=()=>{switch(R){case 1:return`
          let a_data0 = vec4<${yt}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${yt}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${yt}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${yt}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${R}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${Ot.type.value}, ${q}>;
        var<workgroup> inter_results: array<array<${In.type.value}, ${X}>, ${G}>;
        ${lt.declareVariables(...Wt,In)}
        ${lt.mainStart([X,G,1])}
          let output_indices = ${In.offsetToIndices(`workgroup_index * ${G}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${te} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${q};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${q}; a_offset += ${z})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${Ot.getByIndices(`${Ot.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${Ot.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${te} + local_id.x;
            ${it?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${it.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${yt}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${yt}(8);`}
            let scale = ${kt.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${Tt.getByIndices(`${Tt.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${p.blockSize/R};
            for (var i: u32 = 0; i < ${V}; i++) {
              ${hn()}
              let b_value = ${V===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${yt}>(${Array.from({length:4},(Be,tt)=>`${yt}(b_value_lower[${tt}]), ${yt}(b_value_upper[${tt}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${yt}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Be,tt)=>`${`dot(a_data${tt}, b_dequantized_values[${tt}])`}`).join(" + ")};
              word_offset += ${8/R};
            }
            workgroupBarrier();
          }

          if (local_idx < ${G}) {
            var output_value: ${In.type.value} = ${In.type.value}(0);
            for (var b = 0u; b < ${X}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${In.setByIndices(`${In.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${p.blockSize};${R};${V};${X};${G}`,inputDependencies:Array(c.length).fill("rank")},getRunData:()=>({outputs:[{dims:F,dataType:O}],dispatchGroup:{x:ee},programUniforms:re}),getShaderSource:Ke}},kS=(c,p)=>{_S(c.inputs,p),p.blockSize===32&&c.adapterInfo.isVendor("intel")&&c.adapterInfo.isArchitecture("gen-12lp")?c.compute(ES(c.inputs,p)):c.compute(DS(c.inputs,p))},CS=c=>rn(c)}),LS,OS,RS,VS,PS,FS,zS,MS,WS,OP=u(()=>{vt(),Et(),Ct(),LS=c=>{if(!c||c.length<1)throw new Error("Too few inputs");if(c[0].dataType!==1&&c[0].dataType!==10)throw new Error("Input type must be float or float16.");if(c.length>=2){let p=c[0].dims.length*2===c[1].dims[0];if(c.length===4&&(p=c[3].dims[0]*2===c[1].dims[0]),!p)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},OS=(c,p,g)=>{let b="";for(let x=p-1;x>=0;--x)b+=`
            k = i32(${c.indicesGet("indices",x)}) - ${pt("uniforms.pads",x,g)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${pt("uniforms.x_shape",x,p)})) {
              break;
            }
            offset += k * i32(${pt("uniforms.x_strides",x,p)});
        `;return`
          value = ${c.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${b}
            value = x[offset];
          }
      `},RS=(c,p,g)=>{let b="";for(let x=p-1;x>=0;--x)b+=`
                k = i32(${c.indicesGet("indices",x)}) - ${pt("uniforms.pads",x,g)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${pt("uniforms.x_shape",x,p)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${pt("uniforms.x_shape",x,p)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${pt("uniforms.x_strides",x,p)});
            `;return`
              var offset = 0;
              var k = 0;
              ${b}
              value = x[offset];
          `},VS=(c,p,g)=>{let b="";for(let x=p-1;x>=0;--x)b+=`
                k = i32(${c.indicesGet("indices",x)}) - ${pt("uniforms.pads",x,g)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${pt("uniforms.x_shape",x,p)})) {
                  k = i32(${pt("uniforms.x_shape",x,p)}) - 1;
                }
                offset += k * i32(${pt("uniforms.x_strides",x,p)});
            `;return`
              var offset = 0;
              var k = 0;
              ${b}
              value = x[offset];
          `},PS=(c,p,g)=>{let b="";for(let x=p-1;x>=0;--x)b+=`
                k = i32(${c.indicesGet("indices",x)}) - ${pt("uniforms.pads",x,g)};
                if (k < 0)  {
                  k += i32(${pt("uniforms.x_shape",x,p)}]);
                }
                if (k >= i32(${pt("uniforms.x_shape",x,p)})) {
                  k -= i32(${pt("uniforms.x_shape",x,p)});
                }
                offset += k * i32(${pt("uniforms.x_strides",x,p)});
            `;return`
              var offset = 0;
              var k = 0;
              ${b}
              value = x[offset];
          `},FS=(c,p,g)=>{switch(g.mode){case 0:return OS(c,p,g.pads.length);case 1:return RS(c,p,g.pads.length);case 2:return VS(c,p,g.pads.length);case 3:return PS(c,p,g.pads.length);default:throw new Error("Invalid mode")}},zS=(c,p)=>{let g=Ae.padShape(c[0].dims.slice(),p.pads),b=c[0].dims,x=Ae.size(g),S=[{type:12,data:x},{type:6,data:p.pads}],A=c.length>=3&&c[2].data;p.mode===0&&S.push({type:A?c[2].dataType:1,data:p.value}),S.push(...It(c[0].dims,g));let $=["rank"],D=k=>{let O=ht("output",c[0].dataType,g.length),R=Ce("x",c[0].dataType,b.length),V=R.type.value,F=FS(O,b.length,p),z=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:p.pads.length}];return p.mode===0&&z.push({name:"constant_value",type:A?V:"f32"}),`
            ${k.registerUniforms(z).declareVariables(R,O)}
            ${k.mainStart()}
            ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${O.offsetToIndices("global_idx")};

            var value = ${V}(0);
            ${F}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${p.mode}${A}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:g,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(Ae.size(g)/64)},programUniforms:S}),getShaderSource:D}},MS=(c,p)=>{if(c.length>1){let g=c[1].getBigInt64Array(),b=c.length>=3&&c[2].data?c[2].dataType===10?c[2].getUint16Array()[0]:c[2].getFloat32Array()[0]:0,x=c[0].dims.length,S=new Int32Array(2*x).fill(0);if(c.length>=4){let $=c[3].getBigInt64Array();for(let D=0;D<$.length;D++)S[Number($[D])]=Number(g[D]),S[Number($[D])+x]=Number(g[D+$.length])}else g.forEach(($,D)=>S[Number(D)]=Number($));let A=[];return S.forEach($=>A.push($)),{mode:p.mode,value:b,pads:A}}else return p},WS=(c,p)=>{LS(c.inputs);let g=MS(c.inputs,p);c.compute(zS(c.inputs,g),{inputs:[0]})}}),sc,w0,A0,T0,S0,BS,HS,v0,$0,US,GS,_0,qS,KS,D0,jS,YS,XS,ZS,RP=u(()=>{dt(),vt(),Et(),Ct(),sc=c=>{if(U.webgpu.validateInputContent&&(!c||c.length!==1))throw new Error("Pool ops requires 1 input.")},w0=(c,p,g)=>{let b=p.format==="NHWC",x=c.dims.slice();b&&x.splice(1,0,x.pop());let S=Object.hasOwnProperty.call(p,"dilations"),A=p.kernelShape.slice(),$=p.strides.slice(),D=S?p.dilations.slice():[],k=p.pads.slice();Ph.adjustPoolAttributes(g,x,A,$,D,k);let O=Ph.computePoolOutputShape(g,x,$,D,A,k,p.autoPad),R=Object.assign({},p);S?Object.assign(R,{kernelShape:A,strides:$,pads:k,dilations:D,cacheKey:p.cacheKey}):Object.assign(R,{kernelShape:A,strides:$,pads:k,cacheKey:p.cacheKey});let V=O.slice();return V.push(V.splice(1,1)[0]),[R,b?V:O]},A0=(c,p)=>{let g=p.format==="NHWC",b=Ae.size(c),x=Ae.size(p.kernelShape),S=[{type:12,data:b},{type:12,data:x}],A=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(p.kernelShape.length<=2){let $=p.kernelShape[p.kernelShape.length-1],D=p.strides[p.strides.length-1],k=p.pads[p.pads.length/2-1],O=p.pads[p.pads.length-1],R=!!(k+O);S.push({type:12,data:$},{type:12,data:D},{type:12,data:k},{type:12,data:O}),A.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let V=!1;if(p.kernelShape.length===2){let F=p.kernelShape[p.kernelShape.length-2],z=p.strides[p.strides.length-2],G=p.pads[p.pads.length/2-2],X=p.pads[p.pads.length-2];V=!!(G+X),S.push({type:12,data:F},{type:12,data:z},{type:12,data:G},{type:12,data:X}),A.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[S,A,!0,R,V]}else{if(g)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let $=Ae.computeStrides(p.kernelShape);S.push({type:12,data:$},{type:12,data:p.pads},{type:12,data:p.strides}),A.push({name:"kernelStrides",type:"u32",length:$.length},{name:"pads",type:"u32",length:p.pads.length},{name:"strides",type:"u32",length:p.strides.length});let D=p.pads.reduce((k,O)=>k+O);return[S,A,!!D,!1,!1]}},T0=(c,p,g,b,x,S,A,$,D,k,O,R)=>{let V=x.format==="NHWC",F=p.type.value,z=ht("output",p.type.tensor,b);if(x.kernelShape.length<=2){let G="",X="",K="",q=g-(V?2:1);if(O?G=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${q}] = indices[${q}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${q}] < 0 || xIndices[${q}]
                      >= uniforms.x_shape[${q}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${p.indicesToOffset("xIndices")}];
                  ${S}
                }`:G=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${q}] = indices[${q}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${p.indicesToOffset("xIndices")}];
                  ${S}
                }`,x.kernelShape.length===2){let te=g-(V?3:2);R?X=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${te}] = indices[${te}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${te}] < 0 || xIndices[${te}] >= uniforms.x_shape[${te}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:X=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${te}] = indices[${te}] * uniforms.sh - uniforms.phStart + j;
                `,K=`
              }
            `}return`
            ${c.registerUniforms(D).declareVariables(p,z)}

            ${c.mainStart()}
              ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${z.offsetToIndices("global_idx")};
              var xIndices = ${z.offsetToIndices("global_idx")};

              var value = ${F}(${$});
              var pad = 0;
              ${X}
              ${G}
              ${K}
              ${A}

              output[global_idx] = value;
            }`}else{if(V)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let G=x.kernelShape.length,X=x.pads.length,K="";return k?K=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${p.indicesToOffset("xIndices")}];
                ${S}
              }`:K=`
              }
              let x_val = x[${p.indicesToOffset("xIndices")}];
              ${S}
            `,`
            ${c.registerUniforms(D).declareVariables(p,z)}

            ${c.mainStart()}
              ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${z.offsetToIndices("global_idx")};
              var xIndices = ${z.offsetToIndices("global_idx")};

              var offsets: array<u32, ${G}>;

              var value = ${F}(${$});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${G-1}u; j++) {
                  offsets[j] = offset / ${pt("uniforms.kernelStrides","j",G)};
                  offset -= offsets[j] * ${pt("uniforms.kernelStrides","j",G)};
                }
                offsets[${G-1}] = offset;

                isPad = false;
                for (var j = ${g-G}u; j < ${g}u; j++) {
                  xIndices[j] = indices[j] * ${pt("uniforms.strides",`j - ${g-G}u`,G)}
                    + offsets[j - ${g-G}u] - ${pt("uniforms.pads","j - 2u",X)};
                  ${K}
              }
              ${A}

              output[global_idx] = value;
            }`}},S0=c=>`${c.format};${c.ceilMode};${c.autoPad};${c.kernelShape.length}`,BS=c=>`${S0(c)};${c.countIncludePad}`,HS=c=>`${S0(c)};${c.storageOrder};${c.dilations}`,v0=c=>({format:c.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][c.auto_pad],ceilMode:c.ceil_mode,kernelShape:c.kernel_shape,strides:c.strides,pads:c.pads}),$0=(c,p,g,b)=>{let[x,S]=w0(p,b,g),A=Ce("x",p.dataType,p.dims.length),$=A.type.value,D="value += x_val;",k="";x.countIncludePad?k+=`value /= ${$}(uniforms.kernelSize);`:k+=`value /= ${$}(i32(uniforms.kernelSize) - pad);`;let[O,R,V,F,z]=A0(S,x);O.push(...It(p.dims,S));let G=["rank"];return{name:c,shaderCache:{hint:`${b.cacheKey};${V};${F};${z}`,inputDependencies:G},getRunData:()=>({outputs:[{dims:S,dataType:p.dataType}],dispatchGroup:{x:Math.ceil(Ae.size(S)/64)},programUniforms:O}),getShaderSource:X=>T0(X,A,p.dims.length,S.length,x,D,k,0,R,V,F,z)}},US=c=>{let p=c.count_include_pad!==0,g=v0(c);if(g.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let b={countIncludePad:p,...g,cacheKey:""};return{...b,cacheKey:BS(b)}},GS=(c,p)=>{sc(c.inputs),c.compute($0("AveragePool",c.inputs[0],!1,p))},_0={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},qS=c=>{let p=c.format;return{format:p,..._0,cacheKey:p}},KS=(c,p)=>{sc(c.inputs),c.compute($0("GlobalAveragePool",c.inputs[0],!0,p))},D0=(c,p,g,b)=>{let[x,S]=w0(p,b,g),A=`
      value = max(x_val, value);
    `,$="",D=Ce("x",p.dataType,p.dims.length),k=["rank"],[O,R,V,F,z]=A0(S,x);return O.push(...It(p.dims,S)),{name:c,shaderCache:{hint:`${b.cacheKey};${V};${F};${z}`,inputDependencies:k},getRunData:()=>({outputs:[{dims:S,dataType:p.dataType}],dispatchGroup:{x:Math.ceil(Ae.size(S)/64)},programUniforms:O}),getShaderSource:G=>T0(G,D,p.dims.length,S.length,x,A,$,p.dataType===10?-65504:-1e5,R,V,F,z)}},jS=(c,p)=>{sc(c.inputs),c.compute(D0("MaxPool",c.inputs[0],!1,p))},YS=c=>{let p=c.storage_order,g=c.dilations,b=v0(c);if(p!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(b.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let x={storageOrder:p,dilations:g,...b,cacheKey:""};return{...x,cacheKey:HS(x)}},XS=c=>{let p=c.format;return{format:p,..._0,cacheKey:p}},ZS=(c,p)=>{sc(c.inputs),c.compute(D0("GlobalMaxPool",c.inputs[0],!0,p))}}),QS,JS,ev,tv,VP=u(()=>{vt(),Et(),Cn(),Ct(),QS=(c,p)=>{if(c.length<2||c.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(c.length===3&&c[1].dims===c[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(c.length===3&&c[0].dataType!==c[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(c[0].dataType===6&&c.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(c[1].dims.length!==0&&c[1].dims.length!==1&&c[1].dims.length!==c[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(c.length>2){if(c[0].dataType!==c[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(c[1].dims.length!==c[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!c[1].dims.map((g,b)=>g===c[2].dims[b]).reduce((g,b)=>g&&b,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(p.blockSize>0){if(c[1].dims.length===0||c[1].dims.length===1&&c[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!c[1].dims.map((x,S)=>S===p.axis||x===c[0].dims[S]).reduce((x,S)=>x&&S,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(c[1].dims.length!==c[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let g=c[0].dims[p.axis],b=c[1].dims[p.axis];if(p.blockSize<Math.ceil(g/b)||p.blockSize>Math.ceil(g/(b-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},JS=(c,p)=>{let g=Ae.normalizeAxis(p.axis,c[0].dims.length),b=c[0].dataType,x=b===3,S=c[0].dims,A=c[1].dataType,$=Ae.size(S),D=b===3||b===2,k=D?[Math.ceil(Ae.size(c[0].dims)/4)]:c[0].dims,O=c[1].dims,R=c.length>2?c[2]:void 0,V=R?D?[Math.ceil(Ae.size(R.dims)/4)]:R.dims:void 0,F=O.length===0||O.length===1&&O[0]===1,z=F===!1&&O.length===1,G=Sn($),X=F&&(!D||G===4),K=X?G:1,q=X&&!D?G:1,te=Ce("input",D?12:b,k.length,q),ee=Ce("scale",A,O.length),re=R?Ce("zero_point",D?12:b,V.length):void 0,me=ht("output",A,S.length,K),Ne=[te,ee];re&&Ne.push(re);let Ve=[k,O];R&&Ve.push(V);let Ke=[{type:12,data:$/K},{type:12,data:g},{type:12,data:p.blockSize},...It(...Ve,S)],lt=_t=>{let Ot=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${_t.registerUniforms(Ot).declareVariables(...Ne,me)}
      ${_t.mainStart()}
          ${_t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${me.offsetToIndices("global_idx")};

          // Set input x
          ${D?`
            let input = ${te.getByOffset("global_idx / 4")};
            let x_vec = ${x?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${K===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${te.getByOffset("global_idx")};`};

          // Set scale input
          ${F?`let scale_value= ${ee.getByOffset("0")}`:z?`
            let scale_index = ${me.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${ee.getByOffset("scale_index")};`:`
            var scale_indices: ${ee.type.indices} = output_indices;
            let index = ${ee.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${ee.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${ee.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${re?F?D?`
                let zero_point_input = ${re.getByOffset("0")};
                let zero_point_vec =  ${x?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${re.getByOffset("0")}`:z?D?`
                let zero_point_index = ${me.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${re.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${x?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${me.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${re.getByOffset("zero_point_index")};`:D?`
                let zero_point_offset = ${ee.indicesToOffset("scale_indices")};
                let zero_point_input = ${re.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${x?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${re.getByIndices("scale_indices")};`:`let zero_point_value = ${D?x?"i32":"u32":te.type.value}(0);`};
      // Compute and write output
      ${me.setByOffset("global_idx",`${me.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:p.cacheKey,inputDependencies:re?["rank","rank","rank"]:["rank","rank"]},getShaderSource:lt,getRunData:()=>({outputs:[{dims:S,dataType:A}],dispatchGroup:{x:Math.ceil($/K/64),y:1,z:1},programUniforms:Ke})}},ev=(c,p)=>{QS(c.inputs,p),c.compute(JS(c.inputs,p))},tv=c=>rn({axis:c.axis,blockSize:c.blockSize})}),nv,sv,rv,PP=u(()=>{dt(),vt(),Ct(),nv=(c,p,g)=>{let b=c===p,x=c<p&&g<0,S=c>p&&g>0;if(b||x||S)throw new Error("Range these inputs' contents are invalid.")},sv=(c,p,g,b)=>{let x=Math.abs(Math.ceil((p-c)/g)),S=[x],A=x,$=[{type:12,data:A},{type:b,data:c},{type:b,data:g},...It(S)],D=k=>{let O=ht("output",b,S.length),R=O.type.value,V=[{name:"outputSize",type:"u32"},{name:"start",type:R},{name:"delta",type:R}];return`
        ${k.registerUniforms(V).declareVariables(O)}
        ${k.mainStart()}
        ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${R}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${b}`},getShaderSource:D,getRunData:()=>({outputs:[{dims:S,dataType:b}],dispatchGroup:{x:Math.ceil(A/64)},programUniforms:$})}},rv=c=>{let p=0,g=0,b=0;c.inputs[0].dataType===6?(p=c.inputs[0].getInt32Array()[0],g=c.inputs[1].getInt32Array()[0],b=c.inputs[2].getInt32Array()[0]):c.inputs[0].dataType===1&&(p=c.inputs[0].getFloat32Array()[0],g=c.inputs[1].getFloat32Array()[0],b=c.inputs[2].getFloat32Array()[0]),U.webgpu.validateInputContent&&nv(p,g,b),c.compute(sv(p,g,b,c.inputs[0].dataType),{inputs:[]})}}),iv,av,ov,lv,FP=u(()=>{vt(),Et(),Cn(),Ct(),iv=(c,p,g,b)=>{if(c!=="none"&&b!=="i32"&&b!=="u32"&&b!=="f32")throw new Error(`Input ${b} is not supported with reduction ${c}.`);let x=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,S=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${p}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(c){case"none":return`${p}=${g};`;case"add":return b==="i32"||b==="u32"?`atomicAdd(&${p}, bitcast<${b}>(${g}));`:`
              ${x}bitcast<${b}>(oldValue) + (${g})${S}`;case"max":return b==="i32"||b==="u32"?`atomicMax(&${p}, bitcast<${b}>(${g}));`:`
                ${x}max(bitcast<f32>(oldValue), (${g}))${S}`;case"min":return b==="i32"||b==="u32"?`atomicMin(&${p}, bitcast<${b}>(${g}));`:`${x}min(bitcast<${b}>(oldValue), (${g}))${S}`;case"mul":return`${x}(bitcast<${b}>(oldValue) * (${g}))${S}`;default:throw new Error(`Reduction ${c} is not supported.`)}},av=(c,p)=>{let g=c[0].dims,b=c[1].dims,x=g,S=1,A=Math.ceil(Ae.size(b)/S),$=b[b.length-1],D=Ae.sizeFromDimension(g,$),k=[{type:12,data:A},{type:12,data:$},{type:12,data:D},...It(c[1].dims,c[2].dims,x)],O=R=>{let V=Ce("indices",c[1].dataType,c[1].dims.length),F=Ce("updates",c[2].dataType,c[2].dims.length,S),z=p.reduction!=="none"&&p.reduction!==""?yN("output",c[0].dataType,x.length):ht("output",c[0].dataType,x.length,S);return`
      ${R.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(V,F,z)}
      ${R.mainStart()}
        ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${p.reduction==="none"}) {
    let n = ${Ae.size(b)};
    for (var i = 0; i < n; i = i + 1) {
      for (var j = i + 1; j < n; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  if (${p.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    indices_start = 0u;
  }
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${c[0].dims.length===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${iv(p.reduction,"output[data_offset + i]","value",z.type.value)}
  }

      }`};return{name:"ScatterND",shaderCache:{hint:`${p.cacheKey}_${p.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:x,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(A/64)},programUniforms:k}),getShaderSource:O}},ov=c=>rn({reduction:c.reduction}),lv=(c,p)=>{c.compute(av(c.inputs,p),{inputs:[c.inputs[1],c.inputs[2]],outputs:[]})}}),uv,cv,dv,E0,hv,pv,fv,mv,gv,Iv,yv,bv,k0,xv,Nv,wv,Av,Tv,Sv,vv,zP=u(()=>{vt(),Et(),Cn(),Ct(),uv=(c,p)=>{if(c.every(g=>g>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),c.length>0){if(p.mode==="linear"){if(!(c.length===2||c.length===3||c.length===4&&c[0]===1&&c[1]===1||c.length===4&&c[0]===1&&c[3]===1||c.length===5&&c[0]===1&&c[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(p.mode==="cubic"&&!(c.length===2||c.length===4&&c[0]===1&&c[1]===1||c.length===4&&c[0]===1&&c[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},cv=(c,p,g)=>{p.every(x=>x>=0&&x<g||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let b=new Array(g).fill(1);return p.forEach((x,S)=>b[x]=c[S]),b},dv=(c,p,g,b,x,S)=>{let[A,$,D]=g>10?[1,2,3]:[-1,c.length>1?1:-1,-1],k=c[0].dims.length;if(A>0&&c.length>A&&c[A].dims.length>0)c[A].getFloat32Array().forEach(O=>S.push(O));else if(p.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if($>0&&c.length>$&&c[$].dims.length===1&&c[$].dims[0]>0){if(c[$].getFloat32Array().forEach(O=>b.push(O)),b.length!==0&&b.length!==k&&g>=18&&b.length!==p.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");uv(b,p),p.axes.length>0&&cv(b,p.axes,k).forEach((O,R)=>b[R]=O)}if(D>0&&c.length>D&&c[D].dims.length===1&&c[D].dims[0]>0&&(c[D].getBigInt64Array().forEach(O=>x.push(Number(O))),x.length!==0&&x.length!==k&&g>=18&&x.length!==p.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(p.axes.length>0){if(b.length!==0&&b.length!==p.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(x.length!==0&&x.length!==p.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof b<"u"&&typeof x<"u"&&b.length>0&&x.length>k)throw new Error("Resize requires only of scales or sizes to be specified")},E0=(c,p,g,b)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${c}) * (${p});
  let whole = ${b}(big / (${g}));
  let fract = ${b}(big % (${g})) / ${b}(${g});
  return whole + fract;
`,hv=(c,p)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${p} { `+(()=>{switch(c){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${p}(xResized) / ${p}(xScale);
          } else {
            ${E0("xResized","lengthOriginal","lengthResized",p)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${p}(xResized) + 0.5) / ${p}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${p}(xResized) + 0.5) / ${p}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${E0("xResized","lengthOriginal - 1","lengthResized - 1",p)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${p}(roiStart) * ${p}(lengthOriginal - 1) +
                        (${p}(xResized) * ${p}(roiEnd - roiStart) * ${p}(lengthOriginal - 1)) /
                        ${p}(lengthResized - 1);
                  } else {
                    return 0.5 * ${p}(roiStart + roiEnd) * ${p}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${p}xScale * ${p}(lengthResized);
                  const adjustment = ${p}(lengthResized) / outputWidth;
                  const center = ${p}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${p}(xResized) + 0.5) / ${p}(xScale)) - 0.5;`;case"half_pixel":return`return ((${p}(xResized) + 0.5) / ${p}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${c} is not supported`)}})()+"}",pv=(c,p,g)=>`fn getNearestPixelFromOriginal(xOriginal: ${g}, isDownSample: bool) -> ${g} {`+(()=>{switch(c){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(p<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${c} is not supported`)}})()+"}",fv=(c,p,g)=>{let b=new Array(g).fill(0).concat(new Array(g).fill(1)),x=c.length===0?b:c.slice();return p.length>0?(p.forEach((S,A)=>{b[S]=x[A],b[A+g]=x[p.length+A]}),b):x},mv=(c,p,g,b)=>{let x=[];if(g.length>0)if(b.length>0){if(c.forEach(S=>x.push(S)),Math.max(...b)>c.length)throw new Error("axes is out of bound");b.forEach((S,A)=>x[S]=g[A])}else g.forEach(S=>x.push(S));else{if(p.length===0)throw new Error("Resize requires either scales or sizes.");x=c.map((S,A)=>Math.round(S*p[A]))}return x},gv=(c,p,g)=>{let b=(()=>{switch(g.keepAspectRatioPolicy){case"not_larger":return g.axes.length>0?Math.min(...g.axes.map(S=>p[S]),Number.MAX_VALUE):Math.min(...p,Number.MAX_VALUE);case"not_smaller":return g.axes.length>0?Math.max(...g.axes.map(S=>p[S]),Number.MIN_VALUE):Math.max(...p,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${g.keepAspectRatioPolicy} is not supported`)}})();p.fill(1,0,p.length);let x=c.slice();return g.axes.length>0?(g.axes.forEach(S=>p[S]=b),g.axes.forEach(S=>x[S]=Math.round(c[S]*p[S]))):(p.fill(b,0,p.length),x.forEach((S,A)=>x[A]=Math.round(S*p[A]))),x},Iv=(c,p,g,b,x)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${c.type.indices}) -> array<${c.type.value}, ${g.length}> {
      var original_indices: array<${c.type.value}, ${g.length}>;
      for (var i:u32 = 0; i < ${g.length}; i++) {
        var output_index = ${c.indicesGet("output_indices","i")};
        var scale = ${pt("uniforms.scales","i",b)};
        var roi_low = ${pt("uniforms.roi","i",x)};
        var roi_hi = ${pt("uniforms.roi",`i + ${p.length}`,x)};
        if (scale == 1.0) {
          original_indices[i] = ${c.type.value}(output_index);
        } else {
          var input_shape_i = ${pt("uniforms.input_shape","i",p.length)};
          var output_shape_i = ${pt("uniforms.output_shape","i",g.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,yv=(c,p,g,b,x,S,A)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${p.type.indices}) -> ${c.type.indices} {
      var input_indices: ${c.type.indices};
      for (var i:u32 = 0; i < ${b.length}; i++) {
        var output_index = ${p.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${pt("uniforms.scales","i",x)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${pt("uniforms.roi","i",S)};
          var roi_hi = ${pt("uniforms.roi",`i + ${g.length}`,S)};
          var input_shape_i = ${pt("uniforms.input_shape","i",g.length)};
          var output_shape_i = ${pt("uniforms.output_shape","i",b.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${A} || (original_idx >= 0 && original_idx < ${p.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${p.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${c.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,bv=(c,p)=>`
    fn checkInputIndices(input_indices: ${c.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${p.length}; i++) {
        var input_index = ${c.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${pt("uniforms.input_shape","i",p.length)}) {
          return false;
        }
      }
      return true;
    }`,k0=(c,p,g,b)=>c.rank>b?`
    ${c.indicesSet("input_indices",p,"channel")};
    ${c.indicesSet("input_indices",g,"batch")};
`:"",xv=(c,p,g,b,x)=>{let[S,A,$,D]=g.length===2?[-1,0,1,-1]:[0,2,3,1],k=c.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${k} {
      var input_indices: ${c.type.indices};
      ${c.indicesSet("input_indices",A,`max(0, min(row, ${g[A]} - 1))`)};
      ${c.indicesSet("input_indices",$,`max(0, min(col, ${g[$]} - 1))`)};
      ${k0(c,D,S,2)}
      return ${c.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${p.type.indices}) -> ${k} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${k} = originalIndices[${A}];
      var col:${k} = originalIndices[${$}];
      ${b?`if (row < 0 || row > (${g[A]} - 1) || col < 0 || col > (${g[$]} - 1)) {
        return ${x};
      }`:""};
      row = max(0, min(row, ${g[A]} - 1));
      col = max(0, min(col, ${g[$]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${g.length>2?`u32(originalIndices[${D}])`:"0"};
      var batch: u32 =  ${g.length>2?`u32(originalIndices[${S}])`:"0"};
      var x11: ${k} = getInputValue(batch, channel, row1, col1);
      var x12: ${k} = getInputValue(batch, channel, row1, col2);
      var x21: ${k} = getInputValue(batch, channel, row2, col1);
      var x22: ${k} = getInputValue(batch, channel, row2, col2);
      var dx1: ${k} = abs(row - ${k}(row1));
      var dx2: ${k} = abs(${k}(row2) - row);
      var dy1: ${k} = abs(col - ${k}(col1));
      var dy2: ${k} = abs(${k}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Nv=(c,p,g,b,x,S,A,$,D,k)=>{let O=g.length===2,[R,V]=O?[0,1]:[2,3],F=c.type.value,z=G=>{let X=G===R?"row":"col";return`
      fn ${X}CubicInterpolation(input_indices: ${c.type.indices}, output_indices: ${p.type.indices}) -> ${F} {
        var output_index = ${p.indicesGet("output_indices",G)};
        var originalIdx: ${F} = getOriginalCoordinateFromResizedCoordinate(output_index, ${x[G]},
        ${b[G]}, ${g[G]}, ${S[G]}, ${S[G]} + ${g.length});
        var fractOriginalIdx: ${F} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${$} && (originalIdx < 0 || originalIdx > (${g[G]} - 1))) {
          return ${D};
        }
        var data: array<${F}, 4> = array<${F}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${X}: ${F} = originalIdx + ${F}(i);
          if (${X} < 0 || ${X} >= ${g[G]}) {
            ${k?`coefs[i + 1] = 0.0;
                        continue;`:$?`return ${D};`:`${X} = max(0, min(${X}, ${g[G]} - 1));`};
          }
        var input_indices_copy: ${c.type.indices} = input_indices;
          ${c.indicesSet("input_indices_copy",G,`u32(${X})`)};
          data[i + 1] = ${G===R?c.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${z(R)};
    ${z(V)};
  fn getCubicInterpolationCoefs(s: ${F}) -> array<${F}, 4> {
    var absS = abs(s);
    var coeffs: array<${F}, 4> = array<${F}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${F} = 1.0 - absS;
    var twoMinusAbsS: ${F} = 2.0 - absS;
    var onePlusAbsS: ${F} = 1.0 + absS;
    coeffs[0] = ((${A} * onePlusAbsS - 5 * ${A}) * onePlusAbsS + 8 * ${A}) * onePlusAbsS - 4 * ${A};
    coeffs[1] = ((${A} + 2) * absS - (${A} + 3)) * absS * absS + 1;
    coeffs[2] = ((${A} + 2) * oneMinusAbsS - (${A} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${A} * twoMinusAbsS - 5 * ${A}) * twoMinusAbsS + 8 * ${A}) * twoMinusAbsS - 4 * ${A};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${F}, 4>, coefs: array<${F}, 4>) -> ${F} {
    var coefsSum: ${F} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${p.type.indices}) -> ${F} {
    var input_indices: ${c.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},wv=(c,p,g,b,x)=>{let[S,A,$,D,k]=g.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],O=c.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${O} {
      var input_indices: ${c.type.indices};
      ${c.indicesSet("input_indices",A,`max(0, min(depth, ${g[A]} - 1))`)};
      ${c.indicesSet("input_indices",$,`max(0, min(height, ${g[$]} - 1))`)};
      ${c.indicesSet("input_indices",D,`max(0, min(width, ${g[D]} - 1))`)};
      ${k0(c,k,S,3)}
      return ${c.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${p.type.indices}) -> ${O} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${O} = originalIndices[${A}];
      var height:${O} = originalIndices[${$}];
      var width:${O} = originalIndices[${D}];
      ${b?`if (depth < 0 || depth > (${g[A]} - 1) || height < 0 || height > (${g[$]} - 1) || width < 0 || (width > ${g[D]} - 1)) {
      return ${x};
        }`:""};

    depth = max(0, min(depth, ${g[A]} - 1));
      height = max(0, min(height, ${g[$]} - 1));
      width = max(0, min(width, ${g[D]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${g.length>3?`u32(originalIndices[${k}])`:"0"};
      var batch: u32 =  ${g.length>3?`u32(originalIndices[${S}])`:"0"};

      var x111: ${O} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${O} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${O} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${O} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${O} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${O} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${O} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${O} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${O} = abs(depth - ${O}(depth1));
      var dx2: ${O} = abs(${O}(depth2) - depth);
      var dy1: ${O} = abs(height - ${O}(height1));
      var dy2: ${O} = abs(${O}(height2) - height);
      var dz1: ${O} = abs(width - ${O}(width1));
      var dz2: ${O} = abs(${O}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Av=(c,p,g,b,x,S)=>{let A=c.dims,$=fv(S,p.axes,A.length),D=mv(A,b,x,p.axes),k=b.slice();b.length===0&&(k=A.map((q,te)=>q===0?1:D[te]/q),p.keepAspectRatioPolicy!=="stretch"&&(D=gv(A,k,p)));let O=ht("output",c.dataType,D.length),R=Ce("input",c.dataType,A.length),V=Ae.size(D),F=A.length===D.length&&A.every((q,te)=>q===D[te]),z=p.coordinateTransformMode==="tf_crop_and_resize",G=p.extrapolationValue,X=R.type.value,K=q=>`
      ${F?"":`
      ${hv(p.coordinateTransformMode,X)};
      ${(()=>{switch(p.mode){case"nearest":return`
              ${bv(R,A)};
              ${pv(p.nearestMode,g,X)};
              ${yv(R,O,A,D,k.length,$.length,z)};
              `;case"linear":return`
              ${Iv(O,A,D,k.length,$.length)};
              ${(()=>{if(A.length===2||A.length===4)return`${xv(R,O,A,z,G)}`;if(A.length===3||A.length===5)return`${wv(R,O,A,z,G)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(A.length===2||A.length===4)return`${Nv(R,O,A,D,k,$,p.cubicCoeffA,z,p.extrapolationValue,p.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${q.registerUniform("output_size","u32").registerUniform("scales","f32",k.length).registerUniform("roi","f32",$.length).declareVariables(R,O)}
      ${q.mainStart()}
        ${q.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${F?"output[global_idx] = input[global_idx];":`
        let output_indices = ${O.offsetToIndices("global_idx")};
        var input_indices: ${R.type.indices};
        ${(()=>{switch(p.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${R.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${p.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${A.length===2||A.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${p.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${p.cacheKey}|${g}|${k.length>0?p.mode==="cubic"?k:k.length:""}|${x.length>0?x:""}|${$.length>0?$:""}|${F}|${p.mode==="nearest"?A.length:A}`,inputDependencies:["rank"]},getShaderSource:K,getRunData:()=>({outputs:[{dims:D,dataType:c.dataType}],dispatchGroup:{x:Math.ceil(V/64)},programUniforms:[{type:12,data:V},{type:1,data:k},{type:1,data:$},...It(A,D)]})}},Tv=c=>{let p=c.customDataBuffer;return new Uint32Array(p,p.byteOffset,1)[0]},Sv=(c,p)=>{let g=[],b=[],x=[],S=Tv(c);if(p.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");dv(c.inputs,p,S,g,b,x),c.compute(Av(c.inputs[0],p,S,g,b,x),{inputs:[0]})},vv=c=>{let p=c.antialias,g=c.axes,b=c.coordinateTransformMode,x=c.cubicCoeffA,S=c.excludeOutside!==0,A=c.extrapolationValue,$=c.keepAspectRatioPolicy,D=c.mode,k=c.nearestMode===""?"simple":c.nearestMode;return rn({antialias:p,axes:g,coordinateTransformMode:b,cubicCoeffA:x,excludeOutside:S,extrapolationValue:A,keepAspectRatioPolicy:$,mode:D,nearestMode:k})}}),$v,_v,Dv,MP=u(()=>{vt(),Et(),Cn(),Ct(),$v=(c,p)=>{let[g,b,x,S]=c,{numHeads:A,rotaryEmbeddingDim:$}=p;if(g.dims.length!==3&&g.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${g.dims.length}`);if(!Ae.areEqual(b.dims,[])&&!Ae.areEqual(b.dims,[1])&&b.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${b.dims.length}`);if(x.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${x.dims.length}`);if(S.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${S.dims.length}`);if(!Ae.areEqual(x.dims,S.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if($>0&&A===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let D=g.dims[0],k=g.dims[g.dims.length-2],O=x.dims[0],R=Ae.sizeFromDimension(g.dims,1)/k,V=$===0?x.dims[1]*2:R/A;if($>V)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(b.dims.length===2){if(D!==b.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${b.dims[0]}`);if(k!==b.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${b.dims[1]}`)}if(V/2!==x.dims[1]&&$/2!==x.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${x.dims[1]}`);if(k>O)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},_v=(c,p)=>{let{interleaved:g,numHeads:b,rotaryEmbeddingDim:x,scale:S}=p,A=c[0].dims[0],$=Ae.sizeFromDimension(c[0].dims,1),D=c[0].dims[c[0].dims.length-2],k=$/D,O=c[2].dims[1],R=x===0?O*2:k/b,V=new Array(A,D,k/R,R-O),F=Ae.computeStrides(V),z=[{type:1,data:S},{type:12,data:V},{type:12,data:F},...c[0].dims.length===3?new Array({type:12,data:[$,k,R,1]}):[],...c[0].dims.length===4?new Array({type:12,data:[$,R,D*R,1]}):[],...It(c[0].dims,c[1].dims,c[2].dims,c[3].dims,c[0].dims)],G=X=>{let K=Ce("input",c[0].dataType,c[0].dims.length),q=Ce("position_ids",c[1].dataType,c[1].dims.length),te=Ce("cos_cache",c[2].dataType,c[2].dims.length),ee=Ce("sin_cache",c[3].dataType,c[3].dims.length),re=ht("output",c[0].dataType,c[0].dims.length);return X.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:V.length},{name:"global_strides",type:"u32",length:F.length},{name:"input_output_strides",type:"u32",length:F.length}]),`
        ${X.declareVariables(K,q,te,ee,re)}

        ${X.mainStart(Vl)}
          let half_rotary_emb_dim = uniforms.${te.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${X.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${q.broadcastedIndicesToOffset("bsnh.xy",ht("",q.type.tensor,2))};
            let position_id =
                u32(${q.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${g});
            let j = i + select(half_rotary_emb_dim, 1, ${g});
            let re = ${K.getByOffset("i")} * ${te.get("position_id","bsnh[3]")} -
                ${K.getByOffset("j")} * ${ee.get("position_id","bsnh[3]")};
            ${re.setByOffset("i","re")}
            let im = ${K.getByOffset("i")} * ${ee.get("position_id","bsnh[3]")} +
                ${K.getByOffset("j")} * ${te.get("position_id","bsnh[3]")};
            ${re.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${re.setByOffset("k",K.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:rn({interleaved:g}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:G,getRunData:()=>({outputs:[{dims:c[0].dims,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(Ae.size(V)/Vl)},programUniforms:z})}},Dv=(c,p)=>{$v(c.inputs,p),c.compute(_v(c.inputs,p))}}),Ev,kv,Cv,WP=u(()=>{vt(),Et(),Ct(),Ev=c=>{if(!c||c.length<3)throw new Error("layerNorm requires at least 3 inputs.");let p=c[0],g=c[1],b=c[2];if(p.dataType!==g.dataType||p.dataType!==b.dataType)throw new Error("All inputs must have the same data type");if(p.dims.length!==3&&p.dims.length!==2)throw new Error("Input must be 2D or 3D");if(g.dims.length!==3&&g.dims.length!==2)throw new Error("Skip must be 2D or 3D");let x=p.dims[p.dims.length-1],S=p.dims[p.dims.length-2];if(g.dims[g.dims.length-1]!==x)throw new Error("Skip must have the same hidden size as input");if(g.dims[g.dims.length-2]!==S)throw new Error("Skip must have the same sequence length as input");if(b.dims.length!==1)throw new Error("Gamma must be 1D");if(b.dims[b.dims.length-1]!==x)throw new Error("Gamma must have the same hidden size as input");if(c.length>3){let A=c[3];if(A.dims.length!==1)throw new Error("Beta must be 1D");if(A.dims[A.dims.length-1]!==x)throw new Error("Beta must have the same hidden size as input")}if(c.length>4){let A=c[4];if(A.dims.length!==1)throw new Error("Bias must be 1D");if(A.dims[A.dims.length-1]!==x)throw new Error("Bias must have the same hidden size as input")}},kv=(c,p,g,b)=>{let x=p.simplified,S=c[0].dims,A=Ae.size(S),$=S,D=A,k=S.slice(-1)[0],O=b?S.slice(0,-1).concat(1):[],R=!x&&c.length>3,V=c.length>4,F=b&&g>1,z=b&&g>2,G=g>3,X=64,K=Sn(k),q=[{type:12,data:D},{type:12,data:K},{type:12,data:k},{type:1,data:p.epsilon}],te=re=>{let me=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],Ne=[Ce("x",c[0].dataType,c[0].dims,K),Ce("skip",c[1].dataType,c[1].dims,K),Ce("gamma",c[2].dataType,c[2].dims,K)];R&&Ne.push(Ce("beta",c[3].dataType,c[3].dims,K)),V&&Ne.push(Ce("bias",c[4].dataType,c[4].dims,K)),Ne.push(ht("output",c[0].dataType,$,K)),F&&Ne.push(ht("mean_output",1,O)),z&&Ne.push(ht("inv_std_output",1,O)),G&&Ne.push(ht("input_skip_bias_sum",c[0].dataType,$,K));let Ve=ns(c[0].dataType),Ke=ns(1,K);return`

      ${re.registerUniforms(me).declareVariables(...Ne)}
      var<workgroup> sum_shared : array<${Ke}, ${X}>;
      var<workgroup> sum_squared_shared : array<${Ke}, ${X}>;

      ${re.mainStart([X,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${X};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${X};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${X-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${V?"bias[offset1d + i]":Ve+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${G?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Pl(Ve,K,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${X};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Ta("sum",K)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Ta("square_sum",K)} / f32(uniforms.hidden_size) ${x?"":"- mean * mean"} + uniforms.epsilon);
        ${F?"mean_output[global_idx] = mean;":""}
        ${z?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${x?"":`- ${Ve}(mean)`}) *
            ${Ve}(inv_std_dev) * gamma[offset1d + i]
            ${R?"+ beta[offset1d + i]":""};
        }
      }`},ee=[{dims:$,dataType:c[0].dataType}];return g>1&&ee.push({dims:O,dataType:1}),g>2&&ee.push({dims:O,dataType:1}),g>3&&ee.push({dims:S,dataType:c[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${K};${F};${z};${G}`,inputDependencies:c.map((re,me)=>"type")},getShaderSource:te,getRunData:()=>({outputs:ee,dispatchGroup:{x:Math.ceil(D/k)},programUniforms:q})}},Cv=(c,p)=>{Ev(c.inputs);let g=[0];c.outputCount>1&&g.push(-3),c.outputCount>2&&g.push(-3),c.outputCount>3&&g.push(3),c.compute(kv(c.inputs,p,c.outputCount,!1),{outputs:g})}}),Lv,rc,Ov,C0,Rv,Vv,Pv,Fv,BP=u(()=>{vt(),Et(),Cn(),Ct(),Lv=(c,p)=>{if(!c||c.length<1)throw new Error("too few inputs");if(p.axes.length!==0){if(p.axes.length!==p.starts.length||p.axes.length!==p.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(p.starts.length!==p.ends.length)throw new Error("starts and ends must have the same length");c.slice(1).forEach((g,b)=>{if(c[b+1].dataType!==6&&c[b+1].dataType!==7)throw new Error(`Input ${b} must be an array of int32 or int64`)})},rc=(c,p)=>{let g=[];if(c.length>p)if(c[p].dataType===7)c[p].getBigInt64Array().forEach(b=>g.push(Number(b)));else if(c[p].dataType===6)c[p].getInt32Array().forEach(b=>g.push(Number(b)));else throw new Error(`Input ${p} must be an array of int32 or int64`);return g},Ov=(c,p)=>{if(c.length>1){let g=rc(c,1),b=rc(c,2),x=rc(c,3);return x.length===0&&(x=[...Array(c[0].dims.length).keys()]),rn({starts:g,ends:b,axes:x})}else return p},C0=(c,p,g,b,x)=>{let S=c;return c<0&&(S+=g[b[p]]),x[p]<0?Math.max(0,Math.min(S,g[b[p]]-1)):Math.max(0,Math.min(S,g[b[p]]))},Rv=(c,p,g)=>`fn calculateInputIndices(output_indices: ${p.type.indices}) -> ${c.type.indices} {
          var input_indices: ${c.type.indices};
          var carry = 0u;
          for (var i = ${g.length}; i >= 0; i--) {
            let input_shape_i = ${pt("uniforms.input_shape","i",g.length)};
            let steps_i = ${pt("uniforms.steps","i",g.length)};
            let signs_i = ${pt("uniforms.signs","i",g.length)};
            let starts_i = ${pt("uniforms.starts","i",g.length)};
            var output_index = ${p.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${c.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Vv=(c,p)=>{let g=c[0].dims,b=Ae.size(g),x=p.axes.length>0?Ae.normalizeAxes(p.axes,g.length):[...Array(g.length).keys()],S=rc(c,4);S.forEach(K=>K!==0||(()=>{throw new Error("step cannot be 0")})),S.length===0&&(S=Array(x.length).fill(1));let A=p.starts.map((K,q)=>C0(K,q,g,x,S)),$=p.ends.map((K,q)=>C0(K,q,g,x,S));if(x.length!==A.length||x.length!==$.length)throw new Error("start, ends and axes should have the same number of elements");if(x.length!==g.length)for(let K=0;K<g.length;++K)x.includes(K)||(A.splice(K,0,0),$.splice(K,0,g[K]),S.splice(K,0,1));let D=S.map(K=>Math.sign(K));S.forEach((K,q,te)=>{if(K<0){let ee=($[q]-A[q])/K,re=A[q],me=re+ee*S[q];A[q]=me,$[q]=re,te[q]=-K}});let k=g.slice(0);x.forEach((K,q)=>{k[K]=Math.ceil(($[K]-A[K])/S[K])});let O={dims:k,dataType:c[0].dataType},R=ht("output",c[0].dataType,k.length),V=Ce("input",c[0].dataType,c[0].dims.length),F=Ae.size(k),z=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:A.length},{name:"signs",type:"i32",length:D.length},{name:"steps",type:"u32",length:S.length}],G=[{type:12,data:F},{type:12,data:A},{type:6,data:D},{type:12,data:S},...It(c[0].dims,k)],X=K=>`
      ${K.registerUniforms(z).declareVariables(V,R)}
        ${Rv(V,R,g)}
        ${K.mainStart()}
          ${K.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${R.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${R.setByOffset("global_idx",V.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${D.length}_${A.length}_${S.length}`,inputDependencies:["rank"]},getShaderSource:X,getRunData:()=>({outputs:[O],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:G})}},Pv=(c,p)=>{Lv(c.inputs,p);let g=Ov(c.inputs,p);c.compute(Vv(c.inputs,g),{inputs:[0]})},Fv=c=>{let p=c.starts,g=c.ends,b=c.axes;return rn({starts:p,ends:g,axes:b})}}),zv,Mv,Wv,Bv,HP=u(()=>{vt(),Et(),Cn(),Sa(),Ct(),zv=c=>{if(!c||c.length!==1)throw new Error("Softmax op requires 1 input.")},Mv=(c,p)=>{let g=c.inputs[0],b=g.dims,x=Ae.size(b),S=b.length,A=Ae.normalizeAxis(p.axis,S),$=A<b.length-1,D,k=[];$?(k=Array.from({length:S},(Ne,Ve)=>Ve),k[A]=S-1,k[S-1]=A,D=c.compute(Nr(g,k),{inputs:[g],outputs:[-1]})[0]):D=g;let O=D.dims,R=O[S-1],V=x/R,F=Sn(R),z=R/F,G=64;V===1&&(G=256);let X=(Ne,Ve)=>Ve===4?`max(max(${Ne}.x, ${Ne}.y), max(${Ne}.z, ${Ne}.w))`:Ve===2?`max(${Ne}.x, ${Ne}.y)`:Ve===3?`max(max(${Ne}.x, ${Ne}.y), ${Ne}.z)`:Ne,K=Ce("x",D.dataType,D.dims,F),q=ht("result",D.dataType,D.dims,F),te=K.type.value,ee=ns(D.dataType)==="f32"?`var threadMax = ${te}(-3.402823e+38f);`:`var threadMax = ${te}(-65504.0h);`,re=Ne=>`
      var<workgroup> rowMaxShared : ${te};
      var<workgroup> rowSumShared : ${te};
      var<workgroup> threadShared : array<${te}, ${G}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${te} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${te}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${Ne.registerUniform("packedCols","i32").declareVariables(K,q)}
      ${Ne.mainStart(G)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${G};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${ee}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${te}(${X("threadShared[0]",F)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${te}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${te}(${Ta("threadShared[0]",F)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,me=c.compute({name:"Softmax",shaderCache:{hint:`${F};${G}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:O,dataType:D.dataType}],dispatchGroup:{x:V},programUniforms:[{type:6,data:z}]}),getShaderSource:re},{inputs:[D],outputs:[$?-1:0]})[0];$&&c.compute(Nr(me,k),{inputs:[me]})},Wv=(c,p)=>{zv(c.inputs),Mv(c,p)},Bv=c=>rn({axis:c.axis})}),L0,Hv,Uv,Gv,qv,UP=u(()=>{vt(),Et(),Ct(),L0=c=>Array.from(c.getBigInt64Array(),Number),Hv=c=>{if(!c||c.length!==2)throw new Error("Tile requires 2 inputs.");if(c[0].dataType!==1&&c[0].dataType!==10&&c[0].dataType!==6&&c[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(c[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(c[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(L0(c[1]).length!==c[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Uv=(c,p)=>{let g=[];for(let b=0;b<c.length;++b)g.push(c[b]*p[b]);return g},Gv=(c,p)=>{let g=c[0].dims,b=p??L0(c[1]),x=Uv(g,b),S=Ae.size(x),A=c[0].dataType,$=Ce("input",A,g.length),D=ht("output",A,x.length),k=O=>`
      const inputShape = ${$.indices(...g)};
      ${O.registerUniform("output_size","u32").declareVariables($,D)}
      ${O.mainStart()}
      ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${D.offsetToIndices("global_idx")};
      var input_indices: ${$.type.indices};
      for (var i = 0; i < ${g.length}; i++) {
        let input_dim_i = ${$.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${D.indicesGet("output_indices","i")}  % input_dim_i;

        ${$.indicesSet("input_indices","i","input_dim_value")}
      }
      ${D.setByOffset("global_idx",$.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${b}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:x,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(S/64)},programUniforms:[{type:12,data:S},...It(c[0].dims,x)]}),getShaderSource:k}},qv=c=>{Hv(c.inputs),c.compute(Gv(c.inputs),{inputs:[0]})}}),Kv,jv,Yv,GP=u(()=>{vt(),Et(),Ct(),Kv=(c,p,g,b,x)=>{let S=ht("output_data",x,g.length,4),A=Ce("a_data",p[1].dataType,p[1].dims.length,4),$=Ce("b_data",p[2].dataType,p[2].dims.length,4),D=Ce("c_data",p[0].dataType,p[0].dims.length,4),k,O=(R,V,F)=>`select(${V}, ${R}, ${F})`;if(!b)k=S.setByOffset("global_idx",O(A.getByOffset("global_idx"),$.getByOffset("global_idx"),D.getByOffset("global_idx")));else{let R=(V,F,z="")=>{let G=`a_data[index_a${F}][component_a${F}]`,X=`b_data[index_b${F}][component_b${F}]`,K=`bool(c_data[index_c${F}] & (0xffu << (component_c${F} * 8)))`;return`
            let output_indices${F} = ${S.offsetToIndices(`global_idx * 4u + ${F}u`)};
            let offset_a${F} = ${A.broadcastedIndicesToOffset(`output_indices${F}`,S)};
            let offset_b${F} = ${$.broadcastedIndicesToOffset(`output_indices${F}`,S)};
            let offset_c${F} = ${D.broadcastedIndicesToOffset(`output_indices${F}`,S)};
            let index_a${F} = offset_a${F} / 4u;
            let index_b${F} = offset_b${F} / 4u;
            let index_c${F} = offset_c${F} / 4u;
            let component_a${F} = offset_a${F} % 4u;
            let component_b${F} = offset_b${F} % 4u;
            let component_c${F} = offset_c${F} % 4u;
            ${V}[${F}] = ${z}(${O(G,X,K)});
          `};x===9?k=`
            var data = vec4<u32>(0);
            ${R("data",0,"u32")}
            ${R("data",1,"u32")}
            ${R("data",2,"u32")}
            ${R("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:k=`
            ${R("output_data[global_idx]",0)}
            ${R("output_data[global_idx]",1)}
            ${R("output_data[global_idx]",2)}
            ${R("output_data[global_idx]",3)}
          `}return`
        ${c.registerUniform("vec_size","u32").declareVariables(D,A,$,S)}
        ${c.mainStart()}
        ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${k}
      }`},jv=c=>{let p=c[1].dims,g=c[2].dims,b=c[0].dims,x=c[1].dataType,S=!(Ae.areEqual(p,g)&&Ae.areEqual(g,b)),A=p,$=Ae.size(p);if(S){let k=Rl.calcShape(Rl.calcShape(p,g,!1),b,!1);if(!k)throw new Error("Can't perform where op on the given tensors");A=k,$=Ae.size(A)}let D=Math.ceil($/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:k=>Kv(k,c,A,S,x),getRunData:()=>({outputs:[{dims:A,dataType:x}],dispatchGroup:{x:Math.ceil($/64/4)},programUniforms:[{type:12,data:D},...It(b,p,g,A)]})}},Yv=c=>{c.compute(jv(c.inputs))}}),Xv,qP=u(()=>{iP(),Yg(),aP(),oP(),lP(),uP(),cP(),mP(),IP(),yP(),bP(),xP(),NP(),wP(),AP(),TP(),SP(),vP(),$P(),_P(),DP(),EP(),kP(),CP(),LP(),uS(),OP(),RP(),VP(),PP(),FP(),qg(),zP(),MP(),WP(),BP(),HP(),gS(),UP(),Sa(),Jg(),GP(),Xv=new Map([["Abs",[kw]],["Acos",[Cw]],["Acosh",[Lw]],["Add",[xA]],["ArgMax",[gw,jg]],["ArgMin",[mw,jg]],["Asin",[Ow]],["Asinh",[Rw]],["Atan",[Vw]],["Atanh",[Pw]],["Attention",[ww]],["AveragePool",[GS,US]],["BatchNormalization",[vw]],["BiasAdd",[Dw]],["BiasSplitGelu",[IA]],["Cast",[zw,Fw]],["Ceil",[Bw]],["Clip",[Ww]],["Concat",[OA,RA]],["Conv",[h0,c0]],["ConvTranspose",[lT,iT]],["Cos",[Hw]],["Cosh",[Uw]],["CumSum",[cT,dT]],["DepthToSpace",[mT,gT]],["DequantizeLinear",[ev,tv]],["Div",[NA]],["Einsum",[wT,AT]],["Elu",[Gw,Qu]],["Equal",[wA]],["Erf",[qw]],["Exp",[Kw]],["Expand",[$T]],["FastGelu",[DT]],["Floor",[jw]],["FusedConv",[h0,c0]],["Gather",[LT,CT]],["GatherElements",[UT,HT]],["GatherBlockQuantized",[zT,MT]],["GatherND",[RT,VT]],["Gelu",[Yw]],["Gemm",[jT,KT]],["GlobalAveragePool",[KS,qS]],["GlobalMaxPool",[ZS,XS]],["Greater",[vA]],["GreaterOrEqual",[_A]],["GridSample",[sS,rS]],["GroupQueryAttention",[bS]],["HardSigmoid",[sA,nA]],["InstanceNormalization",[wS]],["LayerNormalization",[SS]],["LeakyRelu",[Xw,Qu]],["Less",[$A]],["LessOrEqual",[DA]],["Log",[dA]],["MatMul",[$S]],["MatMulNBits",[kS,CS]],["MaxPool",[jS,YS]],["Mul",[AA]],["MultiHeadAttention",[lS,aS]],["Neg",[Qw]],["Not",[Zw]],["Pad",[WS]],["Pow",[TA]],["QuickGelu",[fA,Qu]],["Range",[rv]],["Reciprocal",[Jw]],["ReduceMin",[cw]],["ReduceMean",[iw]],["ReduceMax",[uw]],["ReduceSum",[hw]],["ReduceProd",[dw]],["ReduceL1",[aw]],["ReduceL2",[ow]],["ReduceLogSum",[fw]],["ReduceLogSumExp",[lw]],["ReduceSumSquare",[pw]],["Relu",[eA]],["Resize",[Sv,vv]],["RotaryEmbedding",[Dv]],["ScatterND",[lv,ov]],["Sigmoid",[tA]],["Sin",[rA]],["Sinh",[iA]],["Slice",[Pv,Fv]],["SkipLayerNormalization",[Cv]],["Split",[fS,mS]],["Sqrt",[aA]],["Softmax",[Wv,Bv]],["Sub",[SA]],["Tan",[oA]],["Tanh",[lA]],["ThresholdedRelu",[cA,Qu]],["Tile",[qv]],["Transpose",[vN,$N]],["Where",[Yv]]])}),Zv,KP=u(()=>{dt(),Qi(),Ct(),Zv=class{constructor(c){this.backend=c,this.repo=new Map,this.attributesBound=!1}getArtifact(c){return this.repo.get(c)}setArtifact(c,p){this.repo.set(c,p)}run(c,p,g,b,x){Q(c.programInfo.name);let S=this.backend.device,A=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let $=[];for(let k of p)$.push({binding:$.length,resource:{buffer:k.buffer}});for(let k of g)$.push({binding:$.length,resource:{buffer:k.buffer}});x&&$.push({binding:$.length,resource:x});let D=S.createBindGroup({layout:c.computePipeline.getBindGroupLayout(0),entries:$,label:c.programInfo.name});if(this.backend.sessionStatus==="capturing"){let k={kernelId:this.backend.currentKernelId,computePipeline:c.computePipeline,bindGroup:D,dispatchGroup:b};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(k)}A.setPipeline(c.computePipeline),A.setBindGroup(0,D),A.dispatchWorkgroups(...b),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),ue(c.programInfo.name)}dispose(){}build(c,p){Q(c.name);let g=this.backend.device,b=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"},{feature:"subgroups-f16",extension:"subgroups_f16"}].forEach(k=>{g.features.has(k.feature)&&b.push(`enable ${k.extension};`)});let x=xN(p,this.backend.device.limits),S=c.getShaderSource(x),A=`${b.join(`
`)}
${x.additionalImplementations}
${S}`,$=g.createShaderModule({code:A,label:c.name});jt("verbose",()=>`[WebGPU] ${c.name} shader code: ${A}`);let D=g.createComputePipeline({compute:{module:$,entryPoint:"main"},layout:"auto",label:c.name});return ue(c.name),{programInfo:c,computePipeline:D,uniformVariablesInfo:x.variablesInfo}}normalizeDispatchGroupSize(c){let p=typeof c=="number"?c:c.x,g=typeof c=="number"?1:c.y||1,b=typeof c=="number"?1:c.z||1,x=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(p<=x&&g<=x&&b<=x)return[p,g,b];let S=p*g*b,A=Math.ceil(Math.sqrt(S));if(A>x){if(A=Math.ceil(Math.cbrt(S)),A>x)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[A,A,A]}else return[A,A,1]}}}),Qv,Jv,e$,t$,n$,jP=u(()=>{dt(),vt(),Qi(),lN(),sP(),qP(),KP(),Qv=(c,p)=>{if(p.length!==c.length)throw new Error(`inputDependencies length ${p.length} is not equal to inputTensors length ${c.length}.`);let g=[];for(let b=0;b<c.length;++b){let x=c[b].dataType;switch(p[b]){case"none":{g.push("");break}case"type":{g.push(`${x}`);break}case"rank":{let S=c[b].dims.length;g.push(`${x};${S}`);break}case"dims":{let S=c[b].dims.join(",");g.push(`${x};${S}`);break}default:throw new Error(`unsupported input dependency: ${p[b]}`)}}return g.join("|")},Jv=(c,p,g)=>{var x,S;let b=c.name;return(x=c.shaderCache)!=null&&x.hint&&(b+="["+c.shaderCache.hint+"]"),b+=":"+g+`:${Qv(p,((S=c.shaderCache)==null?void 0:S.inputDependencies)??new Array(p.length).fill("dims"))}`,b},e$=class{constructor(c){c&&(this.architecture=c.architecture,this.vendor=c.vendor)}isArchitecture(c){return this.architecture===c}isVendor(c){return this.vendor===c}},t$=class{constructor(c){this.subgroupsSupported=c.features.has("subgroups"),this.subgroupsF16Supported=c.features.has("subgroups");let p=c.limits;!this.subgroupsSupported||!p.minSubgroupSize||!p.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[p.minSubgroupSize,p.maxSubgroupSize]}},n$=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let c=this.kernelCustomData.get(this.currentKernelId);return c||(c={},this.kernelCustomData.set(this.currentKernelId,c)),c}async initialize(c,p){this.env=c;let g=[],b={requiredLimits:{maxComputeWorkgroupStorageSize:p.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:p.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:p.limits.maxStorageBufferBindingSize,maxBufferSize:p.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:p.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:p.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:p.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:p.limits.maxComputeWorkgroupSizeZ},requiredFeatures:g},x=S=>p.features.has(S)&&g.push(S)&&!0;x("chromium-experimental-timestamp-query-inside-passes")||x("timestamp-query"),x("shader-f16"),x("subgroups")&&x("subgroups-f16"),this.device=await p.requestDevice(b),this.deviceInfo=new t$(this.device),this.adapterInfo=new e$(p.info||await p.requestAdapterInfo()),this.gpuDataManager=hN(this),this.programManager=new Zv(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Vg(c.logLevel,!!c.debug),this.device.onuncapturederror=S=>{S.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${S.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:p,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let c=this.getCommandEncoder(),p={};this.queryType==="at-passes"&&(p.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=c.beginComputePass(p)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Q(),this.endComputePass();let c;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),c=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(c,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,c,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&c.mapAsync(GPUMapMode.READ).then(()=>{var b;let p=new BigUint64Array(c.getMappedRange()),g=this.pendingQueries.get(c);for(let x=0;x<p.length/2;x++){let S=g[x],A=S.kernelId,$=this.kernels.get(A),D=$.kernelType,k=$.kernelName,O=S.programName,R=S.inputTensorViews,V=S.outputTensorViews,F=p[x*2],z=p[x*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=F);let G=Number(F-this.queryTimeBase),X=Number(z-this.queryTimeBase);if(!Number.isSafeInteger(G)||!Number.isSafeInteger(X))throw new RangeError("incorrect timestamp range");if((b=this.env.webgpu.profiling)!=null&&b.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:R.map(K=>({dims:K.dims,dataType:xo(K.dataType)})),outputsMetadata:V.map(K=>({dims:K.dims,dataType:xo(K.dataType)})),kernelId:A,kernelType:D,kernelName:k,programName:O,startTime:G,endTime:X});else{let K="";R.forEach((te,ee)=>{K+=`input[${ee}]: [${te.dims}] | ${xo(te.dataType)}, `});let q="";V.forEach((te,ee)=>{q+=`output[${ee}]: [${te.dims}] | ${xo(te.dataType)}, `}),console.log(`[profiling] kernel "${A}|${D}|${k}|${O}" ${K}${q}execution time: ${X-G} ns`)}xt("GPU",`${O}::${F}::${z}`)}c.unmap(),this.pendingQueries.delete(c)}),ue()}run(c,p,g,b,x,S){Q(c.name);let A=[];for(let q=0;q<p.length;++q){let te=p[q].data;if(te===0)continue;let ee=this.gpuDataManager.get(te);if(!ee)throw new Error(`no GPU data for input: ${te}`);A.push(ee)}let{outputs:$,dispatchGroup:D,programUniforms:k}=c.getRunData(p),O=g.length===0?$.map((q,te)=>te):g;if(O.length!==$.length)throw new Error(`Output size ${O.length} must be equal to ${$.length}.`);let R=[],V=[];for(let q=0;q<$.length;++q){if(!Number.isInteger(O[q])||O[q]<-3||O[q]>=S)throw new Error(`Invalid output index: ${O[q]}`);if(O[q]===-3)continue;let te=O[q]===-1,ee=O[q]===-2,re=te||ee?x($[q].dataType,$[q].dims):b(O[q],$[q].dataType,$[q].dims);if(R.push(re),re.data===0)continue;let me=this.gpuDataManager.get(re.data);if(!me)throw new Error(`no GPU data for output: ${re.data}`);if(te&&this.temporaryData.push(me),ee){let Ne=this.kernelPersistentData.get(this.currentKernelId);Ne||(Ne=[],this.kernelPersistentData.set(this.currentKernelId,Ne)),Ne.push(me)}V.push(me)}if(A.length!==p.length||V.length!==R.length){if(V.length===0)return ue(c.name),R;throw new Error(`Program ${c.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let F;if(k){let q=0,te=[];k.forEach(Ne=>{let Ve=typeof Ne.data=="number"?[Ne.data]:Ne.data;if(Ve.length===0)return;let Ke=Ne.type===10?2:4,lt,_t;Ne.type===10?(_t=Ve.length>4?16:Ve.length>2?8:Ve.length*Ke,lt=Ve.length>4?16:Ke*Ve.length):(_t=Ve.length<=2?Ve.length*Ke:16,lt=16),q=Math.ceil(q/_t)*_t,te.push(q);let Ot=Ne.type===10?8:4;q+=Ve.length>4?Math.ceil(Ve.length/Ot)*lt:Ve.length*Ke});let ee=16;q=Math.ceil(q/ee)*ee;let re=new ArrayBuffer(q);k.forEach((Ne,Ve)=>{let Ke=te[Ve],lt=typeof Ne.data=="number"?[Ne.data]:Ne.data;if(Ne.type===6)new Int32Array(re,Ke,lt.length).set(lt);else if(Ne.type===12)new Uint32Array(re,Ke,lt.length).set(lt);else if(Ne.type===10)new Uint16Array(re,Ke,lt.length).set(lt);else if(Ne.type===1)new Float32Array(re,Ke,lt.length).set(lt);else throw new Error(`Unsupported uniform type: ${xo(Ne.type)}`)});let me=this.gpuDataManager.create(q,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(me.buffer,0,re,0,q),this.gpuDataManager.release(me.id),F={offset:0,size:q,buffer:me.buffer}}let z=this.programManager.normalizeDispatchGroupSize(D),G=z[1]===1&&z[2]===1,X=Jv(c,p,G),K=this.programManager.getArtifact(X);if(K||(K=this.programManager.build(c,z),this.programManager.setArtifact(X,K),jt("info",()=>`[artifact] key: ${X}, programName: ${c.name}`)),k&&K.uniformVariablesInfo){if(k.length!==K.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${K.uniformVariablesInfo.length}, got ${k.length} in program "${K.programInfo.name}".`);for(let q=0;q<k.length;q++){let te=k[q],ee=te.type,re=typeof te.data=="number"?1:te.data.length,[me,Ne]=K.uniformVariablesInfo[q];if(ee!==me||re!==Ne)throw new Error(`Uniform variable ${q} mismatch: expect type ${me} with size ${Ne}, got type ${ee} with size ${re} in program "${K.programInfo.name}".`)}}if(jt("info",()=>`[ProgramManager] run "${c.name}" (key=${X}) with ${z[0]}x${z[1]}x${z[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let q={kernelId:this.currentKernelId,programName:K.programInfo.name,inputTensorViews:p,outputTensorViews:R};this.pendingKernels.push(q),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(q)}return this.programManager.run(K,A,V,z,F),ue(c.name),R}upload(c,p){this.gpuDataManager.upload(c,p)}memcpy(c,p){this.gpuDataManager.memcpy(c,p)}async download(c,p){await this.gpuDataManager.download(c,p)}alloc(c){return this.gpuDataManager.create(c).id}free(c){return this.gpuDataManager.release(c)}createKernel(c,p,g,b){let x=Xv.get(c);if(!x)throw new Error(`kernel not implemented: ${c}`);let S={kernelType:c,kernelName:b,kernelEntry:x[0],attributes:[x[1],g]};this.kernels.set(p,S)}releaseKernel(c){let p=this.kernelPersistentData.get(c);if(p){for(let g of p)this.gpuDataManager.release(g.id);this.kernelPersistentData.delete(c)}this.kernelCustomData.delete(c),this.kernels.delete(c)}computeKernel(c,p,g){let b=this.kernels.get(c);if(!b)throw new Error(`kernel not created: ${c}`);let x=b.kernelType,S=b.kernelName,A=b.kernelEntry,$=b.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${x}] ${S}" is not allowed to be called recursively`);this.currentKernelId=c,$[0]&&($[1]=$[0]($[1]),$[0]=void 0),jt("info",()=>`[WebGPU] Start to run kernel "[${x}] ${S}"...`);let D=this.env.debug;this.temporaryData=[];try{return D&&this.device.pushErrorScope("validation"),A(p,$[1]),0}catch(k){return g.push(Promise.resolve(`[WebGPU] Kernel "[${x}] ${S}" failed. ${k}`)),1}finally{D&&g.push(this.device.popErrorScope().then(k=>k?`GPU validation error for kernel "[${x}] ${S}": ${k.message}`:null));for(let k of this.temporaryData)this.gpuDataManager.release(k.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(c,p,g,b){let x=this.sessionExternalDataMapping.get(c);x||(x=new Map,this.sessionExternalDataMapping.set(c,x));let S=x.get(p),A=this.gpuDataManager.registerExternalBuffer(g,b,S);return x.set(p,[A,g]),A}unregisterBuffers(c){let p=this.sessionExternalDataMapping.get(c);p&&(p.forEach(g=>this.gpuDataManager.unregisterExternalBuffer(g[0])),this.sessionExternalDataMapping.delete(c))}getBuffer(c){let p=this.gpuDataManager.get(c);if(!p)throw new Error(`no GPU data for buffer: ${c}`);return p.buffer}createDownloader(c,p,g){return async()=>{let b=await Wg(this,c,p);return Pg(b.buffer,g)}}writeTimestamp(c){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,c)}setQueryType(){var c;this.queryType="none",(((c=this.env.webgpu.profiling)==null?void 0:c.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){jt("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){jt("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){jt("info","replay"),this.sessionStatus="replaying";let c=this.capturedCommandList.get(this.currentSessionId),p=this.capturedPendingKernels.get(this.currentSessionId),g=c.length;this.pendingKernels=[];for(let b=0;b<g;b++){let x=this.getComputePassEncoder(),S=c[b];this.writeTimestamp(this.pendingDispatchNumber*2),x.setPipeline(S.computePipeline),x.setBindGroup(0,S.bindGroup),x.dispatchWorkgroups(...S.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(p[b]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(c){this.unregisterBuffers(c),this.capturedCommandList.has(c)&&this.capturedCommandList.delete(c),this.capturedPendingKernels.has(c)&&this.capturedPendingKernels.delete(c),this.gpuDataManager.onReleaseSession(c)}onRunStart(c){this.currentSessionId=c,this.setQueryType()}}}),s$,O0,r$,R0,V0,P0,i$,a$,YP=u(()=>{Qi(),s$=1,O0=()=>s$++,r$=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),R0=(c,p)=>{let g=r$.get(c);if(!g)throw new Error("Unsupported data type.");return p.length>0?Math.ceil(p.reduce((b,x)=>b*x)*g/8):0},V0=class{constructor(c){this.sessionId=c.sessionId,this.mlContext=c.context,this.mlTensor=c.tensor,this.dataType=c.dataType,this.tensorShape=c.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return R0(this.dataType,this.tensorShape)}destroy(){jt("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(c){this.mlContext.writeTensor(this.mlTensor,c)}async read(c){return c?this.mlContext.readTensor(this.mlTensor,c):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(c,p,g){return this.mlContext===c&&this.dataType===p&&this.tensorShape.length===g.length&&this.tensorShape.every((b,x)=>b===g[x])}},P0=class{constructor(c,p){this.tensorManager=c,this.wrapper=p}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(c,p,g,b){let x=this.tensorManager.getMLContext(c);if(this.wrapper){if(this.wrapper.canReuseTensor(x,p,g))return this.wrapper.tensor;if(b){if(this.wrapper.byteLength!==R0(p,g))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let S=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(c,p,g,S,!0,!0),b&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(c){if(this.wrapper)if(c.byteLength===this.wrapper.byteLength){this.wrapper.write(c);return}else jt("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(c):this.activeUpload=new Uint8Array(c)}async download(c){if(this.activeUpload)if(c){c instanceof ArrayBuffer?new Uint8Array(c).set(this.activeUpload):new Uint8Array(c.buffer,c.byteOffset,c.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return c?this.wrapper.read(c):this.wrapper.read()}},i$=class{constructor(c){this.backend=c,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(c){let p=this.backend.getMLContext(c);if(!p)throw new Error("MLContext not found for session.");return p}reserveTensorId(){let c=O0();return this.tensorTrackersById.set(c,new P0(this)),c}releaseTensorId(c){let p=this.tensorTrackersById.get(c);p&&(this.tensorTrackersById.delete(c),p.tensorWrapper&&this.releaseTensor(p.tensorWrapper))}async ensureTensor(c,p,g,b,x){jt("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${p}, dataType: ${g}, shape: ${b}, copyOld: ${x}}`);let S=this.tensorTrackersById.get(p);if(!S)throw new Error("Tensor not found.");return S.ensureTensor(c,g,b,x)}upload(c,p){let g=this.tensorTrackersById.get(c);if(!g)throw new Error("Tensor not found.");g.upload(p)}async download(c,p){jt("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${c}, dstBuffer: ${p==null?void 0:p.byteLength}}`);let g=this.tensorTrackersById.get(c);if(!g)throw new Error("Tensor not found.");return g.download(p)}releaseTensorsForSession(c){for(let p of this.freeTensors)p.sessionId===c&&p.destroy();this.freeTensors=this.freeTensors.filter(p=>p.sessionId!==c)}registerTensor(c,p,g,b){let x=this.getMLContext(c),S=O0(),A=new V0({sessionId:c,context:x,tensor:p,dataType:g,shape:b});return this.tensorTrackersById.set(S,new P0(this,A)),this.externalTensors.add(A),S}async getCachedTensor(c,p,g,b,x,S){let A=this.getMLContext(c);for(let[D,k]of this.freeTensors.entries())if(k.canReuseTensor(A,p,g)){jt("verbose",()=>`[WebNN] Reusing tensor {dataType: ${p}, shape: ${g}}`);let O=this.freeTensors.splice(D,1)[0];return O.sessionId=c,O}jt("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${p}, shape: ${g}}`);let $=await A.createTensor({dataType:p,shape:g,dimensions:g,usage:b,writable:x,readable:S});return new V0({sessionId:c,context:A,tensor:$,dataType:p,shape:g})}releaseTensor(c){this.externalTensors.has(c)&&this.externalTensors.delete(c),this.freeTensors.push(c)}},a$=(...c)=>new i$(...c)}),qh,o$,l$,XP=u(()=>{vt(),bo(),lN(),YP(),Qi(),qh=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),o$=(c,p)=>{if(c===p)return!0;if(c===void 0||p===void 0)return!1;let g=Object.keys(c).sort(),b=Object.keys(p).sort();return g.length===b.length&&g.every((x,S)=>x===b[S]&&c[x]===p[x])},l$=class{constructor(c){this.tensorManager=a$(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Vg(c.logLevel,!!c.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(c){jt("verbose",()=>`[WebNN] onRunStart {sessionId: ${c}}`),this.activeSessionId=c}onRunEnd(c){jt("verbose",()=>`[WebNN] onRunEnd {sessionId: ${c}}`);let p=this.temporarySessionTensorIds.get(c);if(p){for(let g of p)jt("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${g}}`),this.tensorManager.releaseTensorId(g);this.temporarySessionTensorIds.delete(c),this.activeSessionId=void 0}}async createMLContext(c){if(c instanceof GPUDevice){let g=this.mlContextCache.findIndex(b=>b.gpuDevice===c);if(g!==-1)return this.mlContextCache[g].mlContext;{let b=await navigator.ml.createContext(c);return this.mlContextCache.push({gpuDevice:c,mlContext:b}),b}}else if(c===void 0){let g=this.mlContextCache.findIndex(b=>b.options===void 0&&b.gpuDevice===void 0);if(g!==-1)return this.mlContextCache[g].mlContext;{let b=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:b}),b}}let p=this.mlContextCache.findIndex(g=>o$(g.options,c));if(p!==-1)return this.mlContextCache[p].mlContext;{let g=await navigator.ml.createContext(c);return this.mlContextCache.push({options:c,mlContext:g}),g}}registerMLContext(c,p){this.mlContextBySessionId.set(c,p);let g=this.sessionIdsByMLContext.get(p);g||(g=new Set,this.sessionIdsByMLContext.set(p,g)),g.add(c),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(c,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(c){this.sessionGraphInputs.delete(c);let p=this.mlContextBySessionId.get(c);if(!p)return;this.tensorManager.releaseTensorsForSession(c),this.mlContextBySessionId.delete(c);let g=this.sessionIdsByMLContext.get(p);if(g.delete(c),g.size===0){this.sessionIdsByMLContext.delete(p);let b=this.mlContextCache.findIndex(x=>x.mlContext===p);b!==-1&&this.mlContextCache.splice(b,1)}}getMLContext(c){return this.mlContextBySessionId.get(c)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(c){jt("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${c}}`),this.tensorManager.releaseTensorId(c)}async ensureTensor(c,p,g,b,x){let S=qh.get(g);if(!S)throw new Error(`Unsupported ONNX data type: ${g}`);return this.tensorManager.ensureTensor(c??this.currentSessionId,p,S,b,x)}async createTemporaryTensor(c,p,g){jt("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${p}, shape: ${g}}`);let b=qh.get(p);if(!b)throw new Error(`Unsupported ONNX data type: ${p}`);let x=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(c,x,b,g,!1);let S=this.temporarySessionTensorIds.get(c);return S?S.push(x):this.temporarySessionTensorIds.set(c,[x]),x}uploadTensor(c,p){if(!ts().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");jt("verbose",()=>`[WebNN] uploadTensor {tensorId: ${c}, data: ${p.byteLength}}`),this.tensorManager.upload(c,p)}async downloadTensor(c,p){return this.tensorManager.download(c,p)}createMLTensorDownloader(c,p){return async()=>{let g=await this.tensorManager.download(c);return Pg(g,p)}}registerMLTensor(c,p,g,b){let x=qh.get(g);if(!x)throw new Error(`Unsupported ONNX data type: ${g}`);let S=this.tensorManager.registerTensor(c,p,x,b);return jt("verbose",()=>`[WebNN] registerMLTensor {tensor: ${p}, dataType: ${x}, dimensions: ${b}} -> {tensorId: ${S}}`),S}registerMLConstant(c,p,g,b,x,S){if(!S)throw new Error("External mounted files are not available.");let A=c;c.startsWith("./")&&(A=c.substring(2));let $=S.get(A);if(!$)throw new Error(`File with name ${A} not found in preloaded files.`);if(p+g>$.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let D=$.slice(p,p+g).buffer,k;switch(x.dataType){case"float32":k=new Float32Array(D);break;case"float16":k=new Uint16Array(D);break;case"int32":k=new Int32Array(D);break;case"uint32":k=new Uint32Array(D);break;case"int64":k=new BigInt64Array(D);break;case"uint64":k=new BigUint64Array(D);break;case"int8":k=new Int8Array(D);break;case"int4":case"uint4":case"uint8":k=new Uint8Array(D);break;default:throw new Error(`Unsupported data type: ${x.dataType} in creating WebNN Constant from external data.`)}return jt("verbose",()=>`[WebNN] registerMLConstant {dataType: ${x.dataType}, shape: ${x.shape}}}`),b.constant(x,k)}registerGraphInput(c){this.temporaryGraphInputs.push(c)}isGraphInput(c,p){let g=this.sessionGraphInputs.get(c);return g?g.includes(p):!1}flush(){}}}),u$={};d(u$,{init:()=>d$});var Kh,c$,d$,ZP=u(()=>{vt(),jP(),Qi(),Et(),XP(),Kh=class tk{constructor(p,g,b,x){this.module=p,this.dataType=g,this.data=b,this.dims=x}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let p=Ae.size(this.dims);return p===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,p)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let p=Ae.size(this.dims);return p===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,p)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let p=Ae.size(this.dims);return p===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,p)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let p=Ae.size(this.dims);return p===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,p)}reshape(p){if(Ae.size(p)!==Ae.size(this.dims))throw new Error("Invalid new shape");return new tk(this.module,this.dataType,this.data,p)}},c$=class{constructor(c,p,g){this.module=c,this.backend=p,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=p.adapterInfo,this.deviceInfo=p.deviceInfo;let b=c.PTR_SIZE,x=g/c.PTR_SIZE,S=b===4?"i32":"i64";this.opKernelContext=Number(c.getValue(b*x++,S));let A=Number(c.getValue(b*x++,S));this.outputCount=Number(c.getValue(b*x++,S)),this.customDataOffset=Number(c.getValue(b*x++,"*")),this.customDataSize=Number(c.getValue(b*x++,S));let $=[];for(let D=0;D<A;D++){let k=Number(c.getValue(b*x++,S)),O=Number(c.getValue(b*x++,"*")),R=Number(c.getValue(b*x++,S)),V=[];for(let F=0;F<R;F++)V.push(Number(c.getValue(b*x++,S)));$.push(new Kh(c,k,O,V))}this.inputs=$}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(c,p){var A;let g=((A=p==null?void 0:p.inputs)==null?void 0:A.map($=>typeof $=="number"?this.inputs[$]:$))??this.inputs,b=(p==null?void 0:p.outputs)??[],x=($,D,k)=>new Kh(this.module,D,this.output($,k),k),S=($,D)=>{let k=No($,D);if(!k)throw new Error(`Unsupported data type: ${$}`);let O=k>0?this.backend.gpuDataManager.create(k).id:0;return new Kh(this.module,$,O,D)};return this.backend.run(c,g,b,x,S,this.outputCount)}output(c,p){let g=this.module.stackSave();try{let b=this.module.PTR_SIZE,x=b===4?"i32":"i64",S=this.module.stackAlloc((1+p.length)*b);this.module.setValue(S,p.length,x);for(let A=0;A<p.length;A++)this.module.setValue(S+b*(A+1),p[A],x);return this.module._JsepOutput(this.opKernelContext,c,S)}catch(b){throw new Error(`Failed to generate kernel's output[${c}] with dims [${p}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${b}`)}finally{this.module.stackRestore(g)}}},d$=async(c,p,g,b)=>{let x=p.jsepInit;if(!x)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(c==="webgpu"){let S=new n$;await S.initialize(g,b),x("webgpu",[S,A=>S.alloc(Number(A)),A=>S.free(A),(A,$,D,k=!1)=>{if(k)jt("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(A)}, dst=${Number($)}, size=${Number(D)}`),S.memcpy(Number(A),Number($));else{jt("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(A)}, gpuDataId=${Number($)}, size=${Number(D)}`);let O=p.HEAPU8.subarray(Number(A>>>0),Number(A>>>0)+Number(D));S.upload(Number($),O)}},async(A,$,D)=>{jt("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${A}, dataOffset=${$}, size=${D}`),await S.download(Number(A),()=>p.HEAPU8.subarray(Number($)>>>0,Number($+D)>>>0))},(A,$,D)=>S.createKernel(A,Number($),D,p.UTF8ToString(p._JsepGetNodeName(Number($)))),A=>S.releaseKernel(A),(A,$,D,k)=>{jt("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${D}, kernel=${A}, contextDataOffset=${$}`);let O=new c$(p,S,Number($));return S.computeKernel(Number(A),O,k)},()=>S.captureBegin(),()=>S.captureEnd(),()=>S.replay()])}else{let S=new l$(g);x("webnn",[S,()=>S.reserveTensorId(),A=>S.releaseTensorId(A),async(A,$,D,k,O)=>S.ensureTensor(A,$,D,k,O),(A,$)=>{S.uploadTensor(A,$)},async(A,$)=>S.downloadTensor(A,$)])}}}),h$,F0,z0,va,p$,jh,M0,W0,B0,H0,U0,G0,f$=u(()=>{tP(),nP(),vt(),bo(),Eg(),nN(),h$=(c,p)=>{ts()._OrtInit(c,p)!==0&&nn("Can't initialize onnxruntime.")},F0=async c=>{h$(c.wasm.numThreads,Oh(c.logLevel))},z0=async(c,p)=>{{let g=(ZP(),f(u$)).init;if(p==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let b=c.webgpu.adapter;if(b){if(typeof b.limits!="object"||typeof b.features!="object"||typeof b.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let x=c.webgpu.powerPreference;if(x!==void 0&&x!=="low-power"&&x!=="high-performance")throw new Error(`Invalid powerPreference setting: "${x}"`);let S=c.webgpu.forceFallbackAdapter;if(S!==void 0&&typeof S!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${S}"`);if(b=await navigator.gpu.requestAdapter({powerPreference:x,forceFallbackAdapter:S}),!b)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await g("webgpu",ts(),c,b)}if(p==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await g("webnn",ts(),c)}}},va=new Map,p$=c=>{let p=ts(),g=p.stackSave();try{let b=p.PTR_SIZE,x=p.stackAlloc(2*b);p._OrtGetInputOutputCount(c,x,x+b)!==0&&nn("Can't get session input/output count.");let S=b===4?"i32":"i64";return[Number(p.getValue(x,S)),Number(p.getValue(x+b,S))]}finally{p.stackRestore(g)}},jh=c=>{let p=ts(),g=p._malloc(c.byteLength);if(g===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${c.byteLength}.`);return p.HEAPU8.set(c,g),[g,c.byteLength]},M0=async(c,p)=>{var R,V,F;let g,b,x=ts();Array.isArray(c)?[g,b]=c:c.buffer===x.HEAPU8.buffer?[g,b]=[c.byteOffset,c.byteLength]:[g,b]=jh(c);let S=0,A=0,$=0,D=[],k=[],O=[];try{if([A,D]=tN(p),(p==null?void 0:p.externalData)&&x.mountExternalData){let re=[];for(let me of p.externalData){let Ne=typeof me=="string"?me:me.path;re.push(Rg(typeof me=="string"?me:me.data).then(Ve=>{x.mountExternalData(Ne,Ve)}))}await Promise.all(re)}for(let re of(p==null?void 0:p.executionProviders)??[])if((typeof re=="string"?re:re.name)==="webnn"){if(x.shouldTransferToMLTensor=!1,typeof re!="string"){let me=re,Ne=me==null?void 0:me.context,Ve=me==null?void 0:me.gpuDevice,Ke=me==null?void 0:me.deviceType,lt=me==null?void 0:me.powerPreference;Ne?x.currentContext=Ne:Ve?x.currentContext=await x.jsepCreateMLContext(Ve):x.currentContext=await x.jsepCreateMLContext({deviceType:Ke,powerPreference:lt})}else x.currentContext=await x.jsepCreateMLContext();break}S=await x._OrtCreateSession(g,b,A),S===0&&nn("Can't create a session."),(R=x.jsepOnCreateSession)==null||R.call(x),x.currentContext&&(x.jsepRegisterMLContext(S,x.currentContext),x.currentContext=void 0,x.shouldTransferToMLTensor=!0);let[z,G]=p$(S),X=!!(p!=null&&p.enableGraphCapture),K=[],q=[],te=[];for(let re=0;re<z;re++){let me=x._OrtGetInputName(S,re);me===0&&nn("Can't get an input name."),k.push(me),K.push(x.UTF8ToString(me))}for(let re=0;re<G;re++){let me=x._OrtGetOutputName(S,re);me===0&&nn("Can't get an output name."),O.push(me);let Ne=x.UTF8ToString(me);q.push(Ne);{if(X&&(p==null?void 0:p.preferredOutputLocation)===void 0){te.push("gpu-buffer");continue}let Ve=typeof(p==null?void 0:p.preferredOutputLocation)=="string"?p.preferredOutputLocation:((V=p==null?void 0:p.preferredOutputLocation)==null?void 0:V[Ne])??"cpu";if(Ve!=="cpu"&&Ve!=="cpu-pinned"&&Ve!=="gpu-buffer"&&Ve!=="ml-tensor")throw new Error(`Not supported preferred output location: ${Ve}.`);if(X&&Ve!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${Ve}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);te.push(Ve)}}let ee=null;return te.some(re=>re==="gpu-buffer"||re==="ml-tensor")&&($=x._OrtCreateBinding(S),$===0&&nn("Can't create IO binding."),ee={handle:$,outputPreferredLocations:te,outputPreferredLocationsEncoded:te.map(re=>Og(re))}),va.set(S,[S,k,O,ee,X,!1]),[S,K,q]}catch(z){throw k.forEach(G=>x._OrtFree(G)),O.forEach(G=>x._OrtFree(G)),$!==0&&x._OrtReleaseBinding($)!==0&&nn("Can't release IO binding."),S!==0&&x._OrtReleaseSession(S)!==0&&nn("Can't release session."),z}finally{x._free(g),A!==0&&x._OrtReleaseSessionOptions(A)!==0&&nn("Can't release session options."),D.forEach(z=>x._free(z)),(F=x.unmountExternalData)==null||F.call(x)}},W0=c=>{var D;let p=ts(),g=va.get(c);if(!g)throw new Error(`cannot release session. invalid session id: ${c}`);let[b,x,S,A,$]=g;A&&($&&p._OrtClearBoundOutputs(A.handle)!==0&&nn("Can't clear bound outputs."),p._OrtReleaseBinding(A.handle)!==0&&nn("Can't release IO binding.")),(D=p.jsepOnReleaseSession)==null||D.call(p,c),x.forEach(k=>p._OrtFree(k)),S.forEach(k=>p._OrtFree(k)),p._OrtReleaseSession(b)!==0&&nn("Can't release session."),va.delete(c)},B0=async(c,p,g,b,x,S=!1)=>{if(!c){p.push(0);return}let A=ts(),$=A.PTR_SIZE,D=c[0],k=c[1],O=c[3],R=O,V,F;if(D==="string"&&(O==="gpu-buffer"||O==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(S&&O!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${x} when enableGraphCapture is true.`);if(O==="gpu-buffer"){let X=c[2].gpuBuffer;F=No(Ol(D),k);let K=A.jsepRegisterBuffer;if(!K)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');V=K(b,x,X,F)}else if(O==="ml-tensor"){let X=c[2].mlTensor;F=No(Ol(D),k);let K=A.jsepRegisterMLTensor;if(!K)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');V=K(b,X,Ol(D),k)}else{let X=c[2];if(Array.isArray(X)){F=$*X.length,V=A._malloc(F),g.push(V);for(let K=0;K<X.length;K++){if(typeof X[K]!="string")throw new TypeError(`tensor data at index ${K} is not a string`);A.setValue(V+K*$,Ts(X[K],g),"*")}}else{let K=A.jsepIsGraphInput;if(D!=="string"&&K){let q=A._OrtGetInputName(b,x),te=A.UTF8ToString(q);if(K(b,te)){let ee=Ol(D);F=No(ee,k),R="ml-tensor";let re=A.jsepCreateTemporaryTensor,me=A.jsepUploadTensor;if(!re||!me)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let Ne=await re(b,ee,k);me(Ne,new Uint8Array(X.buffer,X.byteOffset,X.byteLength)),V=Ne}else F=X.byteLength,V=A._malloc(F),g.push(V),A.HEAPU8.set(new Uint8Array(X.buffer,X.byteOffset,F),V)}else F=X.byteLength,V=A._malloc(F),g.push(V),A.HEAPU8.set(new Uint8Array(X.buffer,X.byteOffset,F),V)}}let z=A.stackSave(),G=A.stackAlloc(4*k.length);try{k.forEach((K,q)=>A.setValue(G+q*$,K,$===4?"i32":"i64"));let X=A._OrtCreateTensor(Ol(D),V,F,G,k.length,Og(R));X===0&&nn(`Can't create tensor for input/output. session=${b}, index=${x}.`),p.push(X)}finally{A.stackRestore(z)}},H0=async(c,p,g,b,x,S)=>{var _t,Ot,Tt;let A=ts(),$=A.PTR_SIZE,D=va.get(c);if(!D)throw new Error(`cannot run inference. invalid session id: ${c}`);let k=D[0],O=D[1],R=D[2],V=D[3],F=D[4],z=D[5],G=p.length,X=b.length,K=0,q=[],te=[],ee=[],re=[],me=A.stackSave(),Ne=A.stackAlloc(G*$),Ve=A.stackAlloc(G*$),Ke=A.stackAlloc(X*$),lt=A.stackAlloc(X*$);try{[K,q]=Xx(S);for(let it=0;it<G;it++)await B0(g[it],te,re,c,p[it],F);for(let it=0;it<X;it++)await B0(x[it],ee,re,c,G+b[it],F);for(let it=0;it<G;it++)A.setValue(Ne+it*$,te[it],"*"),A.setValue(Ve+it*$,O[p[it]],"*");for(let it=0;it<X;it++)A.setValue(Ke+it*$,ee[it],"*"),A.setValue(lt+it*$,R[b[it]],"*");if(V&&!z){let{handle:it,outputPreferredLocations:en,outputPreferredLocationsEncoded:In}=V;if(O.length!==G)throw new Error(`input count from feeds (${G}) is expected to be always equal to model's input count (${O.length}).`);for(let yt=0;yt<G;yt++){let hn=p[yt];await A._OrtBindInput(it,O[hn],te[yt])!==0&&nn(`Can't bind input[${yt}] for session=${c}.`)}for(let yt=0;yt<X;yt++){let hn=b[yt];(_t=x[yt])!=null&&_t[3]?A._OrtBindOutput(it,R[hn],ee[yt],0)!==0&&nn(`Can't bind pre-allocated output[${yt}] for session=${c}.`):A._OrtBindOutput(it,R[hn],0,In[hn])!==0&&nn(`Can't bind output[${yt}] to ${en[yt]} for session=${c}.`)}va.set(c,[k,O,R,V,F,!0])}(Ot=A.jsepOnRunStart)==null||Ot.call(A,k);let kt;V?kt=await A._OrtRunWithBinding(k,V.handle,X,Ke,K):kt=await A._OrtRun(k,Ve,Ne,G,lt,X,Ke,K),kt!==0&&nn("failed to call OrtRun().");let Wt=[];for(let it=0;it<X;it++){let en=Number(A.getValue(Ke+it*$,"*"));if(en===ee[it]){Wt.push(x[it]);continue}let In=A.stackSave(),yt=A.stackAlloc(4*$),hn=!1,Be,tt=0;try{A._OrtGetTensorData(en,yt,yt+$,yt+2*$,yt+3*$)!==0&&nn(`Can't access output tensor data on index ${it}.`);let sn=$===4?"i32":"i64",Vn=Number(A.getValue(yt,sn));tt=A.getValue(yt+$,"*");let Or=A.getValue(yt+$*2,"*"),X0=Number(A.getValue(yt+$*3,sn)),Eo=[];for(let ks=0;ks<X0;ks++)Eo.push(Number(A.getValue(Or+ks*$,sn)));A._OrtFree(Or)!==0&&nn("Can't free memory for tensor dims.");let ko=Eo.reduce((ks,hs)=>ks*hs,1);Be=xo(Vn);let Zh=V==null?void 0:V.outputPreferredLocations[b[it]];if(Be==="string"){if(Zh==="gpu-buffer"||Zh==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let ks=[];for(let hs=0;hs<ko;hs++){let oc=A.getValue(tt+hs*$,"*"),n6=A.getValue(tt+(hs+1)*$,"*"),s6=hs===ko-1?void 0:n6-oc;ks.push(A.UTF8ToString(oc,s6))}Wt.push([Be,Eo,ks,"cpu"])}else if(Zh==="gpu-buffer"&&ko>0){let ks=A.jsepGetBuffer;if(!ks)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let hs=ks(tt),oc=No(Vn,ko);if(oc===void 0||!Cg(Be))throw new Error(`Unsupported data type: ${Be}`);hn=!0,Wt.push([Be,Eo,{gpuBuffer:hs,download:A.jsepCreateDownloader(hs,oc,Be),dispose:()=>{A._OrtReleaseTensor(en)!==0&&nn("Can't release tensor.")}},"gpu-buffer"])}else if(Zh==="ml-tensor"&&ko>0){let ks=A.jsepEnsureTensor;if(!ks)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(No(Vn,ko)===void 0||!Lg(Be))throw new Error(`Unsupported data type: ${Be}`);let hs=await ks(c,tt,Vn,Eo,!1);hn=!0,Wt.push([Be,Eo,{mlTensor:hs,download:A.jsepCreateMLTensorDownloader(tt,Be),dispose:()=>{A.jsepReleaseTensorId(tt),A._OrtReleaseTensor(en)}},"ml-tensor"])}else{let ks=kg(Be),hs=new ks(ko);new Uint8Array(hs.buffer,hs.byteOffset,hs.byteLength).set(A.HEAPU8.subarray(tt,tt+hs.byteLength)),Wt.push([Be,Eo,hs,"cpu"])}}finally{A.stackRestore(In),Be==="string"&&tt&&A._free(tt),hn||A._OrtReleaseTensor(en),(Tt=A.jsepOnRunEnd)==null||Tt.call(A,k)}}return V&&!F&&(A._OrtClearBoundOutputs(V.handle)!==0&&nn("Can't clear bound outputs."),va.set(c,[k,O,R,V,F,!1])),Wt}finally{A.stackRestore(me),te.forEach(kt=>A._OrtReleaseTensor(kt)),ee.forEach(kt=>A._OrtReleaseTensor(kt)),re.forEach(kt=>A._free(kt)),K!==0&&A._OrtReleaseRunOptions(K),q.forEach(kt=>A._free(kt))}},U0=c=>{let p=ts(),g=va.get(c);if(!g)throw new Error("invalid session id");let b=g[0],x=p._OrtEndProfiling(b);x===0&&nn("Can't get an profile file name."),p._OrtFree(x)},G0=c=>{let p=[];for(let g of c){let b=g[2];!Array.isArray(b)&&"buffer"in b&&p.push(b.buffer)}return p}}),$a,sr,Fl,ic,ac,Yh,q0,Xh,_o,Do,m$,g$,I$,y$,b$,x$,N$,w$,A$=u(()=>{dt(),f$(),bo(),vg(),$a=()=>!!U.wasm.proxy&&typeof document<"u",Fl=!1,ic=!1,ac=!1,Xh=new Map,_o=(c,p)=>{let g=Xh.get(c);g?g.push(p):Xh.set(c,[p])},Do=()=>{if(Fl||!ic||ac||!sr)throw new Error("worker not ready")},m$=c=>{switch(c.data.type){case"init-wasm":Fl=!1,c.data.err?(ac=!0,q0[1](c.data.err)):(ic=!0,q0[0]()),Yh&&(URL.revokeObjectURL(Yh),Yh=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let p=Xh.get(c.data.type);c.data.err?p.shift()[1](c.data.err):p.shift()[0](c.data.out);break}}},g$=async()=>{if(!ic){if(Fl)throw new Error("multiple calls to 'initWasm()' detected.");if(ac)throw new Error("previous call to 'initWasm()' failed.");if(Fl=!0,$a())return new Promise((c,p)=>{sr==null||sr.terminate(),qx().then(([g,b])=>{try{sr=b,sr.onerror=S=>p(S),sr.onmessage=m$,q0=[c,p];let x={type:"init-wasm",in:U};if(!x.in.wasm.wasmPaths&&g){let S=As();S&&(x.in.wasm.wasmPaths=S)}sr.postMessage(x),Yh=g}catch(x){p(x)}},p)});try{await Dg(U.wasm),await F0(U),ic=!0}catch(c){throw ac=!0,c}finally{Fl=!1}}},I$=async c=>{if($a())return Do(),new Promise((p,g)=>{_o("init-ep",[p,g]);let b={type:"init-ep",in:{epName:c,env:U}};sr.postMessage(b)});await z0(U,c)},y$=async c=>$a()?(Do(),new Promise((p,g)=>{_o("copy-from",[p,g]);let b={type:"copy-from",in:{buffer:c}};sr.postMessage(b,[c.buffer])})):jh(c),b$=async(c,p)=>{if($a()){if(p!=null&&p.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Do(),new Promise((g,b)=>{_o("create",[g,b]);let x={type:"create",in:{model:c,options:{...p}}},S=[];c instanceof Uint8Array&&S.push(c.buffer),sr.postMessage(x,S)})}else return M0(c,p)},x$=async c=>{if($a())return Do(),new Promise((p,g)=>{_o("release",[p,g]);let b={type:"release",in:c};sr.postMessage(b)});W0(c)},N$=async(c,p,g,b,x,S)=>{if($a()){if(g.some(A=>A[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(x.some(A=>A))throw new Error("pre-allocated output tensor is not supported for proxy.");return Do(),new Promise((A,$)=>{_o("run",[A,$]);let D=g,k={type:"run",in:{sessionId:c,inputIndices:p,inputs:D,outputIndices:b,options:S}};sr.postMessage(k,G0(D))})}else return H0(c,p,g,b,x,S)},w$=async c=>{if($a())return Do(),new Promise((p,g)=>{_o("end-profiling",[p,g]);let b={type:"end-profiling",in:c};sr.postMessage(b)});U0(c)}}),K0,T$,S$,QP=u(()=>{dt(),A$(),vt(),Dt(),nN(),K0=(c,p)=>{switch(c.location){case"cpu":return[c.type,c.dims,c.data,"cpu"];case"gpu-buffer":return[c.type,c.dims,{gpuBuffer:c.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[c.type,c.dims,{mlTensor:c.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${c.location} for ${p()}`)}},T$=c=>{switch(c[3]){case"cpu":return new ze(c[0],c[2],c[1]);case"gpu-buffer":{let p=c[0];if(!Cg(p))throw new Error(`not supported data type: ${p} for deserializing GPU tensor`);let{gpuBuffer:g,download:b,dispose:x}=c[2];return ze.fromGpuBuffer(g,{dataType:p,dims:c[1],download:b,dispose:x})}case"ml-tensor":{let p=c[0];if(!Lg(p))throw new Error(`not supported data type: ${p} for deserializing MLTensor tensor`);let{mlTensor:g,download:b,dispose:x}=c[2];return ze.fromMLTensor(g,{dataType:p,dims:c[1],download:b,dispose:x})}default:throw new Error(`invalid data location: ${c[3]}`)}},S$=class{async fetchModelAndCopyToWasmMemory(c){return y$(await Rg(c))}async loadModel(c,p){Q();let g;typeof c=="string"?g=await this.fetchModelAndCopyToWasmMemory(c):g=c,[this.sessionId,this.inputNames,this.outputNames]=await b$(g,p),ue()}async dispose(){return x$(this.sessionId)}async run(c,p,g){Q();let b=[],x=[];Object.entries(c).forEach(R=>{let V=R[0],F=R[1],z=this.inputNames.indexOf(V);if(z===-1)throw new Error(`invalid input '${V}'`);b.push(F),x.push(z)});let S=[],A=[];Object.entries(p).forEach(R=>{let V=R[0],F=R[1],z=this.outputNames.indexOf(V);if(z===-1)throw new Error(`invalid output '${V}'`);S.push(F),A.push(z)});let $=b.map((R,V)=>K0(R,()=>`input "${this.inputNames[x[V]]}"`)),D=S.map((R,V)=>R?K0(R,()=>`output "${this.outputNames[A[V]]}"`):null),k=await N$(this.sessionId,x,$,A,D,g),O={};for(let R=0;R<k.length;R++)O[this.outputNames[A[R]]]=S[R]??T$(k[R]);return ue(),O}startProfiling(){}endProfiling(){w$(this.sessionId)}}}),v$={};d(v$,{OnnxruntimeWebAssemblyBackend:()=>Y0,initializeFlags:()=>j0,wasmBackend:()=>$$});var j0,Y0,$$,JP=u(()=>{dt(),A$(),QP(),j0=()=>{if((typeof U.wasm.initTimeout!="number"||U.wasm.initTimeout<0)&&(U.wasm.initTimeout=0),U.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof U.wasm.proxy!="boolean"&&(U.wasm.proxy=!1),typeof U.wasm.trace!="boolean"&&(U.wasm.trace=!1),typeof U.wasm.numThreads!="number"||!Number.isInteger(U.wasm.numThreads)||U.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)U.wasm.numThreads=1;else{let c=typeof navigator>"u"?l("node:os").cpus().length:navigator.hardwareConcurrency;U.wasm.numThreads=Math.min(4,Math.ceil((c||1)/2))}},Y0=class{async init(c){j0(),await g$(),await I$(c)}async createInferenceSessionHandler(c,p){let g=new S$;return await g.loadModel(c,p),Promise.resolve(g)}},$$=new Y0}),_$={};d(_$,{InferenceSession:()=>Xe,TRACE:()=>xt,TRACE_FUNC_BEGIN:()=>Q,TRACE_FUNC_END:()=>ue,Tensor:()=>ze,default:()=>t6,env:()=>U,registerBackend:()=>y}),dt(),dt(),dt();var e6="1.21.0",t6=ct;{let c=(JP(),f(v$)).wasmBackend;y("webgpu",c,5),y("webnn",c,5),y("cpu",c,10),y("wasm",c,10)}return Object.defineProperty(U.versions,"web",{value:e6,enumerable:!0}),f(_$)})();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */n.exports=t})(Jz);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eM=1e-7,tM=1e-4;class nk{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class gy{refCount(e){return rr("refCount")}incRef(e){return rr("incRef")}timerAvailable(){return!0}time(e){return rr("time")}read(e){return rr("read")}readSync(e){return rr("readSync")}readToGPU(e,t){return rr("readToGPU")}numDataIds(){return rr("numDataIds")}disposeData(e,t){return rr("disposeData")}write(e,t,s){return rr("write")}move(e,t,s,r,i){return rr("move")}createTensorFromGPUData(e,t,s){return rr("createTensorFromGPUData")}memory(){return rr("memory")}floatPrecision(){return rr("floatPrecision")}epsilon(){return this.floatPrecision()===32?eM:tM}dispose(){return rr("dispose")}}function rr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nM(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Gl(n,e,t)}function el(n,e,t){return Math.max(n,Math.min(e,t))}function Iy(n){return n%2===0?n:n+1}function Gl(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function sM(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function W(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function yr(n,e,t=""){W(Kt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Eu(n){W(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Te(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function rM(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Kt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function fu(n){return n%1===0}function G1(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function iu(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function __(n,e=r=>0,t,s){return new Promise((r,i)=>{let o=0;const l=()=>{if(n()){r();return}o++;const u=e(o);if(t!=null&&o>=t){i();return}s!=null?s(l,u):setTimeout(l,u)};l()})}function sk(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function Bt(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),W(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),W(n.every(s=>fu(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function ro(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:Bt(e,n).sort();let o=0;for(let l=0;l<n.length;++l){if(i!=null){if(i[o]===l&&n[l]!==1)throw new Error(`Can't squeeze axis ${l} since its dim '${n[l]}' is not 1`);(i[o]==null||i[o]>l)&&n[l]===1&&(t.push(n[l]),s.push(l)),i[o]<=l&&o++}n[l]!==1&&(t.push(n[l]),s.push(l))}return{newShape:t,keptDims:s}}function Is(n,e){return Pn(n,e)}function Pn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function iM(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function aM(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function rk(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Fp(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function oM(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function cd(n){return typeof n=="string"||n instanceof String}function lM(n){return typeof n=="boolean"}function q1(n){return typeof n=="number"}function ku(n){return Array.isArray(n)?ku(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":q1(n)?"float32":cd(n)?"string":lM(n)?"bool":"float32"}function K1(n){return!!(n&&n.constructor&&n.call&&n.apply)}function j1(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function wt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function ik(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=t[n+o]}else{const i=e[0],o=e.slice(1),l=o.reduce((u,d)=>u*d)*(s?2:1);for(let u=0;u<i;u++)r[u]=ik(n+u*l,o,t,s)}return r}function jr(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return ik(0,n,e,t)}function uM(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function yy(n,e){const t=$s(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function $s(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function ak(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return jr(n,new Float32Array(t));if(e==="int32")return jr(n,new Int32Array(t));if(e==="bool")return jr(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Cr(n){n.forEach(e=>{W(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Mi(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function Cu(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function tl(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D_="tfjsflags";class cM{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=dM,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(tl(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);D_ in e&&e[D_].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=pM(r,i)})}}function dM(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(hM(e,s[0],s[1]),s.join("="))),e}function hM(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function pM(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function xe(){return ok}let ok=null;function fM(n){ok=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let u1;function lk(){if(u1==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");u1=n}return u1}function mM(){const n=lk();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function by(n,e){const t=mM();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const _f="Abs",dd="Acos",hd="Acosh",Lu="Add",Df="AddN",xy="All",Ny="Any",Ef="ArgMax",kf="ArgMin",pd="Asin",fd="Asinh",md="Atan",gd="Atanh",Id="Atan2",Cf="AvgPool",wy="AvgPoolGrad",Lf="AvgPool3D",Ay="AvgPool3DGrad",Of="BatchMatMul",Rf="BatchToSpaceND",Ty="Bincount",Vf="BitwiseAnd",gM="BroadcastTo",Sy="BroadcastArgs",yd="Cast",bd="Ceil",xd="ClipByValue",vy="Complex",Pf="ComplexAbs",Ff="Concat",zf="Conv2D",$y="Conv2DBackpropFilter",Mf="Conv2DBackpropInput",Wf="Conv3D",_y="Conv3DBackpropFilterV2",Dy="Conv3DBackpropInputV2",Nd="Cos",wd="Cosh",Ey="Cumprod",Bf="Cumsum",ky="CropAndResize",Cy="DenseBincount",Ly="DepthToSpace",Hf="DepthwiseConv2dNative",Oy="DepthwiseConv2dNativeBackpropFilter",Ry="DepthwiseConv2dNativeBackpropInput",Vy="Diag",Uf="Dilation2D",Y1="Dilation2DBackpropInput",X1="Dilation2DBackpropFilter",IM="Draw",Ad="RealDiv",Py="Einsum",Td="Elu",Fy="EluGrad",Sd="Erf",Gf="Equal",vd="Exp",qf="ExpandDims",$d="Expm1",zy="FFT",My="Fill",Wy="FlipLeftRight",_d="Floor",Dd="FloorDiv",Kf="FusedBatchNorm",jf="GatherV2",By="GatherNd",Yf="Greater",Ed="GreaterEqual",kd="Identity",Hy="IFFT",Uy="Imag",Cd="IsFinite",Ld="IsInf",Od="IsNan",Xf="LeakyRelu",Zf="Less",Qf="LessEqual",Gy="LinSpace",Rd="Log",Vd="Log1p",Jf="LogicalAnd",em="LogicalNot",tm="LogicalOr",yM="LogSoftmax",nm="LRN",qy="LRNGrad",sm="Max",Pd="Maximum",rm="MaxPool",Ky="MaxPoolGrad",im="MaxPool3D",jy="MaxPool3DGrad",Yy="MaxPoolWithArgmax",am="Mean",om="Min",Fd="Minimum",lm="MirrorPad",zd="Mod",Xy="Multinomial",Md="Multiply",um="Neg",cm="NotEqual",Zy="NonMaxSuppressionV3",Qy="NonMaxSuppressionV4",Jy="NonMaxSuppressionV5",dm="OnesLike",hm="OneHot",pm="Pack",fm="PadV2",Wd="Pow",mm="Prelu",gm="Prod",e2="RaggedGather",t2="RaggedRange",n2="RaggedTensorToTensor",s2="Range",r2="Real",Bd="Reciprocal",Hd="Relu",Im="Reshape",ym="ResizeNearestNeighbor",i2="ResizeNearestNeighborGrad",bm="ResizeBilinear",a2="ResizeBilinearGrad",Ud="Relu6",xm="Reverse",Gd="Round",qd="Rsqrt",o2="ScatterNd",l2="TensorScatterUpdate",u2="SearchSorted",Nm="Select",Kd="Selu",wm="Slice",jd="Sin",Yd="Sinh",Xd="Sign",Zd="Sigmoid",Qd="Softplus",Jd="Sqrt",Am="Sum",Tm="SpaceToBatchND",Sm="SplitV",vm="Softmax",c2="SparseFillEmptyRows",d2="SparseReshape",h2="SparseSegmentMean",p2="SparseSegmentSum",f2="SparseToDense",eh="SquaredDifference",m2="Square",$m="StaticRegexReplace",g2="StridedSlice",I2="StringNGrams",y2="StringSplit",b2="StringToHashBucketFast",th="Sub",nh="Tan",sh="Tanh",rh="Tile",x2="TopK",N2="Transform",au="Transpose",w2="Unique",_m="Unpack",Dm="UnsortedSegmentSum",Em="ZerosLike",ih="Step",bM="FromPixels",A2="RotateWithOffset",zp="_FusedMatMul",Mp="FusedConv2D",Wp="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vr(...n){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(...n)}function xM(...n){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bp=by("kernelRegistry",()=>new Map),Z1=by("gradRegistry",()=>new Map);function E_(n,e){const t=ck(n,e);return Bp.get(t)}function k_(n){return Z1.get(n)}function C_(n){const e=Bp.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,o]=r,[l]=i.split("_");l===n&&t.push(o)}return t}function uk(n){const{kernelName:e,backendName:t}=n,s=ck(e,t);Bp.has(s)&&vr(`The kernel '${e}' for backend '${t}' is already registered`),Bp.set(s,n)}function NM(n){const{kernelName:e}=n;Z1.has(e)&&xe().getBool("DEBUG")&&vr(`Overriding the gradient for '${e}'`),Z1.set(e,n)}function ck(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dk(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var hk=xn,Wr=null;try{Wr=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function xn(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}xn.prototype.__isLong__;Object.defineProperty(xn.prototype,"__isLong__",{value:!0});function br(n){return(n&&n.__isLong__)===!0}xn.isLong=br;var L_={},O_={};function bl(n,e){var t,s,r;return e?(n>>>=0,(r=0<=n&&n<256)&&(s=O_[n],s)?s:(t=Nn(n,(n|0)<0?-1:0,!0),r&&(O_[n]=t),t)):(n|=0,(r=-128<=n&&n<128)&&(s=L_[n],s)?s:(t=Nn(n,n<0?-1:0,!1),r&&(L_[n]=t),t))}xn.fromInt=bl;function Br(n,e){if(isNaN(n))return e?Uo:Hr;if(e){if(n<0)return Uo;if(n>=pk)return gk}else{if(n<=-V_)return lr;if(n+1>=V_)return mk}return n<0?Br(-n,e).neg():Nn(n%mu|0,n/mu|0,e)}xn.fromNumber=Br;function Nn(n,e,t){return new xn(n,e,t)}xn.fromBits=Nn;var Hp=Math.pow;function T2(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return Hr;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var s;if((s=n.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return T2(n.substring(1),e,t).neg();for(var r=Br(Hp(t,8)),i=Hr,o=0;o<n.length;o+=8){var l=Math.min(8,n.length-o),u=parseInt(n.substring(o,o+l),t);if(l<8){var d=Br(Hp(t,l));i=i.mul(d).add(Br(u))}else i=i.mul(r),i=i.add(Br(u))}return i.unsigned=e,i}xn.fromString=T2;function Ai(n,e){return typeof n=="number"?Br(n,e):typeof n=="string"?T2(n,e):Nn(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}xn.fromValue=Ai;var R_=65536,wM=1<<24,mu=R_*R_,pk=mu*mu,V_=pk/2,P_=bl(wM),Hr=bl(0);xn.ZERO=Hr;var Uo=bl(0,!0);xn.UZERO=Uo;var Ql=bl(1);xn.ONE=Ql;var fk=bl(1,!0);xn.UONE=fk;var Q1=bl(-1);xn.NEG_ONE=Q1;var mk=Nn(-1,2147483647,!1);xn.MAX_VALUE=mk;var gk=Nn(-1,-1,!0);xn.MAX_UNSIGNED_VALUE=gk;var lr=Nn(0,-2147483648,!1);xn.MIN_VALUE=lr;var st=xn.prototype;st.toInt=function(){return this.unsigned?this.low>>>0:this.low};st.toNumber=function(){return this.unsigned?(this.high>>>0)*mu+(this.low>>>0):this.high*mu+(this.low>>>0)};st.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(lr)){var t=Br(e),s=this.div(t),r=s.mul(t).sub(this);return s.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=Br(Hp(e,6),this.unsigned),o=this,l="";;){var u=o.div(i),d=o.sub(u.mul(i)).toInt()>>>0,h=d.toString(e);if(o=u,o.isZero())return h+l;for(;h.length<6;)h="0"+h;l=""+h+l}};st.getHighBits=function(){return this.high};st.getHighBitsUnsigned=function(){return this.high>>>0};st.getLowBits=function(){return this.low};st.getLowBitsUnsigned=function(){return this.low>>>0};st.getNumBitsAbs=function(){if(this.isNegative())return this.eq(lr)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};st.isZero=function(){return this.high===0&&this.low===0};st.eqz=st.isZero;st.isNegative=function(){return!this.unsigned&&this.high<0};st.isPositive=function(){return this.unsigned||this.high>=0};st.isOdd=function(){return(this.low&1)===1};st.isEven=function(){return(this.low&1)===0};st.equals=function(e){return br(e)||(e=Ai(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};st.eq=st.equals;st.notEquals=function(e){return!this.eq(e)};st.neq=st.notEquals;st.ne=st.notEquals;st.lessThan=function(e){return this.comp(e)<0};st.lt=st.lessThan;st.lessThanOrEqual=function(e){return this.comp(e)<=0};st.lte=st.lessThanOrEqual;st.le=st.lessThanOrEqual;st.greaterThan=function(e){return this.comp(e)>0};st.gt=st.greaterThan;st.greaterThanOrEqual=function(e){return this.comp(e)>=0};st.gte=st.greaterThanOrEqual;st.ge=st.greaterThanOrEqual;st.compare=function(e){if(br(e)||(e=Ai(e)),this.eq(e))return 0;var t=this.isNegative(),s=e.isNegative();return t&&!s?-1:!t&&s?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};st.comp=st.compare;st.negate=function(){return!this.unsigned&&this.eq(lr)?lr:this.not().add(Ql)};st.neg=st.negate;st.add=function(e){br(e)||(e=Ai(e));var t=this.high>>>16,s=this.high&65535,r=this.low>>>16,i=this.low&65535,o=e.high>>>16,l=e.high&65535,u=e.low>>>16,d=e.low&65535,h=0,f=0,m=0,I=0;return I+=i+d,m+=I>>>16,I&=65535,m+=r+u,f+=m>>>16,m&=65535,f+=s+l,h+=f>>>16,f&=65535,h+=t+o,h&=65535,Nn(m<<16|I,h<<16|f,this.unsigned)};st.subtract=function(e){return br(e)||(e=Ai(e)),this.add(e.neg())};st.sub=st.subtract;st.multiply=function(e){if(this.isZero())return Hr;if(br(e)||(e=Ai(e)),Wr){var t=Wr.mul(this.low,this.high,e.low,e.high);return Nn(t,Wr.get_high(),this.unsigned)}if(e.isZero())return Hr;if(this.eq(lr))return e.isOdd()?lr:Hr;if(e.eq(lr))return this.isOdd()?lr:Hr;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(P_)&&e.lt(P_))return Br(this.toNumber()*e.toNumber(),this.unsigned);var s=this.high>>>16,r=this.high&65535,i=this.low>>>16,o=this.low&65535,l=e.high>>>16,u=e.high&65535,d=e.low>>>16,h=e.low&65535,f=0,m=0,I=0,y=0;return y+=o*h,I+=y>>>16,y&=65535,I+=i*h,m+=I>>>16,I&=65535,I+=o*d,m+=I>>>16,I&=65535,m+=r*h,f+=m>>>16,m&=65535,m+=i*d,f+=m>>>16,m&=65535,m+=o*u,f+=m>>>16,m&=65535,f+=s*h+r*d+i*u+o*l,f&=65535,Nn(I<<16|y,f<<16|m,this.unsigned)};st.mul=st.multiply;st.divide=function(e){if(br(e)||(e=Ai(e)),e.isZero())throw Error("division by zero");if(Wr){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Wr.div_u:Wr.div_s)(this.low,this.high,e.low,e.high);return Nn(t,Wr.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Uo:Hr;var s,r,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Uo;if(e.gt(this.shru(1)))return fk;i=Uo}else{if(this.eq(lr)){if(e.eq(Ql)||e.eq(Q1))return lr;if(e.eq(lr))return Ql;var o=this.shr(1);return s=o.div(e).shl(1),s.eq(Hr)?e.isNegative()?Ql:Q1:(r=this.sub(e.mul(s)),i=s.add(r.div(e)),i)}else if(e.eq(lr))return this.unsigned?Uo:Hr;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=Hr}for(r=this;r.gte(e);){s=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var l=Math.ceil(Math.log(s)/Math.LN2),u=l<=48?1:Hp(2,l-48),d=Br(s),h=d.mul(e);h.isNegative()||h.gt(r);)s-=u,d=Br(s,this.unsigned),h=d.mul(e);d.isZero()&&(d=Ql),i=i.add(d),r=r.sub(h)}return i};st.div=st.divide;st.modulo=function(e){if(br(e)||(e=Ai(e)),Wr){var t=(this.unsigned?Wr.rem_u:Wr.rem_s)(this.low,this.high,e.low,e.high);return Nn(t,Wr.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};st.mod=st.modulo;st.rem=st.modulo;st.not=function(){return Nn(~this.low,~this.high,this.unsigned)};st.and=function(e){return br(e)||(e=Ai(e)),Nn(this.low&e.low,this.high&e.high,this.unsigned)};st.or=function(e){return br(e)||(e=Ai(e)),Nn(this.low|e.low,this.high|e.high,this.unsigned)};st.xor=function(e){return br(e)||(e=Ai(e)),Nn(this.low^e.low,this.high^e.high,this.unsigned)};st.shiftLeft=function(e){return br(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Nn(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Nn(0,this.low<<e-32,this.unsigned)};st.shl=st.shiftLeft;st.shiftRight=function(e){return br(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Nn(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Nn(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};st.shr=st.shiftRight;st.shiftRightUnsigned=function(e){if(br(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var s=this.low;return Nn(s>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Nn(t,0,this.unsigned):Nn(t>>>e-32,0,this.unsigned)};st.shru=st.shiftRightUnsigned;st.shr_u=st.shiftRightUnsigned;st.toSigned=function(){return this.unsigned?Nn(this.low,this.high,!1):this};st.toUnsigned=function(){return this.unsigned?this:Nn(this.low,this.high,!0)};st.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};st.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};st.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};xn.fromBytes=function(e,t,s){return s?xn.fromBytesLE(e,t):xn.fromBytesBE(e,t)};xn.fromBytesLE=function(e,t){return new xn(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};xn.fromBytesBE=function(e,t){return new xn(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const Ik=Zz(hk),AM=a6({__proto__:null,default:Ik},[hk]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zo=Ik||AM;function km(n){return zo.fromString(n,!0,16)}const yk=km("c3a5c85c97cb3127"),Po=km("b492b66fbe98f273"),Vs=km("9ae16a3b2f90404f");function J1(n){return n.xor(n.shru(47))}function bk(n,e,t){const s=n.slice(e,e+t);return zo.fromBytes(Array.from(s),!0,!0)}function mn(n,e){return bk(n,e,8)}function F_(n,e){return bk(n,e,4)}function ss(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Wa(n,e,t=km("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function TM(n,e,t,s,r,i){r=r.add(n),i=ss(i.add(r).add(s),21);const o=r;return r=r.add(e),r=r.add(t),i=i.add(ss(r,44)),[r.add(s),i.add(o)]}function tp(n,e,t,s){return TM(mn(n,e),mn(n,e+8),mn(n,e+16),mn(n,e+24),t,s)}function SM(n,e=n.length){if(e>=8){const t=Vs.add(e*2),s=mn(n,0).add(Vs),r=mn(n,e-8),i=ss(r,37).mul(t).add(s),o=ss(s,25).add(r).mul(t);return Wa(i,o,t)}if(e>=4){const t=Vs.add(e*2),s=F_(n,0);return Wa(s.shl(3).add(e),F_(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),o=e+(r<<2);return J1(Vs.mul(i).xor(yk.mul(o))).mul(Vs)}return Vs}function vM(n,e=n.length){const t=Vs.add(e*2),s=mn(n,0).mul(Po),r=mn(n,8),i=mn(n,e-8).mul(t),o=mn(n,e-16).mul(Vs);return Wa(ss(s.add(r),43).add(ss(i,30)).add(o),s.add(ss(r.add(Vs),18)).add(i),t)}function $M(n,e=n.length){const t=Vs.add(e*2),s=mn(n,0).mul(Vs),r=mn(n,8),i=mn(n,e-8).mul(t),o=mn(n,e-16).mul(Vs),l=ss(s.add(r),43).add(ss(i,30)).add(o),u=Wa(l,s.add(ss(r.add(Vs),18)).add(i),t),d=mn(n,16).mul(t),h=mn(n,24),f=l.add(mn(n,e-32)).mul(t),m=u.add(mn(n,e-24)).mul(t);return Wa(ss(d.add(h),43).add(ss(f,30)).add(m),d.add(ss(h.add(s),18)).add(f),t)}function _M(n,e=n.length){const t=zo.fromNumber(81,!0);if(e<=32)return e<=16?SM(n,e):vM(n,e);if(e<=64)return $M(n,e);let s=t,r=t.mul(Po).add(113),i=J1(r.mul(Vs).add(113)).mul(Vs),o=[zo.UZERO,zo.UZERO],l=[zo.UZERO,zo.UZERO];s=s.mul(Vs).add(mn(n,0));let u=0;const d=(e-1>>6)*64,h=d+(e-1&63)-63;do s=ss(s.add(r).add(o[0]).add(mn(n,u+8)),37).mul(Po),r=ss(r.add(o[1]).add(mn(n,u+48)),42).mul(Po),s=s.xor(l[1]),r=r.add(o[0]).add(mn(n,u+40)),i=ss(i.add(l[0]),33).mul(Po),o=tp(n,u,o[1].mul(Po),s.add(l[0])),l=tp(n,u+32,i.add(l[1]),r.add(mn(n,u+16))),[i,s]=[s,i],u+=64;while(u!==d);const f=Po.add(i.and(255).shl(1));return u=h,l[0]=l[0].add(e-1&63),o[0]=o[0].add(l[0]),l[0]=l[0].add(o[0]),s=ss(s.add(r).add(o[0]).add(mn(n,u+8)),37).mul(f),r=ss(r.add(o[1]).add(mn(n,u+48)),42).mul(f),s=s.xor(l[1].mul(9)),r=r.add(o[0].mul(9).add(mn(n,u+40))),i=ss(i.add(l[0]),33).mul(f),o=tp(n,u,o[1].mul(f),s.add(l[0])),l=tp(n,u+32,i.add(l[1]),r.add(mn(n,u+16))),[i,s]=[s,i],Wa(Wa(o[0],l[0],f).add(J1(r).mul(yk)).add(i),Wa(o[1],l[1],f).add(s),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function io(n,e){return e==="string"?Ba(n):xl([n],e)}function DM(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function xl(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=nl(n)),xe().getBool("DEBUG")&&iM(n,e),DM(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function js(){return xe().platform.now()}function Ba(n,e="utf-8"){return e=e||"utf-8",xe().platform.encode(n,e)}function Ga(n,e="utf-8"){return e=e||"utf-8",xe().platform.decode(n,e)}function Zr(n){return xe().platform.isTypedArray!=null?xe().platform.isTypedArray(n):dk(n)}function nl(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||tl(n)||n==null||Zr(n)&&t)e.push(n);else if(Array.isArray(n)||Zr(n))for(let s=0;s<n.length;++s)nl(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)nl(n[r],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EM{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new CM)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let o;const l=js();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const d of r)d.dataSync();o=Promise.resolve({kernelMs:js()-l})}if(xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let d=0;d<r.length;d++){const h=r[d];h.data().then(f=>{kM(f,h.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(d=>d.kernelMs),extraInfo:o.then(d=>d.getExtraProfileInfo!=null?d.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:o}=e;s.forEach(l=>{Promise.all([l.data(),r,o]).then(u=>{this.logger.logKernelProfile(t,l,u[0],u[1],i,u[2])})})}}function kM(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class CM{logKernelProfile(e,t,s,r,i,o){const l=typeof r=="number"?iu(`${r}ms`,9):r.error,u=iu(e,25),d=t.rank,h=t.size,f=iu(t.shape.toString(),14);let m="";for(const I in i){const y=i[I];if(y!=null){const N=y.shape||t.shape,w=N.length;m+=`${I}: ${w}D ${w>0?N:""} `}}console.log(`%c${u}	%c${l}	%c${d}D ${f}	%c${h}	%c${m}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LM(n,e,t){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<n.length;u++){const d=n[u],h=d.inputs;for(const f in h){const m=h[f];let I=!1;for(let y=0;y<e.length;y++)if(s[m.id]){d.outputs.forEach(N=>s[N.id]=!0),I=!0,r[d.id]=!0;break}if(I)break}}const i={};i[t.id]=!0;const o={};for(let u=n.length-1;u>=0;u--){const d=n[u],h=d.inputs;for(let f=0;f<d.outputs.length;f++)if(i[d.outputs[f].id]){for(const m in h)i[h[m].id]=!0,o[d.id]=!0;break}}const l=[];for(let u=0;u<n.length;u++){const d=n[u];if(r[d.id]&&o[d.id]){const h={};for(const m in d.inputs){const I=d.inputs[m];s[I.id]&&(h[m]=I)}const f=Object.assign({},d);f.inputs=h,f.outputs=d.outputs,l.push(f)}}return l}function OM(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],o=[];if(i.outputs.forEach(u=>{const d=n[u.id];d!=null?o.push(d):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const l=i.gradient(o);for(const u in i.inputs){if(!(u in l))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(l)}.`);const d=t(()=>l[u]());if(d.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${d.dtype}'`);const h=i.inputs[u];if(!Kt(d.shape,h.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${u}' has shape '${d.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=d;else{const f=n[h.id];n[h.id]=s(f,d),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_=20,cc=3,c1=7;function RM(n,e,t,s){const r=wt(e),i=VM(n,e,t,r),o=e.length,l=Ap(n,e,t,r,i),u=["Tensor"];return s&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(l.map(d=>"    "+d).join(`
`)),u.join(`
`)}function VM(n,e,t,s){const r=Te(e),i=s[s.length-1],o=new Array(i).fill(0),l=e.length,u=t==="complex64"?xc(n):n;if(l>1)for(let d=0;d<r/i;d++){const h=d*i;for(let f=0;f<i;f++)o[f]=Math.max(o[f],bc(u[h+f],0,t).length)}return o}function bc(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(c1))} + ${parseFloat(n[1].toFixed(c1))}j`:cd(n)?s=`'${n}'`:t==="bool"?s=xk(n):s=parseFloat(n.toFixed(c1)).toString(),iu(s,e)}function xk(n){return n===0?"false":"true"}function Ap(n,e,t,s,r,i=!0){const o=t==="complex64"?2:1,l=e[0],u=e.length;if(u===0){if(t==="complex64"){const N=xc(n);return[bc(N[0],0,t)]}return t==="bool"?[xk(n[0])]:[n[0].toString()]}if(u===1){if(l>z_){const w=cc*o;let T=Array.from(n.slice(0,w)),v=Array.from(n.slice((l-cc)*o,l*o));return t==="complex64"&&(T=xc(T),v=xc(v)),["["+T.map((E,_)=>bc(E,r[_],t)).join(", ")+", ..., "+v.map((E,_)=>bc(E,r[l-cc+_],t)).join(", ")+"]"]}return["["+(t==="complex64"?xc(n):Array.from(n)).map((w,T)=>bc(w,r[T],t)).join(", ")+"]"]}const d=e.slice(1),h=s.slice(1),f=s[0]*o,m=[];if(l>z_){for(let N=0;N<cc;N++){const w=N*f,T=w+f;m.push(...Ap(n.slice(w,T),d,t,h,r,!1))}m.push("...");for(let N=l-cc;N<l;N++){const w=N*f,T=w+f;m.push(...Ap(n.slice(w,T),d,t,h,r,N===l-1))}}else for(let N=0;N<l;N++){const w=N*f,T=w+f;m.push(...Ap(n.slice(w,T),d,t,h,r,N===l-1))}const I=u===2?",":"";m[0]="["+(l>0?m[0]+I:"");for(let N=1;N<m.length-1;N++)m[N]=" "+m[N]+I;let y=`,
`;for(let N=2;N<u;N++)y+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":y),m}function xc(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yn{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=Te(e),s!=null){const r=s.length;W(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Pn(t,this.size),this.strides=wt(e)}set(e,...t){t.length===0&&(t=[0]),W(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return di().makeTensor(this.values,this.shape,this.dtype)}}let di=null,ql=null;function PM(n){di=n}function FM(n){ql=n}class $n{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Te(e),this.strides=wt(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return ql.buffer(this.shape,this.dtype,e)}bufferSync(){return ql.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return jr(this.shape,e,this.dtype==="complex64")}arraySync(){return jr(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=di().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Ga(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),di().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=di().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Ga(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await di().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),di().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ql.print(this,e)}clone(){return this.throwIfDisposed(),ql.clone(this)}toString(e=!1){const t=this.dataSync();return RM(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ql.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),di().makeVariable(this,e,t,s)}}Object.defineProperty($n,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function ve(){return by("Tensor",()=>$n)}ve();class Up extends $n{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Kt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);di().disposeTensor(this),this.dataId=e.dataId,di().incRef(this,null)}dispose(){di().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Up,Symbol.hasInstance,{value:n=>n instanceof $n&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var M_;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(M_||(M_={}));var eI;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(eI||(eI={}));var tI;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(tI||(tI={}));var nI;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(nI||(nI={}));var sI;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(sI||(sI={}));const zM={float32:nI,int32:eI,bool:tI,complex64:sI};function dr(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return zM[n][e]}function S2(n){return dr(n,"int32")}function Nk(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function wk(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn(n,e){if(n.dtype===e.dtype)return[n,e];const t=dr(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function MM(n,e){W(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Ak(n){const e=[];return Tk(n,e,new Set),e}function Tk(n,e,t){if(n==null)return;if(n instanceof $n){e.push(n);return}if(!WM(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),Tk(i,e,t))}}function WM(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d1(n){return n.kernelName!=null}class W_{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class gu{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new W_}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(vr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new EM(this.backendInstance),!0}setupRegisteredKernels(){C_(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){C_(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof gy)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,vr(`Initialization of backend ${e} failed`),vr(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return vr(`Initialization of backend ${e} failed`),vr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return gu.nextTensorId++}nextVariableId(){return gu.nextVariableId++}clone(e){const t=se.runKernel(kd,{x:e}),s={x:e},r=o=>({x:()=>{const l="float32",u={x:o},d={dtype:l};return se.runKernel(yd,u,d)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(E_(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(u=>{i+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=r-t-i-o;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let u;const d=d1(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(d1(e)){const{kernelName:y,inputs:N,attrs:w}=e;this.backendName==null&&this.backend;const T=E_(y,this.backendName);W(T!=null,()=>`Cannot find registered kernel '${y}' for backend '${this.backendName}'`),l=()=>{const v=this.backend.numDataIds();u=T.kernelFunc({inputs:N,attrs:w,backend:this.backend});const E=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(y,v,E);const _=E.map(L=>L.rank!=null?L:this.makeTensorFromTensorInfo(L));if(r){const L=this.getTensorsForGradient(y,N,_);s=this.saveTensorsForBackwardMode(L)}return _}}else{const{forwardFunc:y}=e,N=w=>{r&&(s=w.map(T=>this.keep(this.clone(T))))};l=()=>{const w=this.backend.numDataIds();u=this.tidy(()=>y(this.backend,N));const T=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,w,T),T}}const{inputs:h,attrs:f}=e,m=d1(e)?null:e.backwardsFunc;let I;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=l():(I=this.profiler.profileKernel(d,h,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(I),t=I.outputs)}),r&&this.addTapeNode(d,h,t,m,s,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(y=>h[y]!=null?h[y].shape:null),outputShapes:t.map(y=>y.shape),kernelTimeMs:I.timeMs,extraInfo:I.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=k_(e);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let l;r.saveAllInputs?(W(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(t).map(d=>t[d])):l=i.map(d=>t[d]);const u=s.filter((d,h)=>o[h]);return l.concat(u)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&cd(e[0])&&(i=e.map(u=>Ba(u)));const o=r.write(i,t,s),l=new $n(t,s,o,this.nextTensorId());if(this.trackTensor(l,r),s==="string"){const u=this.state.tensorInfo.get(o),d=oM(i);this.state.numBytes+=d-u.bytes,u.bytes=d}return l}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,o=new $n(r,i,s,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new Up(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Fp(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Up||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Fp(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,o){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},u=k_(e);u!=null&&(r=u.gradFunc),r!=null&&(l.gradient=d=>(d=d.map((h,f)=>{if(h==null){const m=s[f],I=$s(m.size,m.dtype);return this.makeTensor(I,m.shape,m.dtype)}return h}),r(d.length>1?d:d[0],i,o))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Ak(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(W(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));W(i instanceof $n,()=>"The result y returned by f() must be a tensor.");const o=LM(this.state.activeTape,t,i);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??BM(i.shape),OM(l,o,d=>this.tidy(d),HM);const u=t.map(d=>l[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(const h of d.saved)h.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return W(K1(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{W(t.every(l=>l instanceof $n),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((l,u)=>{r[u]=l});const i=(l,u)=>(s=e(...t,u),W(s.value instanceof $n,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),W(K1(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(l,u)=>{const d=s.gradFunc(l,u),h=Array.isArray(d)?d:[d];W(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),W(h.every(m=>m instanceof $n),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return h.forEach((m,I)=>{f[I]=()=>m}),f};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=js(),s=await this.backend.time(e);return s.wallMs=js()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new W_;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}gu.nextTensorId=0;gu.nextVariableId=0;function BM(n){const e=yy(Te(n),"float32");return se.makeTensor(e,n,"float32")}function Sk(){const n=lk();if(n._tfengine==null){const e=new cM(n);n._tfengine=new gu(e)}return fM(n._tfengine.ENV),PM(()=>n._tfengine),n._tfengine}const se=Sk();function HM(n,e){const t={a:n,b:e};return se.runKernel(Lu,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UM(){return typeof navigator<"u"&&navigator!=null}function vk(n){if(n||UM()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function $k(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const er=xe();er.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});er.registerFlag("IS_BROWSER",()=>$k());er.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");er.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));er.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));er.registerFlag("PROD",()=>!1);er.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>er.getBool("DEBUG"));er.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);er.registerFlag("IS_TEST",()=>!1);er.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>er.getBool("DEBUG"));er.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);er.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);er.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ao(n,e){let t=n;if(Zr(n))return e==="string"?[]:[n.length];if(Nk(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(wk(n))return[n.buffer.size/(e==null?4:Fp(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Zr(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&_k(n,s,[]),s}function _k(n,e,t){if(t=t||[],!Array.isArray(n)&&!Zr(n)){W(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}W(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),W(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)_k(n[r],s,t.concat(r))}function B_(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function H(n,e,t,s="numeric"){if(n instanceof ve())return B_(s,n.dtype,e,t),n;let r=ku(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),B_(s,r,e,t),n==null||!Zr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const i=ao(n,r);!Zr(n)&&!Array.isArray(n)&&(n=[n]);const l=r!=="string"?xl(n,r):nl(n,[],!0);return se.makeTensor(l,i,r)}function Gp(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>H(i,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dk="__op";function J(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Dk;const r=(...i)=>{se.startScope(t);try{const o=s(...i);return tl(o)&&console.error("Cannot return a Promise inside of tidy."),se.endScope(o),o}catch(o){throw se.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GM(n,e){const t=H(n,"real","complex"),s=H(e,"imag","complex");yr(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return se.runKernel(vy,r)}const qa=J({complex_:GM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oo(n,e,t,s){if(s==null)s=ku(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(wk(n)||Nk(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return se.backend.createTensorFromGPUData(n,e||t,s)}if(!Zr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Cr(e);const r=Te(e),i=Te(t);W(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<t.length;++o){const l=t[o],u=o===t.length-1?l!==Te(e.slice(o)):!0;W(t[o]===e[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Zr(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?xl(n,s):nl(n,[],!0),se.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(n,e,t){const s=ao(n,t);return oo(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Ti{static join(e){return new Ti(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>Zr(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),o=new Uint8Array(i);let l=0;for(let u=s;u<this.shards.length;u++){const d=this.shards[u],f=e+l-d.start,m=l,y=Math.min(t,d.end)-d.start,N=new Uint8Array(d.buffer,f,y-f);if(o.set(N,m),l+=N.length,t<d.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=qM(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function qM(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fr(){return se}function rI(){return se.memory()}function pe(n,e){return se.tidy(n,e)}function Ft(n){Ak(n).forEach(t=>t.dispose())}function is(n){return se.keep(n)}function KM(){return se.backendName}function Ek(n,e,t=1){return se.registerBackend(n,e,t)}function kk(){return se.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ka=4;async function iI(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const l=r[o],u=Array.isArray(n)?n[o].tensor:n[l];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${l}': ${u.dtype}`);const d={name:l,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const h=new Promise(async f=>{const m=await u.bytes(),I=m.reduce((w,T)=>w+T.length,0)+Ka*m.length,y=new Uint8Array(I);let N=0;for(let w=0;w<m.length;w++){const T=m[w],v=new Uint8Array(new Uint32Array([T.length]).buffer);y.set(v,N),N+=Ka,y.set(T,N),N+=T.length}f(y)});s.push(h)}else s.push(u.data());e!=null&&(d.group=e),t.push(d)}const i=await Promise.all(s);return{data:XM(i),specs:t}}function Ck(n,e){const t=new Ti(n),s={};let r=0;for(const i of e){const o=jM(i,(l,u)=>t.slice(r+l,r+u));s[i.name]=Lk(i,t.slice(r,r+o)),r+=o}return s}function jM(n,e){const t=Te(n.shape);let s;if("quantization"in n){const r=n.quantization;s=sl[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Ka+new Uint32Array(e(r,r+Ka))[0];return r}else s=sl[n.dtype];return t*s}async function YM(n,e){const t=Te(n.shape);let s;if("quantization"in n){const r=n.quantization;s=sl[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Ka+new Uint32Array(await e(r,r+Ka))[0];return r}else s=sl[n.dtype];return t*s}function Lk(n,e){const t=n.name,s=n.dtype,r=n.shape,i=Te(r);let o,l=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=sl[u.dtype],h=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){o=new Float32Array(h.length);for(let f=0;f<h.length;f++){const m=h[f];o[f]=m*u.scale+u.min}}else if(u.dtype==="float16")o=nW()(h);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);o=new Int32Array(h.length);for(let f=0;f<h.length;f++){const m=h[f];o[f]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);l+=i*d}else if(s==="string"){const u=Te(n.shape);o=[];for(let d=0;d<u;d++){const h=new Uint32Array(e.slice(l,l+Ka))[0];l+=Ka;const f=new Uint8Array(e.slice(l,l+h));o.push(f),l+=h}}else{const u=sl[s];if(s==="float32")o=new Float32Array(e);else if(s==="int32")o=new Int32Array(e);else if(s==="bool")o=new Uint8Array(e);else if(s==="complex64"){o=new Float32Array(e);const d=new Float32Array(o.length/2),h=new Float32Array(o.length/2);for(let y=0;y<d.length;y++)d[y]=o[y*2],h[y]=o[y*2+1];const f=Dr(d,r,"float32"),m=Dr(h,r,"float32"),I=qa(f,m);return f.dispose(),m.dispose(),I}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);l+=i*u}return Dr(o,r,s)}async function H_(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:i}=await n.read();if(r&&i==null){const l=t-s.byteLength;throw new Error(`Reader is done but ${l} bytes are still expected`)}const o=new Uint8Array(s.length+i.byteLength);o.set(s,0),o.set(new Uint8Array(i),s.length),s=o}return s.buffer}async function Ok(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const i of e){const o=await YM(i,async(d,h)=>(r=await H_(s,r,h),r.slice(d,h)));r=await H_(s,r,o);const l=r.slice(0,o);r=r.slice(o);const u=Lk(i,l);if(t[i.name]=u,KM()==="webgpu"){const d=kk();"uploadToGPU"in d&&Te(u.shape)>=xe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&d.uploadToGPU(u.dataId)}}return t}function XM(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const v2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function U_(n){return v2?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function ZM(n){if(v2)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function QM(n){if(v2){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function Rk(n){return Ti.join(n)}function G_(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function Vk(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function Pk(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function $2(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),Pk(n,t,s)}function ah(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:U_(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:U_(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Ti(n.weightData).byteLength}}function aI(n){const e=[];for(const t of n)e.push(...t.weights);return e}function JM(){const n=t=>{let s=t<<13,r=0;for(;!(s&8388608);)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function eW(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function tW(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function nW(){const n=JM(),e=eW(),t=tW();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const l=s[o],u=n[t[l>>10]+(l&1023)]+e[l>>10];i[o]=u}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return vn.instance==null&&(vn.instance=new vn),vn.instance}static registerSaveRouter(e){vn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){vn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return vn.getHandlers(e,"save")}static getLoadHandlers(e,t){return vn.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?vn.getInstance().loadRouters:vn.getInstance().saveRouters).forEach(o=>{const l=o(e,s);l!==null&&r.push(l)}),r}}const sW=n=>vn.registerSaveRouter(n),rW=n=>vn.registerLoadRouter(n),Fk=n=>vn.getSaveHandlers(n),iW=(n,e)=>vn.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oI="tensorflowjs",lI=1,Go="models_store",Pa="model_info_store";function zk(){if(!xe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function uI(n){const e=n.result;e.createObjectStore(Go,{keyPath:"modelPath"}),e.createObjectStore(Pa,{keyPath:"modelPath"})}class rl{constructor(e){if(this.indexedDB=zk(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(oI,lI);i.onupgradeneeded=()=>uI(i),i.onsuccess=()=>{const o=i.result;if(t==null){const l=o.transaction(Go,"readonly"),d=l.objectStore(Go).get(this.modelPath);d.onsuccess=()=>{if(d.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(d.result.modelArtifacts)},d.onerror=h=>(o.close(),r(d.error)),l.oncomplete=()=>o.close()}else{t.weightData=Ti.join(t.weightData);const l=ah(t),u=o.transaction(Pa,"readwrite");let d=u.objectStore(Pa),h;try{h=d.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(m){return r(m)}let f;h.onsuccess=()=>{f=o.transaction(Go,"readwrite");const m=f.objectStore(Go);let I;try{I=m.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:l})}catch(y){return r(y)}I.onsuccess=()=>s({modelArtifactsInfo:l}),I.onerror=y=>{d=u.objectStore(Pa);const N=d.delete(this.modelPath);N.onsuccess=()=>(o.close(),r(I.error)),N.onerror=w=>(o.close(),r(I.error))}},h.onerror=m=>(o.close(),r(h.error)),u.oncomplete=()=>{f==null?o.close():f.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}rl.URL_SCHEME="indexeddb://";const Mk=n=>xe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(rl.URL_SCHEME)?aW(n.slice(rl.URL_SCHEME.length)):null;vn.registerSaveRouter(Mk);vn.registerLoadRouter(Mk);function aW(n){return new rl(n)}function oW(n){return n.startsWith(rl.URL_SCHEME)?n.slice(rl.URL_SCHEME.length):n}class lW{constructor(){this.indexedDB=zk()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(oI,lI);s.onupgradeneeded=()=>uI(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Pa,"readonly"),l=i.objectStore(Pa).getAll();l.onsuccess=()=>{const u={};for(const d of l.result)u[d.modelPath]=d.modelArtifactsInfo;e(u)},l.onerror=u=>(r.close(),t(l.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=oW(e),new Promise((t,s)=>{const r=this.indexedDB.open(oI,lI);r.onupgradeneeded=()=>uI(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Pa,"readwrite"),l=o.objectStore(Pa),u=l.get(e);let d;u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const h=l.delete(e),f=()=>{d=i.transaction(Go,"readwrite");const I=d.objectStore(Go).delete(e);I.onsuccess=()=>t(u.result.modelArtifactsInfo),I.onerror=y=>s(u.error)};h.onsuccess=f,h.onerror=m=>(f(),i.close(),s(u.error))}},u.onerror=h=>(i.close(),s(u.error)),o.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const la="/",Kl="tensorflowjs_models",Wk="info",uW="model_topology",cW="weight_specs",dW="weight_data",hW="model_metadata";function Bk(n){return{info:[Kl,n,Wk].join(la),topology:[Kl,n,uW].join(la),weightSpecs:[Kl,n,cW].join(la),weightData:[Kl,n,dW].join(la),modelMetadata:[Kl,n,hW].join(la)}}function Hk(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function pW(n){const e=n.split(la);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(la)}function fW(n){return n.startsWith(il.URL_SCHEME)?n.slice(il.URL_SCHEME.length):n}class il{constructor(e){if(!xe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Bk(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=ah(e),i=Ti.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,ZM(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw Hk(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const l=JSON.parse(i);t.format=l.format,t.generatedBy=l.generatedBy,t.convertedBy=l.convertedBy,l.signature!=null&&(t.signature=l.signature),l.userDefinedMetadata!=null&&(t.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(t.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(t.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(t.trainingConfig=l.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=QM(o),t}}il.URL_SCHEME="localstorage://";const Uk=n=>xe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(il.URL_SCHEME)?mW(n.slice(il.URL_SCHEME.length)):null;vn.registerSaveRouter(Uk);vn.registerLoadRouter(Uk);function mW(n){return new il(n)}class gW{constructor(){W(xe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),W(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Kl+la,s=la+Wk;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const o=pW(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=fW(e);const t=Bk(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return Hk(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ou="://";class Ls{constructor(){this.managers={}}static getInstance(){return Ls.instance==null&&(Ls.instance=new Ls),Ls.instance}static registerManager(e,t){W(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(ou)&&(e=e.slice(0,e.indexOf(ou))),W(e.length>0,()=>"scheme must not be an empty string.");const s=Ls.getInstance();W(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=Ls.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Ls.getInstance().managers)}}function Tp(n){if(n.indexOf(ou)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ls.getSchemes().join(",")}`);return{scheme:n.split(ou)[0],path:n.split(ou)[1]}}async function Gk(n,e,t=!1){W(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=vn.getLoadHandlers(n);W(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),W(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],i=vn.getSaveHandlers(e);W(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),W(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const o=i[0],l=Tp(n).scheme,u=Tp(n).path,d=l===Tp(n).scheme,h=await r.load();t&&d&&await Ls.getManager(l).removeModel(u);const f=await o.save(h);return t&&!d&&await Ls.getManager(l).removeModel(u),f.modelArtifactsInfo}async function IW(){const n=Ls.getSchemes(),e={};for(const t of n){const s=await Ls.getManager(t).listModels();for(const r in s){const i=t+ou+r;e[i]=s[r]}}return e}async function yW(n){const e=Tp(n);return Ls.getManager(e.scheme).removeModel(e.path)}async function bW(n,e){return Gk(n,e,!1)}async function xW(n,e){return Gk(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NW{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!xe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return dk(e)}}if(xe().get("IS_BROWSER")){xe().setPlatform("browser",new NW);try{Ls.registerManager(il.URL_SCHEME,new gW)}catch{}try{Ls.registerManager(rl.URL_SCHEME,new lW)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wW={importFetch:()=>require("node-fetch")};let h1;class AW{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return xe().global.fetch!=null?xe().global.fetch(e,t):(h1==null&&(h1=wW.importFetch()),h1(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}xe().get("IS_NODE")&&!xe().get("IS_BROWSER")&&xe().setPlatform("node",new AW);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zt(n,e="float32",t){return e=e||"float32",Cr(n),new Yn(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(n,e){const t=H(n,"x","cast");if(!aM(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return se.runKernel(yd,s,r)}const rt=J({cast_:TW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SW(n){const t={x:H(n,"x","clone","string_or_numeric")};return se.runKernel(kd,t)}const ha=J({clone_:SW});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qk(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Sk();const vW={buffer:zt,cast:rt,clone:ha,print:qk};FM(vW);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $W(n,e){let t=H(n,"a","add"),s=H(e,"b","add");[t,s]=Rn(t,s);const r={a:t,b:s};return se.runKernel(Lu,r)}const Me=J({add_:$W});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _W(n,e){let t=H(n,"a","floorDiv"),s=H(e,"b","floorDiv");[t,s]=Rn(t,s);const r={a:t,b:s};return se.runKernel(Dd,r)}const _2=J({floorDiv_:_W});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DW(n,e){let t=H(n,"a","div"),s=H(e,"b","div");if([t,s]=Rn(t,s),t.dtype==="int32"&&s.dtype==="int32")return _2(t,s);const r={a:t,b:s},i={};return se.runKernel(Ad,r,i)}const bt=J({div_:DW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(n,e){let t=H(n,"a","mul"),s=H(e,"b","mul");[t,s]=Rn(t,s);const r={a:t,b:s};return se.runKernel(Md,r)}const ne=J({mul_:EW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(n){const e=H(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return se.runKernel(Pf,t)}else{const t={x:e};return se.runKernel(_f,t)}}const Gn=J({abs_:kW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CW(n){const t={x:H(n,"x","acos")};return se.runKernel(dd,t)}const Kk=J({acos_:CW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LW(n){const t={x:H(n,"x","acosh")};return se.runKernel(hd,t)}const jk=J({acosh_:LW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OW(n){W(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),W(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,i)=>H(r,`tensors${i}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Kt(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return se.runKernel(Df,s)}const RW=J({addN_:OW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VW(n,e=null,t=!1){const r={x:H(n,"x","all","bool")},i={axis:e,keepDims:t};return se.runKernel(xy,r,i)}const D2=J({all_:VW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PW(n,e=null,t=!1){const r={x:H(n,"x","any","bool")},i={axis:e,keepDims:t};return se.runKernel(Ny,r,i)}const qp=J({any_:PW});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FW(n,e=0){const s={x:H(n,"x","argMax")},r={axis:e};return se.runKernel(Ef,s,r)}const Iu=J({argMax_:FW});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zW(n,e=0){const s={x:H(n,"x","argMin")},r={axis:e};return se.runKernel(kf,s,r)}const Yk=J({argMin_:zW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MW(n){const t={x:H(n,"x","asin")};return se.runKernel(pd,t)}const Xk=J({asin_:MW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WW(n){const t={x:H(n,"x","asinh")};return se.runKernel(fd,t)}const Zk=J({asinh_:WW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BW(n){const t={x:H(n,"x","atan")};return se.runKernel(md,t)}const Qk=J({atan_:BW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HW(n,e){let t=H(n,"a","atan2"),s=H(e,"b","atan2");[t,s]=Rn(t,s);const r={a:t,b:s};return se.runKernel(Id,r)}const Jk=J({atan2_:HW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UW(n){const t={x:H(n,"x","atanh")};return se.runKernel(gd,t)}const eC=J({atanh_:UW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oh(n,e,t,s,r="NHWC",i){const o=n[3],l=[...e,o],u=xa(r);return ls(n,l,t,i,s,null,null,u)}function ei(n,e,t,s,r,i,o="channelsLast"){const[l,u]=Uc(e);let d;if(o==="channelsLast")d=[l,u,n[3],n[3]];else if(o==="channelsFirst")d=[l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return ls(n,d,t,s,r,i,!1,o)}function ba(n,e,t,s,r,i,o="NDHWC"){const[l,u,d]=cI(e);let h,f;if(o==="NDHWC")f="channelsLast",h=[l,u,d,n[4],n[4]];else if(o==="NCDHW")f="channelsFirst",h=[l,u,d,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return lo(n,h,t,s,r,!1,f,i)}function ls(n,e,t,s,r,i,o=!1,l="channelsLast"){let[u,d,h,f]=[-1,-1,-1,-1];if(l==="channelsLast")[u,d,h,f]=n;else if(l==="channelsFirst")[u,f,d,h]=n;else throw new Error(`Unknown dataFormat ${l}`);const[m,I,,y]=e,[N,w]=Uc(t),[T,v]=Uc(s),E=lu(m,T),_=lu(I,v),{padInfo:L,outHeight:P,outWidth:B}=KW(r,d,h,N,w,E,_,i,l),U=o?y*f:y;let Z;return l==="channelsFirst"?Z=[u,U,P,B]:l==="channelsLast"&&(Z=[u,P,B,U]),{batchSize:u,dataFormat:l,inHeight:d,inWidth:h,inChannels:f,outHeight:P,outWidth:B,outChannels:U,padInfo:L,strideHeight:N,strideWidth:w,filterHeight:m,filterWidth:I,effectiveFilterHeight:E,effectiveFilterWidth:_,dilationHeight:T,dilationWidth:v,inShape:n,outShape:Z,filterShape:e}}function lo(n,e,t,s,r,i=!1,o="channelsLast",l){let[u,d,h,f,m]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,d,h,f,m]=n;else if(o==="channelsFirst")[u,m,d,h,f]=n;else throw new Error(`Unknown dataFormat ${o}`);const[I,y,N,,w]=e,[T,v,E]=cI(t),[_,L,P]=cI(s),B=lu(I,_),U=lu(y,L),Z=lu(N,P),{padInfo:Y,outDepth:ae,outHeight:de,outWidth:ce}=jW(r,d,h,f,T,v,E,B,U,Z,l),Ie=i?w*m:w;let be;return o==="channelsFirst"?be=[u,Ie,ae,de,ce]:o==="channelsLast"&&(be=[u,ae,de,ce,Ie]),{batchSize:u,dataFormat:o,inDepth:d,inHeight:h,inWidth:f,inChannels:m,outDepth:ae,outHeight:de,outWidth:ce,outChannels:Ie,padInfo:Y,strideDepth:T,strideHeight:v,strideWidth:E,filterDepth:I,filterHeight:y,filterWidth:N,effectiveFilterDepth:B,effectiveFilterHeight:U,effectiveFilterWidth:Z,dilationDepth:_,dilationHeight:L,dilationWidth:P,inShape:n,outShape:be,filterShape:e}}function GW(n,e,t,s,r){s==null&&(s=E2(n,e,t));const i=n[0],o=n[1],l=Gc((i-e+2*s)/t+1,r),u=Gc((o-e+2*s)/t+1,r);return[l,u]}function qW(n,e,t,s,r,i){r==null&&(r=E2(n,e[0],s[0]));const o=[0,0,0,t];for(let l=0;l<3;l++)n[l]+2*r>=e[l]&&(o[l]=Gc((n[l]-e[l]+2*r)/s[l]+1,i));return o}function E2(n,e,t,s=1){const r=lu(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function Uc(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function cI(n){return typeof n=="number"?[n,n,n]:n}function lu(n,e){return e<=1?n:n+(n-1)*(e-1)}function KW(n,e,t,s,r,i,o,l,u){let d,h,f;if(typeof n=="number"){d={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const I=GW([e,t],i,s,n,l);h=I[0],f=I[1]}else if(n==="same"){h=Math.ceil(e/s),f=Math.ceil(t/r);const m=Math.max(0,(h-1)*s+i-e),I=Math.max(0,(f-1)*r+o-t),y=Math.floor(m/2),N=m-y,w=Math.floor(I/2),T=I-w;d={top:y,bottom:N,left:w,right:T,type:"SAME"}}else if(n==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-i+1)/s),f=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const m=u==="channelsLast"?n[1][0]:n[2][0],I=u==="channelsLast"?n[1][1]:n[2][1],y=u==="channelsLast"?n[2][0]:n[3][0],N=u==="channelsLast"?n[2][1]:n[3][1];d={top:m,bottom:I,left:y,right:N,type:m===0&&I===0&&y===0&&N===0?"VALID":"EXPLICIT"},h=Gc((e-i+m+I)/s+1,l),f=Gc((t-o+y+N)/r+1,l)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outHeight:h,outWidth:f}}function jW(n,e,t,s,r,i,o,l,u,d,h){let f,m,I,y;if(n==="valid"&&(n=0),typeof n=="number"){f={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=qW([e,t,s,1],[l,u,d],1,[r,i,o],n,h);m=w[0],I=w[1],y=w[2]}else if(n==="same"){m=Math.ceil(e/r),I=Math.ceil(t/i),y=Math.ceil(s/o);const N=(m-1)*r+l-e,w=(I-1)*i+u-t,T=(y-1)*o+d-s,v=Math.floor(N/2),E=N-v,_=Math.floor(w/2),L=w-_,P=Math.floor(T/2),B=T-P;f={top:_,bottom:L,left:P,right:B,front:v,back:E,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:f,outDepth:m,outHeight:I,outWidth:y}}function Gc(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function ja(n){const[e,t,s]=Uc(n);return e===1&&t===1&&s===1}function bs(n,e){return ja(n)||ja(e)}function al(n){return Uc(n).every(e=>e>0)}function xa(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Bs(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")W(fu(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{W(fu(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YW(n,e){const s={x:H(n,"x","reshape","string_or_numeric")},r={shape:e};return se.runKernel(Im,s,r)}const ie=J({reshape_:YW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XW(n,e,t,s,r){const i=H(n,"x","avgPool","float32"),o=1;W(bs(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let l=i,u=!1;i.rank===3&&(u=!0,l=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(l.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${l.rank}.`),Bs("avgPool",s,r);const d={x:l},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let f=se.runKernel(Cf,d,h);return f=rt(f,i.dtype),u?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Cm=J({avgPool_:XW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZW(n,e,t,s,r,i="NDHWC"){const o=H(n,"x","avgPool3d","float32");let l=o,u=!1;o.rank===4&&(u=!0,l=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(l.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),W(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),W(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Bs("avgPool3d",s,r);const d={x:l},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let f=se.runKernel(Lf,d,h);return f=rt(f,l.dtype),u?ie(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const tC=J({avgPool3d_:ZW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QW(n,e=0){W(n.length>=1,()=>"Pass at least one tensor to concat");const t=Gp(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return ha(t[0]);const s=t,r={axis:e};return se.runKernel(Ff,s,r)}const Un=J({concat_:QW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JW(n,e,t=!1,s=!1){let r=H(n,"a","matMul"),i=H(e,"b","matMul");[r,i]=Rn(r,i);const o={a:r,b:i},l={transposeA:t,transposeB:s};return se.runKernel(Of,o,l)}const Gt=J({matMul_:JW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(n){const t={x:H(n,"x","sigmoid","float32")};return se.runKernel(Zd,t)}const Wi=J({sigmoid_:eB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tB(n,e,t){const s=H(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return se.runKernel(wm,r,i)}const Yt=J({slice_:tB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(n){const t={x:H(n,"x","tanh","float32")};return se.runKernel(sh,t)}const ol=J({tanh_:nB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sB(n,e,t,s,r,i){const o=H(n,"forgetBias","basicLSTMCell"),l=H(e,"lstmKernel","basicLSTMCell"),u=H(t,"lstmBias","basicLSTMCell"),d=H(s,"data","basicLSTMCell"),h=H(r,"c","basicLSTMCell"),f=H(i,"h","basicLSTMCell"),m=Un([d,f],1),I=Gt(m,l),y=Me(I,u),N=y.shape[0],w=y.shape[1]/4,T=[N,w],v=Yt(y,[0,0],T),E=Yt(y,[0,w],T),_=Yt(y,[0,w*2],T),L=Yt(y,[0,w*3],T),P=Me(ne(Wi(v),ol(E)),ne(h,Wi(Me(o,_)))),B=ne(ol(P),Wi(L));return[P,B]}const rB=J({basicLSTMCell_:sB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(n,e,t){const s=H(n,"x","batchToSpaceND"),r=e.reduce((l,u)=>l*u);W(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),W(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),W(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},o={blockShape:e,crops:t};return se.runKernel(Rf,i,o)}const Lm=J({batchToSpaceND_:iB});function aB(n){let e;return n.rank===0||n.rank===1?e=ie(n,[1,1,1,n.size]):n.rank===2?e=ie(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(n,e,t,s,r,i){i==null&&(i=.001);const o=H(n,"x","batchNorm"),l=H(e,"mean","batchNorm"),u=H(t,"variance","batchNorm");let d;r!=null&&(d=H(r,"scale","batchNorm"));let h;s!=null&&(h=H(s,"offset","batchNorm")),W(l.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(h==null||l.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(d==null||l.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:aB(o),scale:d,offset:h,mean:l,variance:u},I={varianceEpsilon:i},y=se.runKernel(Kf,m,I);return ie(y,o.shape)}const lh=J({batchNorm_:oB});function lB(n,e,t,s,r,i){const o=H(n,"x","batchNorm"),l=H(e,"mean","batchNorm"),u=H(t,"variance","batchNorm");let d;r!=null&&(d=H(r,"scale","batchNorm"));let h;return s!=null&&(h=H(s,"offset","batchNorm")),W(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),W(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${l.rank}.`),W(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),d!=null&&W(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${d.rank}.`),h!=null&&W(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),lh(o,l,u,h,d,i)}const nC=J({batchNorm2d_:lB});function uB(n,e,t,s,r,i){const o=H(n,"x","batchNorm"),l=H(e,"mean","batchNorm"),u=H(t,"variance","batchNorm");let d;r!=null&&(d=H(r,"scale","batchNorm"));let h;return s!=null&&(h=H(s,"offset","batchNorm")),W(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),W(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${l.rank}.`),W(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),d!=null&&W(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${d.rank}.`),h!=null&&W(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),lh(o,l,u,h,d,i)}const sC=J({batchNorm3d_:uB});function cB(n,e,t,s,r,i){const o=H(n,"x","batchNorm"),l=H(e,"mean","batchNorm"),u=H(t,"variance","batchNorm");let d;r!=null&&(d=H(r,"scale","batchNorm"));let h;return s!=null&&(h=H(s,"offset","batchNorm")),W(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),W(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${l.rank}.`),W(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),d!=null&&W(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${d.rank}.`),h!=null&&W(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),lh(o,l,u,h,d,i)}const rC=J({batchNorm4d_:cB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(n,e,t){const s=H(n,"x","bincount"),r=H(e,"weights","bincount");W(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),W(t>=0,()=>`size must be non-negative, but got ${t}.`),W(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:t};return se.runKernel(Ty,i,o)}const iC=J({bincount_:dB});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hB(n,e){const t=H(n,"x","bitwiseAnd"),s=H(e,"y","bitwiseAnd");if(!Kt(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return se.runKernel(Vf,r)}const pB=J({bitwiseAnd_:hB});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(n,e){const t=H(n,"s0","broadcastArgs","int32"),s=H(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return se.runKernel(Sy,r)}const mB=J({broadcastArgs_:fB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gB(n,e){let t=H(n,"broadcastTo","x");const s=t.shape;if(Cr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const d=t.shape.slice();for(;d.length<e.length;)d.unshift(1);t=ie(t,d)}const r=t.shape,i=Array.from(e);for(let d=e.length-1;d>=0;d--)if(r[d]===e[d])i[d]=1;else if(t.shape[d]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((d,h)=>d>1?h:-1).filter(d=>d>=0).length===0)return ha(t);const l={x:t},u={reps:i};return se.runKernel(rh,l,u)}const uu=J({broadcastTo_:gB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IB(n){const t={x:H(n,"x","ceil","float32")};return se.runKernel(bd,t)}const aC=J({ceil_:IB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ou(n,e,t){Cr(n),t=t||ku(e);const s={shape:n,value:e,dtype:t};return se.runKernel(My,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yB(n,e,t){const s=H(n,"x","clipByValue");if(W(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Ou(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return se.runKernel(xd,r,i)}const hr=J({clipByValue_:yB});function bB(n){return Un(n,0)}const oC=J({concat1d_:bB});function xB(n,e){return Un(n,e)}const lC=J({concat2d_:xB});function NB(n,e){return Un(n,e)}const uC=J({concat3d_:NB});function wB(n,e){return Un(n,e)}const cC=J({concat4d_:wB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(n,e,t,s,r="NHWC",i=[1,1],o){const l=H(n,"x","conv2d","float32"),u=H(e,"filter","conv2d","float32");let d=l,h=!1;l.rank===3&&(h=!0,d=ie(l,[1,l.shape[0],l.shape[1],l.shape[2]])),W(d.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`),W(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Bs("conv2d",s,o);const f=r==="NHWC"?d.shape[3]:d.shape[1];W(f===u.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${u.shape[2]}.`),W(bs(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),W(al(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),W(al(t),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:d,filter:u},I={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},y=se.runKernel(zf,m,I);return h?ie(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const Ya=J({conv2d_:AB});function TB(n,e,t,s,r="NWC",i=1,o){const l=H(n,"x","conv1d"),u=H(e,"filter","conv1d");let d=l,h=!1;l.rank===2&&(h=!0,d=ie(l,[1,l.shape[0],l.shape[1]])),W(d.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${d.rank}.`),W(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Bs("conv1d",s,o),W(d.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${d.shape[2]}) must match input depth for filter ${u.shape[1]}.`),W(bs(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),W(al(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),W(al(t),()=>"Error in conv1D: Stride should be larger than 0."),W(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const f=ie(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=ie(d,[d.shape[0],1,d.shape[1],d.shape[2]]),w=Ya(m,f,[1,t],s,"NHWC",[1,i],o);return h?ie(w,[w.shape[2],w.shape[3]]):ie(w,[w.shape[0],w.shape[2],w.shape[3]])}const k2=J({conv1d_:TB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SB(n,e,t,s,r,i="NHWC",o){W(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let l=n,u=e,d=!1;e.rank===3&&(d=!0,u=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]),l=[1,n[0],n[1],n[2]]),W(l.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`),W(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),W(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const h=i==="NHWC"?l[3]:l[1],f=i==="NHWC"?u.shape[3]:u.shape[1];W(h===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${t.shape[2]}.`),W(f===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${t.shape[3]}.`),Bs("conv2dDerInput",r,o);const m={dy:u,filter:t},I={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:l},y=se.runKernel(Mf,m,I);return d?ie(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const C2=J({conv2DBackpropInput_:SB});function vB(n,e,t,s,r,i){const o=H(n,"x","conv2dTranspose"),l=H(e,"filter","conv2dTranspose");return C2(t,o,l,s,r,"NHWC",i)}const L2=J({conv2dTranspose_:vB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(n,e,t,s,r="NDHWC",i=[1,1,1]){const o=H(n,"x","conv3d"),l=H(e,"filter","conv3d");let u=o,d=!1;o.rank===4&&(d=!0,u=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),W(l.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`),W(u.shape[4]===l.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${l.shape[3]}.`),W(bs(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),W(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),W(al(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),W(al(t),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:u,filter:l},f={strides:t,pad:s,dataFormat:r,dilations:i},m=se.runKernel(Wf,h,f);return d?ie(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const dC=J({conv3d_:$B});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _B(n,e,t,s,r){W(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,l=!1;e.rank===4&&(l=!0,o=ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const u=i[4],d=o.shape[4];W(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),W(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),W(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),W(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),W(d===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[4]}.`);const h={dy:o,filter:t},f={pad:r,strides:s,inputShape:i},m=se.runKernel(Dy,h,f);return l?ie(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const hC=J({conv3DBackpropInput_:_B});function DB(n,e,t,s,r){const i=H(n,"x","conv3dTranspose"),o=H(e,"filter","conv3dTranspose");return hC(t,i,o,s,r)}const pC=J({conv3dTranspose_:DB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EB(n){const t={x:H(n,"x","cos","float32")};return se.runKernel(Nd,t)}const Om=J({cos_:EB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kB(n){const t={x:H(n,"x","cosh","float32")};return se.runKernel(wd,t)}const O2=J({cosh_:kB});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CB(n,e=0,t=!1,s=!1){const i={x:H(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:s};return se.runKernel(Ey,i,o)}const Kp=J({cumprod_:CB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LB(n,e=0,t=!1,s=!1){const i={x:H(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return se.runKernel(Bf,i,o)}const R2=J({cumsum_:LB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(n,e,t,s=!1){const r=H(n,"x","denseBincount"),i=H(e,"weights","denseBincount");W(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),W(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),W(t>=0,()=>`size must be non-negative, but got ${t}.`),W(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},l={size:t,binaryOutput:s};return se.runKernel(Cy,o,l)}const dI=J({denseBincount_:OB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RB(n,e,t="NHWC"){const s=H(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];W(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),W(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),W(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),W(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const l={x:s},u={blockSize:e,dataFormat:t};return se.runKernel(Ly,l,u)}const fC=J({depthToSpace_:RB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VB(n,e,t,s,r="NHWC",i=[1,1],o){const l=H(n,"x","depthwiseConv2d","float32"),u=H(e,"filter","depthwiseConv2d","float32");let d=l,h=!1;l.rank===3&&(h=!0,d=ie(l,[1,l.shape[0],l.shape[1],l.shape[2]])),W(d.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),W(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const f=r==="NHWC"?d.shape[3]:d.shape[1];W(f===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${u.shape[2]}.`),Bs("depthwiseConv2d",s,o);const m={x:d,filter:u},I={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},y=se.runKernel(Hf,m,I);return h?ie(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const uh=J({depthwiseConv2d_:VB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PB(n){const t={x:H(n,"x","diag")};return se.runKernel(Vy,t)}const FB=J({diag_:PB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zB(n,e,t,s,r=[1,1],i="NHWC"){const o=H(n,"x","dilation2d"),l=H(e,"filter","dilation2d");W(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),W(l.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`),W(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let u=o,d=!1;o.rank===3&&(u=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]]),d=!0),W(u.shape[3]===l.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${l.shape[2]}`);const h={x:u,filter:l},f={strides:t,pad:s,dilations:r},m=se.runKernel(Uf,h,f);return d?ie(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const mC=J({dilation2d_:zB});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yu(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,o=n[i]||1;(e[e.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function Jn(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,o=e[i];(r==null||r===1&&o>1)&&t.unshift(i)}return t}function Lt(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=e[e.length-r-1];if(o==null&&(o=1),i===1)s[t-r-1]=o;else if(o===1)s[t-r-1]=i;else if(i!==o){const l=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(l)}else s[t-r-1]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(n,e){let t=H(n,"a","equal","string_or_numeric"),s=H(e,"b","equal","string_or_numeric");[t,s]=Rn(t,s),Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Gf,r)}const yi=J({equal_:MB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(n,e,t){const s=H(e,"a","where"),r=H(t,"b","where"),i=H(n,"condition","where","bool"),o=Lt(Lt(i.shape,s.shape),r.shape),l=uu(i,o),u=uu(s,o),d=uu(r,o),h={condition:l,t:u,e:d};return se.runKernel(Nm,h)}const vs=J({where_:WB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(n){const t={x:H(n,"x","zerosLike")};return se.runKernel(Em,t)}const Zt=J({zerosLike_:BB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(n,e){let t=H(n,"a","div"),s=H(e,"b","div");[t,s]=Rn(t,s);const r=bt(t,s),i=Zt(r),o=yi(s,i);return vs(o,i,r)}const gC=J({divNoNan_:HB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UB(n,e){const t=H(n,"t1","dot"),s=H(e,"t2","dot");W((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(W(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const o=ie(t,[1,-1]),l=ie(s,[-1,1]),u=Gt(o,l);return ie(u,[])}else if(t.rank===1&&s.rank===2){const o=ie(t,[1,-1]),l=ie(s,[s.shape[0],s.shape[1]]),u=Gt(o,l);return ie(u,[u.size])}else if(t.rank===2&&s.rank===1){const o=ie(s,[-1,1]),l=Gt(t,o);return ie(l,[l.size])}else{const o=ie(s,[s.shape[0],s.shape[1]]);return Gt(t,o)}}const IC=J({dot_:UB});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GB(n,...e){const t=e.map((r,i)=>H(r,`tensors${i}`,"einsum")),s={equation:n};return se.runKernel(Py,t,s)}const jl=J({einsum_:GB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qB(n){const t={x:H(n,"x","elu","float32")};return se.runKernel(Td,t)}const ch=J({elu_:qB});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB(n,e){const t=H(n,"x","ensureShape","string_or_numeric");if(!rM(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const jB=J({ensureShape_:KB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YB(n){let e=H(n,"x","erf");W(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=rt(e,"float32"));const t={x:e};return se.runKernel(Sd,t)}const V2=J({erf_:YB});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function yC(n,e,t){const s=n.length+e.length,r=[];let i=0,o=0;for(let l=0;l<s;l++)t.indexOf(l)===-1?r.push(n[i++]):r.push(e[o++]);return r}function us(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function Fn(n,e){const t=e.map(s=>1);return yC(n,t,e)}function xs(n,e,t){W(P2(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function En(n,e){if(P2(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function uo(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function zn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XB(n,e=null,t=!1){const r={x:H(n,"x","max")},i={reductionIndices:e,keepDims:t};return se.runKernel(sm,r,i)}const Yr=J({max_:XB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZB(n,e=null,t=!1){const r={x:H(n,"x","min")},i={axis:e,keepDims:t};return se.runKernel(om,r,i)}const qc=J({min_:ZB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QB(n,e){let t=H(n,"base","pow"),s=H(e,"exp","pow");[t,s]=Rn(t,s);const r={a:t,b:s};return se.runKernel(Wd,r)}const fa=J({pow_:QB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function At(n,e){if((Zr(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Zr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return oo(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(n){const t={x:H(n,"x","sqrt","float32")};return se.runKernel(Jd,t)}const ys=J({sqrt_:JB});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eH(n){const e=H(n,"x","square"),t={};return se.runKernel("Square",{x:e},t)}const pn=J({square_:eH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tH(n,e=null,t=!1){let s=H(n,"x","sum");s.dtype==="bool"&&(s=rt(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return se.runKernel(Am,r,i)}const ft=J({sum_:tH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nH(n,e="euclidean",t=null,s=!1){n=H(n,"x","norm");const r=bC(n,e,t);let i=r.shape;if(s){const o=Bt(t,n.shape);i=Fn(r.shape,o)}return ie(r,i)}function bC(n,e,t=null){if(n.rank===0)return Gn(n);if(n.rank!==1&&t===null)return bC(ie(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return ft(Gn(n),t);if(e===1/0)return Yr(Gn(n),t);if(e===-1/0)return qc(Gn(n),t);if(e==="euclidean"||e===2)return ys(ft(fa(Gn(n),At(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Yr(ft(Gn(n),t[0]),t[1]-1);if(e===1/0)return Yr(ft(Gn(n),t[1]),t[0]);if(e===-1/0)return qc(ft(Gn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return ys(ft(pn(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const dh=J({norm_:nH});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(n,e=null,t=!1){return dh(n,"euclidean",e,t)}const xC=J({euclideanNorm_:sH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rH(n){const t={x:H(n,"x","exp")};return se.runKernel(vd,t)}const pr=J({exp_:rH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iH(n,e=0){const t=H(n,"x","expandDims","string_or_numeric");W(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return se.runKernel(qf,s,r)}const Ps=J({expandDims_:iH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aH(n){const t={x:H(n,"x","expm1")};return se.runKernel($d,t)}const NC=J({expm1_:aH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oH(n,e){const t=H(n,"x","tile","string_or_numeric");W(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return se.runKernel(rh,s,r)}const Ur=J({tile_:oH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lH(n,e,t,s="float32"){e==null&&(e=n);const r=zt([n,e],s),i=n<=e?n:e;for(let l=0;l<i;++l)r.set(1,l,l);const o=ie(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Ur(Ps(o,0),[t[0],1,1]);if(t.length===2)return Ur(Ps(Ps(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Ur(Ps(Ps(Ps(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const F2=J({eye_:lH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uH(n){const t={x:H(n,"x","floor","float32")};return se.runKernel(_d,t)}const hh=J({floor_:uH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cH(n,e,t=0,s=0){const r=H(n,"x","gather"),i=H(e,"indices","gather","int32"),o={x:r,indices:i},l={axis:t,batchDims:s};return se.runKernel(jf,o,l)}const ph=J({gather_:cH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dH(n,e){let t=H(n,"a","greater","string_or_numeric"),s=H(e,"b","greater","string_or_numeric");[t,s]=Rn(t,s),Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Yf,r)}const xr=J({greater_:dH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hH(n,e){let t=H(n,"a","greaterEqual","string_or_numeric"),s=H(e,"b","greaterEqual","string_or_numeric");[t,s]=Rn(t,s),Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Ed,r)}const co=J({greaterEqual_:hH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pH(n){const t={input:H(n,"input","imag")};return se.runKernel(Uy,t)}const Rm=J({imag_:pH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fH(n){const t={x:H(n,"x","isFinite")};return se.runKernel(Cd,t)}const wC=J({isFinite_:fH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mH(n){const t={x:H(n,"x","isInf")};return se.runKernel(Ld,t)}const AC=J({isInf_:mH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gH(n){const t={x:H(n,"x","isNaN")};return se.runKernel(Od,t)}const TC=J({isNaN_:gH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IH(n,e=.2){const s={x:H(n,"x","leakyRelu")},r={alpha:e};return se.runKernel(Xf,s,r)}const Vm=J({leakyRelu_:IH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yH(n,e){let t=H(n,"a","less","string_or_numeric"),s=H(e,"b","less","string_or_numeric");[t,s]=Rn(t,s),Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Zf,r)}const Kc=J({less_:yH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bH(n,e){let t=H(n,"a","lessEqual","string_or_numeric"),s=H(e,"b","lessEqual","string_or_numeric");[t,s]=Rn(t,s),Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Qf,r)}const Nl=J({lessEqual_:bH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xH(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return se.runKernel(Gy,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NH(n,e=5,t=1,s=1,r=.5){const i=H(n,"x","localResponseNormalization");W(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),W(fu(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,l=!1;i.rank===3&&(l=!0,o=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u={x:o},d={depthRadius:e,bias:t,alpha:s,beta:r},h=se.runKernel(nm,u,d);return l?ie(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const SC=J({localResponseNormalization_:NH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wH(n){const t={x:H(n,"x","log","float32")};return se.runKernel(Rd,t)}const Er=J({log_:wH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AH(n){const t={x:H(n,"x","log1p")};return se.runKernel(Vd,t)}const Pm=J({log1p_:AH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TH(n,e){W(K1(n),()=>"The f passed in variableGrads(f) must be a function"),W(e==null||Array.isArray(e)&&e.every(d=>d instanceof Up),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const d in se.registeredVariables)e.push(se.registeredVariables[d])}const s=t?e.filter(d=>!d.trainable):null,r=e.length;e=e.filter(d=>d.trainable),W(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:l}=se.gradients(n,e,null,i);W(l.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),W(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return e.forEach((d,h)=>{l[h]!=null&&(u[d.name]=l[h])}),s!=null&&s.forEach(d=>u[d.name]=null),{value:o,grads:u}}function ma(n){return se.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SH(n){const t={x:H(n,"x","neg")};return se.runKernel(um,t)}const wn=J({neg_:SH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vH(n){const t={x:H(n,"x","softplus")};return se.runKernel(Qd,t)}const Ru=J({softplus_:vH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $H(n){const e=H(n,"x","logSigmoid");return ma(s=>({value:wn(Ru(wn(s))),gradFunc:o=>ne(o,Wi(wn(s)))}))(e)}const vC=J({logSigmoid_:$H});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _H(n,e){let t=H(n,"a","sub"),s=H(e,"b","sub");[t,s]=Rn(t,s);const r={a:t,b:s};return se.runKernel(th,r)}const ut=J({sub_:_H});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DH(n,e=-1){const t=H(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return ma((r,i)=>{const l=Yr(r,e,!0),u=ut(r,l),d=ut(rt(u,"float32"),Er(ft(pr(u),e,!0)));return i([d]),{value:d,gradFunc:(f,m)=>{const[I]=m,y=!0,N=pr(I);return ut(f,ne(ft(f,e,y),N))}}})(t)}const z2=J({logSoftmax_:DH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EH(n,e=null,t=!1){const s=H(n,"x","logSumExp"),r=Bt(e,s.shape),i=Yr(s,r,!0),o=ut(s,i),l=pr(o),u=ft(l,r),d=Er(u),h=Me(ie(i,d.shape),d);if(t){const f=Fn(h.shape,r);return ie(h,f)}return h}const Fm=J({logSumExp_:EH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kH(n,e){const t=H(n,"a","logicalAnd","bool"),s=H(e,"b","logicalAnd","bool");Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Jf,r)}const Ki=J({logicalAnd_:kH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CH(n){const t={x:H(n,"x","logicalNot","bool")};return se.runKernel(em,t)}const zm=J({logicalNot_:CH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LH(n,e){const t=H(n,"a","logicalOr","bool"),s=H(e,"b","logicalOr","bool");Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(tm,r)}const M2=J({logicalOr_:LH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OH(n,e){const t=H(n,"a","logicalXor","bool"),s=H(e,"b","logicalXor","bool");return Lt(t.shape,s.shape),Ki(M2(n,e),zm(Ki(n,e)))}const $C=J({logicalXor_:OH});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const np=2147483648;function RH(n,e,t="left"){const s=H(n,"sortedSequence","searchSorted"),r=H(e,"values","searchSorted"),i=s.shape[s.shape.length-1],o=r.shape[r.shape.length-1],l=ie(s,[-1,i]),u=ie(r,[-1,o]);if(l.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(l.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Te(u.shape)>=np)throw new Error(`values tensor size must less than ${np}`);if(l.shape[1]>=np)throw new Error(`trailing dim_size must less than ${np} for int32 output type, was ${l.shape[1]}`);const d={sortedSequence:l,values:u},h={side:t};return se.runKernel(u2,d,h)}const W2=J({searchSorted_:RH});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VH(n,e){return W2(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PH(n,e,t,s,r){const i=H(n,"x","maxPool"),o=1;let l=i,u=!1;i.rank===3&&(u=!0,l=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(l.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.rank}.`),W(bs(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Bs("maxPool",s,r);const d={x:l},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r},f=se.runKernel(rm,d,h);return u?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Mm=J({maxPool_:PH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FH(n,e=[1,1,1],t,s,r,i="NDHWC"){const o=H(n,"x","maxPool3d");let l=o,u=!1;o.rank===4&&(u=!0,l=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),W(l.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),W(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Bs("maxPool3d",s,r);const d={x:l},h={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},f=se.runKernel(im,d,h);return u?ie(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const _C=J({maxPool3d_:FH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zH(n,e,t,s,r=!1){const o={x:H(n,"x","maxPoolWithArgmax")},l={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},u=se.runKernel(Yy,o,l);return{result:u[0],indexes:u[1]}}const MH=J({maxPoolWithArgmax_:zH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WH(n,e){let t=H(n,"a","maximum"),s=H(e,"b","maximum");[t,s]=Rn(t,s),t.dtype==="bool"&&(t=rt(t,"int32"),s=rt(s,"int32")),Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Pd,r)}const Na=J({maximum_:WH});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BH(n,e=null,t=!1){const r={x:H(n,"x","mean")},i={axis:e,keepDims:t};return se.runKernel(am,r,i)}const On=J({mean_:BH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qn(n,e="float32"){if(Cr(n),e==="complex64"){const s=qn(n,"float32"),r=qn(n,"float32");return qa(s,r)}const t=$s(Te(n),e);return se.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(n,e="float32"){if(Cr(n),e==="complex64"){const s=ur(n,"float32"),r=qn(n,"float32");return qa(s,r)}const t=yy(Te(n),e);return se.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HH(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=H(n,"x","meshgrid",n instanceof $n?n.dtype:"float32");if(e===void 0)return[s];let r=H(e,"y","meshgrid",e instanceof $n?e.dtype:"float32");const i=Te(s.shape),o=Te(r.shape);return t==="xy"?(s=ie(s,[1,-1]),r=ie(r,[-1,1]),[Gt(ur([o,1],s.dtype),s),Gt(r,ur([1,i],r.dtype))]):(s=ie(s,[-1,1]),r=ie(r,[1,-1]),[Gt(s,ur([1,o],s.dtype)),Gt(ur([i,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UH(n,e){let t=H(n,"a","minimum"),s=H(e,"b","minimum");[t,s]=Rn(t,s),t.dtype==="bool"&&(t=rt(t,"int32"),s=rt(s,"int32")),Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(Fd,r)}const ll=J({minimum_:UH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GH(n,e,t){W(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=H(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");W(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let l=0;l<s.rank;l++)W(e[l].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),W(e[l][0]>=0&&e[l][0]<=s.shape[l]-r&&e[l][1]>=0&&e[l][1]<=s.shape[l]-r,()=>`Padding in dimension ${l} cannot be greater than or equal to ${s.shape[l]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},o={x:s};return se.runKernel(lm,o,i)}const DC=J({mirrorPad_:GH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qH(n,e){let t=H(n,"a","mod"),s=H(e,"b","mod");[t,s]=Rn(t,s);const r={a:t,b:s};return se.runKernel(zd,r)}const EC=J({mod_:qH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KH(n,e=null,t=!1){n=H(n,"x","moments");const s=Bt(e,n.shape),r=On(n,s,t);let i=r.shape;t||(i=Fn(r.shape,s));const o=pn(ut(rt(n,"float32"),ie(r,i))),l=On(o,s,t);return{mean:r,variance:l}}const Wm=J({moments_:KH});function jH(n,e,t,s){const r=H(e,"data","multiRNNCell"),i=Gp(t,"c","multiRNNCell"),o=Gp(s,"h","multiRNNCell");let l=r;const u=[];for(let f=0;f<n.length;f++){const m=n[f](l,i[f],o[f]);u.push(m[0]),u.push(m[1]),l=m[1]}const d=[],h=[];for(let f=0;f<u.length;f+=2)d.push(u[f]),h.push(u[f+1]);return[d,h]}const YH=J({multiRNNCell_:jH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XH(n,e,t,s=!1){const r=H(n,"logits","multinomial"),i=r.size,o=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const u={logits:o===1?ie(r,[1,-1]):r},d={numSamples:e,seed:t,normalized:s},h=se.runKernel(Xy,u,d);return o===1?ie(h,[h.size]):h}const ZH=J({multinomial_:XH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QH(n,e){let t=H(n,"a","notEqual","string_or_numeric"),s=H(e,"b","notEqual","string_or_numeric");[t,s]=Rn(t,s),Lt(t.shape,s.shape);const r={a:t,b:s};return se.runKernel(cm,r)}const bu=J({notEqual_:QH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JH(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:H(n,"indices","oneHot","int32")},l={dtype:r,depth:e,onValue:t,offValue:s};return se.runKernel(hm,o,l)}const B2=J({oneHot_:JH});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8(n){const t={x:H(n,"x","onesLike")};return se.runKernel(dm,t)}const kr=J({onesLike_:e8});function t8(n,e){const t=H(n,"v1","outerProduct"),s=H(e,"v2","outerProduct");W(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=ie(t,[-1,1]),i=ie(s,[1,-1]);return Gt(r,i)}const n8=J({outerProduct_:t8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8(n,e,t=0){const s=H(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return se.runKernel(fm,i,r)}const ho=J({pad_:s8});function r8(n,e,t=0){return W(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),ho(n,[e],t)}const i8=J({pad1d_:r8});function a8(n,e,t=0){return W(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(n,e,t)}const o8=J({pad2d_:a8});function l8(n,e,t=0){return W(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(n,e,t)}const u8=J({pad3d_:l8});function c8(n,e,t=0){return W(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(n,e,t)}const d8=J({pad4d_:c8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(n,e,t){const s=H(n,"x","spaceToBatchND");W(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),W(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),W(s.shape.reduce((o,l,u)=>u>0&&u<=e.length?o&&(l+t[u-1][0]+t[u-1][1])%e[u-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return se.runKernel(Tm,r,i)}const Bm=J({spaceToBatchND_:h8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p8(n,e,t,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const l=H(n,"x","maxPool");let u=l,d=!1;l.rank===3&&(d=!0,u=ie(l,[1,l.shape[0],l.shape[1],l.shape[2]])),W(bs(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const h=ei(u.shape,e,i,r,s),f=[h.dilationHeight,h.dilationWidth];let m;s==="same"?m=m8([h.filterHeight,h.filterWidth],f):m=[[0,0],[0,0]];const I=f[0]===1&&f[1]===1,[y,N]=f8([h.inHeight,h.inWidth],f,m),w=I?s:"valid",T=I?u:Bm(u,f,y),E=(t==="avg"?()=>Cm(T,e,i,w,o):()=>Mm(T,e,i,w,o))(),_=I?E:Lm(E,f,N);return d?ie(_,[_.shape[1],_.shape[2],_.shape[3]]):_}function f8(n,e,t){const s=t.map(h=>h[0]),r=t.map(h=>h[1]),i=n.concat(s,r),o=e.map((h,f)=>(h-i[f]%h)%h),l=r.map((h,f)=>h+o[f]),u=e.map((h,f)=>[s[f],l[f]]),d=e.map((h,f)=>[0,o[f]]);return[u,d]}function m8(n,e){const s=n.map((o,l)=>o+(o-1)*(e[l]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,l)=>o-r[l]);return s.map((o,l)=>[r[l],i[l]])}const kC=J({pool_:p8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g8(n,e){const t=H(n,"x","prelu"),s=H(e,"alpha","prelu"),r={x:t,alpha:s};return se.runKernel(mm,r)}const Hm=J({prelu_:g8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I8(n,e=null,t=!1){let s=H(n,"x","prod");s.dtype==="bool"&&(s=rt(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return se.runKernel(gm,r,i)}const CC=J({prod_:I8});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y8(n,e,t,s){const r=n.map((h,f)=>H(h,`tensors${f}`,"raggedGather","int32")),i=H(e,"paramsDenseValues","raggedGather"),o=H(t,"indices","raggedGather","int32"),l={paramsNestedSplits:r,paramsDenseValues:i,indices:o},u={outputRaggedRank:s},d=se.runKernel(e2,l,u);return{outputNestedSplits:d.slice(0,d.length-1),outputDenseValues:d[d.length-1]}}const b8=J({raggedGather_:y8});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x8(n,e,t){const s=H(n,"starts","raggedRange"),r=H(e,"limits","raggedRange",s.dtype),i=H(t,"deltas","raggedRange",s.dtype),o={starts:s,limits:r,deltas:i},l=se.runKernel(t2,o);return{rtNestedSplits:l[0],rtDenseValues:l[1]}}const N8=J({raggedRange_:x8});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w8(n,e,t,s,r){const i=H(n,"shape","raggedTensorToTensor","int32"),o=H(e,"values","raggedTensorToTensor"),l=H(t,"defaultValue","raggedTensorToTensor",o.dtype),u=s.map((f,m)=>H(f,`tensors${m}`,"raggedTensorToTensor","int32")),d={shape:i,values:o,defaultValue:l,rowPartitionTensors:u},h={rowPartitionTypes:r};return se.runKernel(n2,d,h)}const A8=J({raggedTensorToTensor_:w8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T8(n,e,t){Cr(n);const s=Te(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<s;i++)r[i]=e();return se.makeTensor(r,n,t)}const S8=J({rand_:T8});var H2={exports:{}};H2.exports;(function(n){(function(e,t,s){function r(u){var d=this,h=l();d.next=function(){var f=2091639*d.s0+d.c*23283064365386963e-26;return d.s0=d.s1,d.s1=d.s2,d.s2=f-(d.c=f|0)},d.c=1,d.s0=h(" "),d.s1=h(" "),d.s2=h(" "),d.s0-=h(u),d.s0<0&&(d.s0+=1),d.s1-=h(u),d.s1<0&&(d.s1+=1),d.s2-=h(u),d.s2<0&&(d.s2+=1),h=null}function i(u,d){return d.c=u.c,d.s0=u.s0,d.s1=u.s1,d.s2=u.s2,d}function o(u,d){var h=new r(u),f=d&&d.state,m=h.next;return m.int32=function(){return h.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,f&&(typeof f=="object"&&i(f,h),m.state=function(){return i(h,{})}),m}function l(){var u=4022871197,d=function(h){h=String(h);for(var f=0;f<h.length;f++){u+=h.charCodeAt(f);var m=.02519603282416938*u;u=m>>>0,m-=u,m*=u,u=m>>>0,m-=u,u+=m*4294967296}return(u>>>0)*23283064365386963e-26};return d}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(yl,n,!1)})(H2);var v8=H2.exports,U2={exports:{}};U2.exports;(function(n){(function(e,t,s){function r(l){var u=this,d="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var f=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^f^f>>>8},l===(l|0)?u.x=l:d+=l;for(var h=0;h<d.length+64;h++)u.x^=d.charCodeAt(h)|0,u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var d=new r(l),h=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,I=(d.next()>>>0)/4294967296,y=(m+I)/(1<<21);while(y===0);return y},f.int32=d.next,f.quick=f,h&&(typeof h=="object"&&i(h,d),f.state=function(){return i(d,{})}),f}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(yl,n,!1)})(U2);var $8=U2.exports,G2={exports:{}};G2.exports;(function(n){(function(e,t,s){function r(l){var u=this,d="";u.next=function(){var f=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(f^f<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:d+=l;for(var h=0;h<d.length+64;h++)u.x^=d.charCodeAt(h)|0,h==d.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var d=new r(l),h=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,I=(d.next()>>>0)/4294967296,y=(m+I)/(1<<21);while(y===0);return y},f.int32=d.next,f.quick=f,h&&(typeof h=="object"&&i(h,d),f.state=function(){return i(d,{})}),f}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(yl,n,!1)})(G2);var _8=G2.exports,q2={exports:{}};q2.exports;(function(n){(function(e,t,s){function r(l){var u=this;u.next=function(){var h=u.x,f=u.i,m,I;return m=h[f],m^=m>>>7,I=m^m<<24,m=h[f+1&7],I^=m^m>>>10,m=h[f+3&7],I^=m^m>>>3,m=h[f+4&7],I^=m^m<<7,m=h[f+7&7],m=m^m<<13,I^=m^m<<9,h[f]=I,u.i=f+1&7,I};function d(h,f){var m,I=[];if(f===(f|0))I[0]=f;else for(f=""+f,m=0;m<f.length;++m)I[m&7]=I[m&7]<<15^f.charCodeAt(m)+I[m+1&7]<<13;for(;I.length<8;)I.push(0);for(m=0;m<8&&I[m]===0;++m);for(m==8?I[7]=-1:I[m],h.x=I,h.i=0,m=256;m>0;--m)h.next()}d(u,l)}function i(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var d=new r(l),h=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,I=(d.next()>>>0)/4294967296,y=(m+I)/(1<<21);while(y===0);return y},f.int32=d.next,f.quick=f,h&&(h.x&&i(h,d),f.state=function(){return i(d,{})}),f}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(yl,n,!1)})(q2);var D8=q2.exports,K2={exports:{}};K2.exports;(function(n){(function(e,t,s){function r(l){var u=this;u.next=function(){var h=u.w,f=u.X,m=u.i,I,y;return u.w=h=h+1640531527|0,y=f[m+34&127],I=f[m=m+1&127],y^=y<<13,I^=I<<17,y^=y>>>15,I^=I>>>12,y=f[m]=y^I,u.i=m,y+(h^h>>>16)|0};function d(h,f){var m,I,y,N,w,T=[],v=128;for(f===(f|0)?(I=f,f=null):(f=f+"\0",I=0,v=Math.max(v,f.length)),y=0,N=-32;N<v;++N)f&&(I^=f.charCodeAt((N+32)%f.length)),N===0&&(w=I),I^=I<<10,I^=I>>>15,I^=I<<4,I^=I>>>13,N>=0&&(w=w+1640531527|0,m=T[N&127]^=I+w,y=m==0?y+1:0);for(y>=128&&(T[(f&&f.length||0)&127]=-1),y=127,N=4*128;N>0;--N)I=T[y+34&127],m=T[y=y+1&127],I^=I<<13,m^=m<<17,I^=I>>>15,m^=m>>>12,T[y]=I^m;h.w=w,h.X=T,h.i=y}d(u,l)}function i(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var d=new r(l),h=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,I=(d.next()>>>0)/4294967296,y=(m+I)/(1<<21);while(y===0);return y},f.int32=d.next,f.quick=f,h&&(h.X&&i(h,d),f.state=function(){return i(d,{})}),f}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(yl,n,!1)})(K2);var E8=K2.exports,j2={exports:{}};j2.exports;(function(n){(function(e,t,s){function r(l){var u=this,d="";u.next=function(){var f=u.b,m=u.c,I=u.d,y=u.a;return f=f<<25^f>>>7^m,m=m-I|0,I=I<<24^I>>>8^y,y=y-f|0,u.b=f=f<<20^f>>>12^m,u.c=m=m-I|0,u.d=I<<16^m>>>16^y,u.a=y-f|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):d+=l;for(var h=0;h<d.length+20;h++)u.b^=d.charCodeAt(h)|0,u.next()}function i(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var d=new r(l),h=u&&u.state,f=function(){return(d.next()>>>0)/4294967296};return f.double=function(){do var m=d.next()>>>11,I=(d.next()>>>0)/4294967296,y=(m+I)/(1<<21);while(y===0);return y},f.int32=d.next,f.quick=f,h&&(typeof h=="object"&&i(h,d),f.state=function(){return i(d,{})}),f}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(yl,n,!1)})(j2);var k8=j2.exports,LC={exports:{}};const C8={},L8=Object.freeze(Object.defineProperty({__proto__:null,default:C8},Symbol.toStringTag,{value:"Module"})),O8=Qz(L8);(function(n){(function(e,t,s){var r=256,i=6,o=52,l="random",u=s.pow(r,i),d=s.pow(2,o),h=d*2,f=r-1,m;function I(_,L,P){var B=[];L=L==!0?{entropy:!0}:L||{};var U=T(w(L.entropy?[_,E(t)]:_??v(),3),B),Z=new y(B),Y=function(){for(var ae=Z.g(i),de=u,ce=0;ae<d;)ae=(ae+ce)*r,de*=r,ce=Z.g(1);for(;ae>=h;)ae/=2,de/=2,ce>>>=1;return(ae+ce)/de};return Y.int32=function(){return Z.g(4)|0},Y.quick=function(){return Z.g(4)/4294967296},Y.double=Y,T(E(Z.S),t),(L.pass||P||function(ae,de,ce,Ie){return Ie&&(Ie.S&&N(Ie,Z),ae.state=function(){return N(Z,{})}),ce?(s[l]=ae,de):ae})(Y,U,"global"in L?L.global:this==s,L.state)}function y(_){var L,P=_.length,B=this,U=0,Z=B.i=B.j=0,Y=B.S=[];for(P||(_=[P++]);U<r;)Y[U]=U++;for(U=0;U<r;U++)Y[U]=Y[Z=f&Z+_[U%P]+(L=Y[U])],Y[Z]=L;(B.g=function(ae){for(var de,ce=0,Ie=B.i,be=B.j,ye=B.S;ae--;)de=ye[Ie=f&Ie+1],ce=ce*r+ye[f&(ye[Ie]=ye[be=f&be+de])+(ye[be]=de)];return B.i=Ie,B.j=be,ce})(r)}function N(_,L){return L.i=_.i,L.j=_.j,L.S=_.S.slice(),L}function w(_,L){var P=[],B=typeof _,U;if(L&&B=="object")for(U in _)try{P.push(w(_[U],L-1))}catch{}return P.length?P:B=="string"?_:_+"\0"}function T(_,L){for(var P=_+"",B,U=0;U<P.length;)L[f&U]=f&(B^=L[f&U]*19)+P.charCodeAt(U++);return E(L)}function v(){try{var _;return m&&(_=m.randomBytes)?_=_(r):(_=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(_)),E(_)}catch{var L=e.navigator,P=L&&L.plugins;return[+new Date,e,P,e.screen,E(t)]}}function E(_){return String.fromCharCode.apply(0,_)}if(T(s.random(),t),n.exports){n.exports=I;try{m=O8}catch{}}else s["seed"+l]=I})(typeof self<"u"?self:yl,[],Math)})(LC);var R8=LC.exports,V8=v8,P8=$8,F8=_8,z8=D8,M8=E8,W8=k8,wl=R8;wl.alea=V8;wl.xor128=P8;wl.xorwow=F8;wl.xorshift7=z8;wl.xor4096=M8;wl.tychei=W8;var Um=wl;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y2{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Um.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const l=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*l,t=this.mean+this.stdDev*i*l,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class B8{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const i=r||Math.random();this.randu=Um.alea(i.toString()),this.randn=new Y2(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,i,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-o+Math.log(o)),i=this.randu(),i<t||Math.log(i)<s)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class H8{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Um.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U8(n,e,t=1,s="float32",r){if(Cr(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const i=new B8(e,t,s,r),o=zt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const G8=J({randomGamma_:U8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q8(n,e=0,t=1,s,r){if(Cr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new Y2(e,t,s,!1,r),o=zt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const X2=J({randomNormal_:q8});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K8(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return X2(n,0,1,e,t)}const j8=J({randomStandardNormal_:K8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y8(n,e=0,t=1,s="float32",r){Cr(n);const i=zt(n,s),o=new H8(e,t,null,r);for(let l=0;l<i.values.length;l++)i.values[l]=o.nextValue();return i.toTensor()}const Al=J({randomUniform_:Y8});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X8(n,e,t,s){return Al(n,e,t,"int32",s)}const Z8=J({randomUniformInt_:X8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xu(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return se.runKernel(s2,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q8(n){const t={input:H(n,"input","real")};return se.runKernel(r2,t)}const jc=J({real_:Q8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J8(n){const t={x:H(n,"x","reciprocal")};return se.runKernel(Bd,t)}const OC=J({reciprocal_:J8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eU(n){const t={x:H(n,"x","relu")};return se.runKernel(Hd,t)}const Xi=J({relu_:eU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(n){const t={x:H(n,"x","relu6")};return se.runKernel(Ud,t)}const Z2=J({relu6_:tU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nU(n,e){const s={x:H(n,"x","reverse")},r={dims:e};return se.runKernel(xm,s,r)}const Qr=J({reverse_:nU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sU(n){const e=H(n,"x","reverse");return W(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Qr(e,0)}const rU=J({reverse1d_:sU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iU(n,e){const t=H(n,"x","reverse");return W(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Qr(t,e)}const aU=J({reverse2d_:iU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oU(n,e){const t=H(n,"x","reverse");return W(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Qr(t,e)}const lU=J({reverse3d_:oU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uU(n,e){const t=H(n,"x","reverse");return W(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Qr(t,e)}const cU=J({reverse4d_:uU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(n){const t={x:H(n,"x","round")};return se.runKernel(Gd,t)}const Q2=J({round_:dU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hU(n){const t={x:H(n,"x","rsqrt","float32")};return se.runKernel(qd,t)}const J2=J({rsqrt_:hU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pU(n){const t={x:H(n,"x","selu")};return se.runKernel(Kd,t)}const eb=J({selu_:pU});function fU(n,e,t,s,r,i=[1,1],o="NHWC"){const l=H(n,"x","separableConv2d"),u=H(e,"depthwiseFilter","separableConv2d"),d=H(t,"pointwiseFilter","separableConv2d");let h=l,f=!1;if(l.rank===3&&(f=!0,h=ie(l,[1,l.shape[0],l.shape[1],l.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");W(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),W(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),W(d.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),W(d.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${d.shape[0]}.`),W(d.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${d.shape[1]}.`);const m=u.shape[2],I=u.shape[3];W(d.shape[2]===m*I,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*I}, but got ${d.shape[2]}.`);const y=uh(h,u,s,r,o,i),w=Ya(y,d,1,"valid",o);return f?ie(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const tb=J({separableConv2d_:fU});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function mU(n,e){const t=H(n,"x","setdiff1d"),s=H(e,"y","setdiff1d");W(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),W(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),W(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),i=await s.data(),o=new Set(i);let l=0;for(let h=0;h<r.length;h++)o.has(r[h])||l++;const u=new Yn([l],t.dtype),d=new Yn([l],"int32");for(let h=0,f=0;h<r.length;h++)o.has(r[h])||(u.values[f]=r[h],d.values[f]=h,f++);return[u.toTensor(),d.toTensor()]}const gU=mU;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IU(n){const t={x:H(n,"x","sign")};return se.runKernel(Xd,t)}const RC=J({sign_:IU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yU(n){const t={x:H(n,"x","sin","float32")};return se.runKernel(jd,t)}const nb=J({sin_:yU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bU(n){const t={x:H(n,"x","sinh")};return se.runKernel(Yd,t)}const sb=J({sinh_:bU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xU(n,e,t){const s=H(n,"x","slice1d");return W(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Yt(s,[e],[t])}const Gm=J({slice1d_:xU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NU(n,e,t){const s=H(n,"x","slice2d");return W(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Yt(s,e,t)}const rb=J({slice2d_:NU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wU(n,e,t){const s=H(n,"x","slice3d");return W(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Yt(s,e,t)}const qm=J({slice3d_:wU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AU(n,e,t){const s=H(n,"x","slice4d");return W(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Yt(s,e,t)}const Yc=J({slice4d_:AU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TU(n,e=-1){const t=H(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return se.runKernel(vm,s,r)}const Km=J({softmax_:TU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SU(n){W(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return se.runKernel(zy,e)}const jm=J({fft_:SU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(n){W(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return se.runKernel(Hy,e)}const Xc=J({ifft_:vU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $U(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=ie(n,[t,e]);s=Xc(r)}else{const r=[t,2*(e-1)],i=ie(jc(n),[t,e]),o=ie(Rm(n),[t,e]),l=Qr(Yt(i,[0,1],[t,e-2]),1),u=ne(Qr(Yt(o,[0,1],[t,e-2]),1),At(-1)),d=Un([i,l],1),h=Un([o,u],1),f=ie(qa(d,h),[r[0],r[1]]);s=Xc(f)}if(s=jc(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=ie(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const ib=J({irfft_:$U});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _U(n,e,t=0){const r={x:H(n,"x","split")},i={numOrSizeSplits:e,axis:t};return se.runKernel(Sm,r,i)}const cr=J({split_:_U});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(n,e){W(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const y=n.shape.map(w=>0),N=n.shape.map(w=>w);N[n.shape.length-1]=e,r=Yt(n,y,N),t=e}else if(e!=null&&e>t){const y=n.shape.map(N=>N);y[n.shape.length-1]=e-t,r=Un([n,qn(y)],n.shape.length-1),t=e}else r=n;const i=Zt(r),o=ie(qa(r,i),[s,t]),l=jm(o),u=Math.floor(t/2)+1,d=jc(l),h=Rm(l),f=cr(d,[u,t-u],d.shape.length-1),m=cr(h,[u,t-u],h.shape.length-1),I=r.shape.slice();return I[r.shape.length-1]=u,ie(qa(f[0],m[0]),I)}const Ym=J({rfft_:DU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EU(n,e){let t=H(n,"a","squaredDifference"),s=H(e,"b","squaredDifference");[t,s]=Rn(t,s),Lt(t.shape,s.shape);const r={a:t,b:s},i={};return se.runKernel(eh,r,i)}const ab=J({squaredDifference_:EU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kU(n,e){const t=H(n,"x","squeeze","string_or_numeric");return ie(t,ro(t.shape,e).newShape)}const Tl=J({squeeze_:kU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CU(n,e=0){const t=Gp(n,"tensors","stack","string_or_numeric");W(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&W(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return se.runKernel(pm,s,r)}const fr=J({stack_:CU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LU(n,e=0){const s={x:H(n,"x","step")},r={alpha:e};return se.runKernel(ih,s,r)}const Vu=J({step_:LU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OU(n,e,t,s,r=0,i=0,o=0,l=0,u=0){const h={x:H(n,"x","stridedSlice","string_or_numeric")},f={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:u};return se.runKernel(g2,h,f)}const VC=J({stridedSlice_:OU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RU(n){const t={x:H(n,"x","tan","float32")};return se.runKernel(nh,t)}const PC=J({tan_:RU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ms(n,e){Eu(n);const t=ao(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return oo(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lc(n,e,t){if(Eu(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=ao(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return oo(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VU(n,e,t){if(Eu(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=ao(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return oo(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PU(n,e,t){if(Eu(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=ao(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return oo(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FU(n,e,t){if(Eu(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=ao(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return oo(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zU(n,e,t){if(Eu(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=ao(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,oo(n,e,s,t)}function FC(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function ob(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}FC(t,e,n)}function Sl(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let o=1;for(let f=r;f<i;++f)o*=t[f];const l=r<1?1:r,u=Te(e.shape)/l,d=[...wt(t.slice(0,r)),1],h=Te(t);return{sliceRank:r,numUpdates:u,sliceSize:o,strides:d,outputSize:h}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MU(n,e,t){const s=H(n,"tensor","tensorScatterupdate"),r=H(e,"indices","tensorScatterupdate","int32"),i=H(t,"updates","tensorScatterupdate");if(ob(i,r,s.shape),s.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${i.dtype}.`);const o={tensor:s,indices:r,updates:i},l={};return se.runKernel(l2,o,l)}const WU=J({tensorScatterUpdate_:MU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BU(n,e=1,t=!0){const s=H(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},o={k:e,sorted:t},[l,u]=se.runKernel(x2,i,o);return{values:l,indices:u}}const zC=J({topk_:BU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HU(n,e=0,t=1,s,r){if(Cr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new Y2(e,t,s,!0,r),o=zt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const lb=J({truncatedNormal_:HU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UU(n,e=0){const t=H(n,"x","unique","string_or_numeric");W(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,o]=se.runKernel(w2,s,r);return{values:i,indices:o}}const MC=J({unique_:UU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GU(n,e,t){const s=H(n,"x","unsortedSegmentSum"),r=H(e,"segmentIds","unsortedSegmentSum","int32");W(fu(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:t};return se.runKernel(Dm,i,o)}const ub=J({unsortedSegmentSum_:GU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qU(n,e=0){const t=H(n,"x","unstack","string_or_numeric");W(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return se.runKernel(_m,s,r)}const Jr=J({unstack_:qU});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KU(n,e){return W2(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(n,e=!0,t,s){return se.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cb(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=zt(n,"int32"),r=zt([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=s.indexToLoc(t[i]),l=i*n.length;r.values.set(o,l)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function jU(n){const e=H(n,"condition","whereAsync","bool"),t=await e.data(),s=cb(e.shape,t);return n!==e&&e.dispose(),s}const BC=jU;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function YU(n,e,t){const s=H(n,"tensor","boolMask"),r=H(e,"mask","boolMask","bool"),i=t??0,o=r.rank,l=s.shape;W(o>0,()=>"mask cannot be scalar"),yr(l.slice(i,i+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let N=i;N<i+o;N++)u*=l[N];const d=l.slice(0,i).concat([u],l.slice(i+o)),h=ie(s,d),f=ie(r,[-1]),m=await BC(f),I=Tl(m,[1]),y=ph(h,I,i);return n!==s&&s.dispose(),e!==r&&r.dispose(),I.dispose(),h.dispose(),f.dispose(),m.dispose(),y}const XU=YU;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(n,e,t){const s=H(n,"x","transpose");if(e==null&&(e=s.shape.map((o,l)=>l).reverse()),W(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{W(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?pe(()=>{let o=jc(s),l=Rm(s);return o=se.runKernel(au,{x:o},i),l=se.runKernel(au,{x:l},i),t&&(l=wn(l)),qa(o,l)}):se.runKernel(au,r,i)}const Xt=J({transpose_:ZU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QU(n,e,t,s,r=!0){const i=H(n,"v","movingAverage"),o=H(e,"x","movingAverage"),l=H(t,"decay","movingAverage");MM(i,o),W(Kt(i.shape,o.shape),()=>"Shape mismatch in v and x");const u=At(1),d=ut(u,l);let h=ne(ut(o,i),d);if(r){W(s!=null,()=>"When using zeroDebias: true, step is required.");const f=H(s,"step","movingAverage");h=bt(h,ut(u,fa(l,f)))}return Me(i,h)}const JU=J({movingAverage_:QU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7(n,e,t){Cr(t);const s=H(n,"indices","scatterND","int32"),r=H(e,"updates","scatterND");ob(r,s,t);const i={indices:s,updates:r},o={shape:t};return se.runKernel(o2,i,o)}const t7=J({scatterND_:e7});function n7(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s7(n,e,t,s=0){Cr(t);const r=H(n,"sparseIndices","sparseToDense","int32"),i=H(e,"sparseValues","sparseToDense","string_or_numeric"),o=H(s,"defaultValue","sparseToDense",i.dtype);n7(r,i,t,o);const l={sparseIndices:r,sparseValues:i,defaultValue:o},u={outputShape:t};return se.runKernel(f2,l,u)}const r7=J({sparseToDense_:s7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(n,e){const t=H(e,"indices","gatherND","int32"),r={params:H(n,"x","gatherND","string_or_numeric"),indices:t};return se.runKernel(By,r)}const a7=J({gatherND_:i7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o7(n,e){if(e==null)return n.shape.slice();if(Kt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(n,e,t,s){const r=H(n,"x","dropout");if(W(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),W(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof $n?r.clone():r;const i=o7(r,t),o=1-e,l=bt(hh(Me(Al(i,0,1,"float32",s),o)),o);return ne(r,l)}const HC=J({dropout_:l7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UC(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function db(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+s-1);r[i]=e-t*Math.cos(o)}return Ms(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function u7(n,e,t=1){const s=H(n,"predictions","inTopK"),r=H(e,"targets","inTopK");W(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),W(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),yr(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];W(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const o=await s.data(),l=await r.data(),[u,d]=[o.length/i,i],h=Is("bool",u);for(let f=0;f<u;f++){const m=f*d,I=o.subarray(m,m+d),y=[];for(let N=0;N<I.length;N++)y.push({value:I[N],index:N});y.sort((N,w)=>w.value-N.value),h[f]=0;for(let N=0;N<t;N++)if(y[N].index===l[f]){h[f]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),Dr(h,r.shape,"bool")}const c7=u7;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d7(n,e,t,s,r,i="NHWC",o){let l=n;n.rank===3&&(l=ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]])),W(l.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`),W(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),W(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const d=i==="NHWC"?l.shape[3]:l.shape[1],h=i==="NHWC"?u.shape[3]:u.shape[1];W(d===t[2],()=>`Error in conv2dDerFilter: depth of input ${d}) must match input depth in filter (${t[2]}.`),W(h===t[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${t[3]}).`),Bs("conv2dDerFilter",r,o);const f={x:l,dy:u},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:t};return se.runKernel($y,f,m)}const hb=J({conv2DBackpropFilter_:d7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xm(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ne(n,Vu(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Zm(n,e){let t=e;const s=Jn(n.shape,e.shape);return s.length>0&&(t=ft(t,s)),ie(t,n.shape)}function Qm(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Xi(n);if(e==="elu")return ch(n);if(e==="relu6")return Z2(n);if(e==="prelu")return Hm(n,t);if(e==="leakyrelu")return Vm(n,s);if(e==="sigmoid")return Wi(n);throw new Error(`Unknown fused activation ${e}.`)}const Jm=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h7({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:h}){if(u=u||"linear",Jm(se.state.gradientDepth,u)===!1){W(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let P=Ya(n,e,t,s,r,i,o);return l!=null&&(P=Me(P,l)),Qm(P,u,d,h)}const f=H(n,"x","conv2d","float32"),m=H(e,"filter","conv2d","float32");let I=f,y=!1;f.rank===3&&(y=!0,I=ie(f,[1,f.shape[0],f.shape[1],f.shape[2]])),W(I.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${I.rank}.`),W(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Bs("fused conv2d",s,o);const N=r==="NHWC"?I.shape[3]:I.shape[1];W(m.shape[2]===N,()=>`Error in conv2d: depth of input (${N}) must match input depth for filter ${m.shape[2]}.`),W(bs(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const w=ls(I.shape,m.shape,t,i,s,o);let T;l!=null&&(T=H(l,"bias","fused conv2d"),[T]=Rn(T,f),r==="NHWC"?Lt(w.outShape,T.shape):(W(T.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${T.shape.length}.`),W(T.shape.length===0||T.shape[0]===w.outChannels||T.shape[0]===1,()=>`Error in fused conv2d: bias shape (${T.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let v;if(d!=null){const P=d.shape;if(W(P.length<=1||P.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${P.length}.`),P.length===1)W(P[0]===1||P[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${P}) is not compatible with the number of output channels (${w.outChannels}).`);else if(P.length===3)try{Lt(P,w.outShape)}catch{const U=`Error in fused conv2d: PReLU activation weights (${P}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(U)}v=H(d,"prelu weights","fused conv2d")}const E=(P,B)=>{W(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[U,Z,Y,ae]=B,de=Xm(P,Y,u);W(ja(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const ce=C2(Z.shape,de,U,t,s),Ie=hb(Z,de,U.shape,t,s),be=[ce,Ie];if(ae!=null){const ye=Zm(ae,de);be.push(ye)}return be},_={x:I,filter:m,bias:T,preluActivationWeights:v},L={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:h};return l==null?ma((B,U,Z)=>{let Y=se.runKernel(Mp,_,L);return Z([U,B,Y]),y&&(Y=ie(Y,[Y.shape[1],Y.shape[2],Y.shape[3]])),{value:Y,gradFunc:E}})(I,m):ma((B,U,Z,Y)=>{let ae=se.runKernel(Mp,_,L);return Y([U,B,ae,Z]),y&&(ae=ie(ae,[ae.shape[1],ae.shape[2],ae.shape[3]])),{value:ae,gradFunc:E}})(I,m,T)}const GC=J({fusedConv2d_:h7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p7(n,e,t,s,r,i=[1,1],o){let l=n;n.rank===3&&(l=ie(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const d={x:l,dy:u},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:t};return se.runKernel(Oy,d,h)}const qC=J({depthwiseConv2dNativeBackpropFilter_:p7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f7(n,e,t,s,r,i=[1,1],o){let l=e,u=!1;e.rank===3&&(u=!0,l=ie(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const d={dy:l,filter:t},h={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},f=se.runKernel(Ry,d,h);return u?ie(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const KC=J({depthwiseConv2dNativeBackpropInput_:f7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m7({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:h}){if(Jm(se.state.gradientDepth,u)===!1){let L=uh(n,e,t,s,r,i,o);return l!=null&&(L=Me(L,l)),Qm(L,u,d,h)}const f=H(n,"x","depthwiseConv2d","float32"),m=H(e,"filter","depthwiseConv2d","float32");let I=f,y=!1;f.rank===3&&(y=!0,I=ie(f,[1,f.shape[0],f.shape[1],f.shape[2]])),W(I.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${I.rank}.`),W(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),W(I.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${I.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),i==null&&(i=[1,1]),W(bs(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Bs("fused depthwiseConv2d",s,o);const N=ls(I.shape,m.shape,t,i,s,o,!0);let w;l!=null&&(w=H(l,"bias","fused conv2d"),[w]=Rn(w,f),Lt(N.outShape,w.shape));let T;d!=null&&(T=H(d,"prelu weights","fused depthwiseConv2d"));const v=(L,P)=>{W(ja(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[B,U,Z,Y]=P,ae=Xm(L,Z,u),de=KC(U.shape,ae,B,t,s,i,o),ce=qC(U,ae,B.shape,t,s,i,o);if(Y!=null){const Ie=Zm(w,ae);return[de,ce,Ie]}return[de,ce]},E={x:I,filter:m,bias:w,preluActivationWeights:T},_={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:h};return l==null?ma((P,B,U)=>{let Z=se.runKernel(Wp,E,_);return U([B,P,Z]),y&&(Z=ie(Z,[Z.shape[1],Z.shape[2],Z.shape[3]])),{value:Z,gradFunc:v}})(I,m):ma((P,B,U,Z)=>{let Y=se.runKernel(Wp,E,_);return Z([B,P,Y,U]),y&&(Y=ie(Y,[Y.shape[1],Y.shape[2],Y.shape[3]])),{value:Y,gradFunc:v}})(I,m,w)}const g7=J({fusedDepthwiseConv2d_:m7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I7({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}){if(Jm(se.state.gradientDepth,i)===!1){let ae=Gt(n,e,t,s);return r!=null&&(ae=Me(ae,r)),Qm(ae,i,o,l)}let u=H(n,"a","fused matMul"),d=H(e,"b","fused matMul");[u,d]=Rn(u,d);const h=t?u.shape[u.rank-2]:u.shape[u.rank-1],f=s?d.shape[d.rank-1]:d.shape[d.rank-2],m=t?u.shape[u.rank-1]:u.shape[u.rank-2],I=s?d.shape[d.rank-2]:d.shape[d.rank-1],y=u.shape.slice(0,-2),N=d.shape.slice(0,-2),w=Te(y),T=Te(N);W(h===f,()=>`Error in fused matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${u.shape} and ${d.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=Lt(u.shape.slice(0,-2),d.shape.slice(0,-2)).concat([m,I]),_=t?ie(u,[w,h,m]):ie(u,[w,m,h]),L=s?ie(d,[T,I,f]):ie(d,[T,f,I]);let P;r!=null&&(P=H(r,"bias","fused matMul"),[P]=Rn(P,u),Lt(E,P.shape));let B;o!=null&&(B=H(o,"prelu weights","fused matMul"));const U=(ae,de)=>{const[ce,Ie,be,ye]=de,we=Xm(ie(ae,be.shape),be,i);let fe,De;if(!t&&!s?(fe=Gt(we,Ie,!1,!0),De=Gt(ce,we,!0,!1)):!t&&s?(fe=Gt(we,Ie,!1,!1),De=Gt(we,ce,!0,!1)):t&&!s?(fe=Gt(Ie,we,!1,!0),De=Gt(ce,we,!1,!1)):(fe=Gt(Ie,we,!0,!0),De=Gt(we,ce,!0,!0)),r!=null){const Pe=Zm(ye,we);return[fe,De,Pe]}else return[fe,De]},Z={a:_,b:L,bias:P,preluActivationWeights:B},Y={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:l};return r==null?ma((de,ce,Ie)=>{const be=se.runKernel(zp,Z,Y);return Ie([de,ce,be]),{value:ie(be,E),gradFunc:U}})(_,L):ma((de,ce,Ie,be)=>{const ye=se.runKernel(zp,Z,Y);return be([de,ce,ye,Ie]),{value:ie(ye,E),gradFunc:U}})(_,L,P)}const hI=J({fusedMatMul_:I7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y7=Object.freeze(Object.defineProperty({__proto__:null,conv2d:GC,depthwiseConv2d:g7,matMul:hI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(n){return db(n,.54,.46)}const x7=J({hammingWindow_:b7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7(n){return db(n,.5,.5)}const jC=J({hannWindow_:N7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w7(n,e,t,s=!1,r=0){let i=0;const o=[];for(;i+e<=n.size;)o.push(Yt(n,i,e)),i+=t;if(s)for(;i<n.size;){const l=i+e-n.size,u=Un([Yt(n,i,e-l),Ou([l],r)]);o.push(u),i+=t}return o.length===0?Lc([],[0,e]):ie(Un(o),[o.length,e])}const YC=J({frame_:w7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A7(n,e,t,s,r=jC){s==null&&(s=UC(e));const i=YC(n,e,t),o=ne(i,r(e));return Ym(o,s)}const T7=J({stft_:A7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7(n,e,t,s,r="bilinear",i=0){const o=H(n,"image","cropAndResize"),l=H(e,"boxes","cropAndResize","float32"),u=H(t,"boxInd","cropAndResize","int32"),d=l.shape[0];W(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),W(l.rank===2&&l.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${d},4] but had shape ${l.shape}.`),W(u.rank===1&&u.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] but had shape ${l.shape}.`),W(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),W(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),W(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const h={image:o,boxes:l,boxInd:u},f={method:r,extrapolationValue:i,cropSize:s};return se.runKernel(ky,h,f)}const v7=J({cropAndResize_:S7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(n){const e=H(n,"image","flipLeftRight","float32");W(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return se.runKernel(Wy,t,{})}const _7=J({flipLeftRight_:$7});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7(n){const e=H(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];W(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),W(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Ur(e,r)}const E7=J({grayscaleToRGB_:D7});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k7(n){const e=H(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];W(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),W(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=rt(e,"float32"),o=Ms([.2989,.587,.114]);let l;switch(e.rank){case 2:l=jl("ij,j->i",i,o);break;case 3:l=jl("ijk,k->ij",i,o);break;case 4:l=jl("ijkl,l->ijk",i,o);break;case 5:l=jl("ijklm,m->ijkl",i,o);break;case 6:l=jl("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return l=Ps(l,-1),rt(l,r)}const C7=J({rgbToGrayscale_:k7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7(n,e,t=0,s=.5){const r=H(n,"image","rotateWithOffset","float32");W(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:e,fillValue:t,center:s};return se.runKernel(A2,i,o)}const O7=J({rotateWithOffset_:L7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pu(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),W(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),W(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),W(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),W(e.rank===1,()=>"scores must be a 1D tensor"),W(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),W(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=H(n,"boxes","nonMaxSuppression","float32"),o=H(e,"scores","nonMaxSuppression","float32"),l=Pu(i,o,t,s,r);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return se.runKernel(Zy,{boxes:i,scores:o},u)}const V7=J({nonMaxSuppression_:R7});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P7(n,e,t){const s=F7(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function F7(n,e,t){return M7(n,e,t||z7)}function z7(n,e){return n>e?1:n<e?-1:0}function M7(n,e,t){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const l=t(e,n[i]);l>0?s=i+1:(r=i,o=!l)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pb(n,e,t,s,r){return gb(n,e,t,s,r,0)}function fb(n,e,t,s,r,i){return gb(n,e,t,s,r,0,!1,i,!0)}function mb(n,e,t,s,r,i){return gb(n,e,t,s,r,i,!0)}function gb(n,e,t,s,r,i,o=!1,l=!1,u=!1){const d=[];for(let w=0;w<e.length;w++)e[w]>r&&d.push({score:e[w],boxIndex:w,suppressBeginIndex:0});d.sort(q_);const h=i>0?-.5/i:0,f=[],m=[];for(;f.length<t&&d.length>0;){const w=d.pop(),{score:T,boxIndex:v,suppressBeginIndex:E}=w;if(T<r)break;let _=!1;for(let L=f.length-1;L>=E;--L){const P=W7(n,v,f[L]);if(P>=s){_=!0;break}if(w.score=w.score*B7(s,h,P),w.score<=r)break}w.suppressBeginIndex=f.length,_||(w.score===T?(f.push(v),m.push(w.score)):w.score>r&&P7(d,w,q_))}const I=f.length,y=t-I;l&&y>0&&(f.push(...new Array(y).fill(0)),m.push(...new Array(y).fill(0)));const N={selectedIndices:f};return o&&(N.selectedScores=m),u&&(N.validOutputs=I),N}function W7(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),l=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),d=Math.min(r[0],r[2]),h=Math.min(r[1],r[3]),f=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),I=(l-i)*(u-o),y=(f-d)*(m-h);if(I<=0||y<=0)return 0;const N=Math.max(i,d),w=Math.max(o,h),T=Math.min(l,f),v=Math.min(u,m),E=Math.max(T-N,0)*Math.max(v-w,0);return E/(I+y-E)}function B7(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function q_(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function H7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=H(n,"boxes","nonMaxSuppressionAsync"),o=H(e,"scores","nonMaxSuppressionAsync"),l=Pu(i,o,t,s,r);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const u=await Promise.all([i.data(),o.data()]),d=u[0],h=u[1],{selectedIndices:f}=pb(d,h,t,s,r);return i!==n&&i.dispose(),o!==e&&o.dispose(),Ms(f,"int32")}const U7=H7;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=H(n,"boxes","nonMaxSuppression"),l=H(e,"scores","nonMaxSuppression"),u=Pu(o,l,t,s,r,i);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const d={boxes:o,scores:l},h={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},f=se.runKernel(Jy,d,h);return{selectedIndices:f[0],selectedScores:f[1]}}const q7=J({nonMaxSuppressionWithScore_:G7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function K7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=H(n,"boxes","nonMaxSuppressionAsync"),l=H(e,"scores","nonMaxSuppressionAsync"),u=Pu(o,l,t,s,r,i);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const d=await Promise.all([o.data(),l.data()]),h=d[0],f=d[1],{selectedIndices:m,selectedScores:I}=mb(h,f,t,s,r,i);return o!==n&&o.dispose(),l!==e&&l.dispose(),{selectedIndices:Ms(m,"int32"),selectedScores:Ms(I)}}const j7=K7;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=H(n,"boxes","nonMaxSuppression"),l=H(e,"scores","nonMaxSuppression"),u=Pu(o,l,t,s,r,null),d=u.maxOutputSize,h=u.iouThreshold,f=u.scoreThreshold,m={boxes:o,scores:l},I={maxOutputSize:d,iouThreshold:h,scoreThreshold:f,padToMaxOutputSize:i},y=se.runKernel(Qy,m,I);return{selectedIndices:y[0],validOutputs:y[1]}}const X7=J({nonMaxSuppressionPadded_:Y7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Z7(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=H(n,"boxes","nonMaxSuppressionAsync"),l=H(e,"scores","nonMaxSuppressionAsync"),u=Pu(o,l,t,s,r,null),d=u.maxOutputSize,h=u.iouThreshold,f=u.scoreThreshold,[m,I]=await Promise.all([o.data(),l.data()]),{selectedIndices:y,validOutputs:N}=fb(m,I,d,h,f,i);return o!==n&&o.dispose(),l!==e&&l.dispose(),{selectedIndices:Ms(y,"int32"),validOutputs:At(N,"int32")}}const Q7=Z7;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J7(n,e,t=!1,s=!1){const r=H(n,"images","resizeBilinear");W(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),W(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),W(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=ie(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:i},u={alignCorners:t,halfPixelCenters:s,size:e},d=se.runKernel(bm,l,u);return o?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const XC=J({resizeBilinear_:J7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e9(n,e,t=!1,s=!1){const r=H(n,"images","resizeNearestNeighbor");W(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),W(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),W(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),W(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=ie(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:i},u={alignCorners:t,halfPixelCenters:s,size:e},d=se.runKernel(ym,l,u);return o?ie(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const ZC=J({resizeNearestNeighbor_:e9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t9(n,e="binary",t=!1,s=.5){const r=H(n,"image","threshold"),i=.2989,o=.587,l=.114,u=r.shape[0]*r.shape[1];let d=ne(Ms([s]),255),h,f,m,I;if(W(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),W(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),W(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),W(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[h,f,m]=cr(r,[1,1,1],-1);const w=ne(h,i),T=ne(f,o),v=ne(m,l);I=Me(Me(w,T),v)}else I=n;if(e==="otsu"){const w=iC(rt(Q2(I),"int32"),Dr([]),256);d=n9(w,u)}const y=t?Nl(I,d):xr(I,d);return rt(ne(y,255),"int32")}function n9(n,e){let t=Ms([-1]),s=Ms([0]),r=Ms([0]),i,o,l,u,d,h;for(let f=0;f<n.size-1;f++){i=Yt(n,0,f+1),o=Yt(n,f+1),d=bt(ft(i),e),h=bt(ft(o),e);const m=ft(ne(i,xu(0,i.size)));l=bt(m,ft(i));const I=Ou(o.shape,i.size),y=Me(xu(0,o.size),I),N=ne(o,y);u=bt(ft(N),ft(o));const w=ut(l,u),T=ut(l,u),v=ne(d,h);r=ne(ne(v,w),T);const E=xr(r,s);s=vs(E,r,s),t=vs(E,Ms([f]),t)}return t}const s9=J({threshold_:t9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r9(n,e,t="nearest",s="constant",r=0,i){const o=H(n,"image","transform","float32"),l=H(e,"transforms","transform","float32");W(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),W(l.rank===2&&(l.shape[0]===o.shape[0]||l.shape[0]===1)&&l.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),W(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const u={image:o,transforms:l},d={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return se.runKernel(N2,u,d)}const i9=J({transform_:r9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a9(n,e,t){const s=H(n,"a","bandPart");W(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let l,u;typeof e=="number"?(W(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),W(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),l=H(e<0?i:e,"numLower","bandPart")):(W(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),l=vs(Kc(e,0),i,ll(e,i))),typeof t=="number"?(W(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),W(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),u=H(t<0?o:t,"numUpper","bandPart")):(W(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=vs(Kc(t,0),o,ll(t,o)));const d=ie(xu(0,i,1,"int32"),[-1,1]),h=xu(0,o,1,"int32"),f=ut(d,h),m=Ki(Nl(f,l),co(f,wn(u))),I=qn([i,o],s.dtype);return ie(fr(Jr(ie(s,[-1,i,o])).map(y=>vs(m,y,I))),r)}const o9=J({bandPart_:a9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l9(n){let e;if(Array.isArray(n)){e=!1,W(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)W(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=cr(n,n.shape[0],0).map(r=>Tl(r,[0]));W(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(se.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const l=ne(ft(ne(t[o],i)),t[o]);i=ut(i,l)}return bt(i,dh(i,"euclidean"))}));return e?fr(t,0):t}const u9=J({gramSchmidt_:l9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c9(n,e=!1){if(W(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return K_(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,d)=>u*d),s=Jr(ie(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(u=>{const[d,h]=K_(u,e);r.push(d),i.push(h)});const o=ie(fr(r,0),n.shape),l=ie(fr(i,0),n.shape);return[o,l]}}function K_(n,e=!1){return se.tidy(()=>{W(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=F2(t),i=ha(n);const o=Lc([[1]],[1,1]);let l=ha(o);const u=t>=s?s:t;for(let d=0;d<u;++d){const h=i,f=l,m=r;[l,i,r]=se.tidy(()=>{const I=Yt(i,[d,d],[t-d,1]),y=dh(I),N=Yt(i,[d,d],[1,1]),w=vs(xr(N,0),Lc([[-1]]),Lc([[1]])),T=ut(N,ne(w,y)),v=bt(I,T);v.shape[0]===1?l=ha(o):l=Un([o,Yt(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const E=wn(bt(Gt(w,T),y)),_=Yt(i,[d,0],[t-d,s]),L=ne(E,l),P=Xt(l);if(d===0)i=ut(_,Gt(L,Gt(P,_)));else{const Z=ut(_,Gt(L,Gt(P,_)));i=Un([Yt(i,[0,0],[d,s]),Z],0)}const B=Xt(L),U=Yt(r,[0,d],[t,r.shape[1]-d]);if(d===0)r=ut(U,Gt(Gt(U,l),B));else{const Z=ut(U,Gt(Gt(U,l),B));r=Un([Yt(r,[0,0],[t,d]),Z],1)}return[l,i,r]}),Ft([h,f,m])}return!e&&t>s&&(r=Yt(r,[0,0],[t,s]),i=Yt(i,[0,0],[s,s])),[r,i]})}const d9=J({qr_:c9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Zs;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Zs||(Zs={}));function h9(n,e,t=Zs.SUM_BY_NONZERO_WEIGHTS){const s=H(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=H(e,"weights","computeWeightedLoss"));const i=r==null?s:ne(s,r);if(t===Zs.NONE)return i;if(t===Zs.SUM)return ft(i);if(t===Zs.MEAN){if(r==null)return On(i);{const o=s.size/r.size,l=bt(ft(i),ft(r));return o>1?bt(l,At(o)):l}}if(t===Zs.SUM_BY_NONZERO_WEIGHTS){if(r==null)return bt(ft(i),At(s.size));{const o=ne(r,ur(s.shape)),l=rt(ft(bu(o,At(0))),"float32");return bt(ft(i),l)}}throw Error(`Unknown reduction: ${t}`)}const wa=J({computeWeightedLoss_:h9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p9(n,e,t,s=Zs.SUM_BY_NONZERO_WEIGHTS){const r=H(n,"labels","absoluteDifference"),i=H(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=H(t,"weights","absoluteDifference")),yr(r.shape,i.shape,"Error in absoluteDifference: ");const l=Gn(ut(r,i));return wa(l,o,s)}const f9=J({absoluteDifference_:p9});function m9(n,e,t,s,r=Zs.SUM_BY_NONZERO_WEIGHTS){const i=H(n,"labels","cosineDistance"),o=H(e,"predictions","cosineDistance");let l=null;s!=null&&(l=H(s,"weights","cosineDistance")),yr(i.shape,o.shape,"Error in cosineDistance: ");const u=At(1),d=ut(u,ft(ne(i,o),t,!0));return wa(d,l,r)}const g9=J({cosineDistance_:m9});function I9(n,e,t,s=Zs.SUM_BY_NONZERO_WEIGHTS){let r=H(n,"labels","hingeLoss");const i=H(e,"predictions","hingeLoss");let o=null;t!=null&&(o=H(t,"weights","hingeLoss")),yr(r.shape,i.shape,"Error in hingeLoss: ");const l=At(1);r=ut(ne(At(2),r),l);const u=Xi(ut(l,ne(r,i)));return wa(u,o,s)}const y9=J({hingeLoss_:I9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b9(n,e,t,s=1,r=Zs.SUM_BY_NONZERO_WEIGHTS){const i=H(n,"labels","huberLoss"),o=H(e,"predictions","huberLoss");let l=null;t!=null&&(l=H(t,"weights","huberLoss")),yr(i.shape,o.shape,"Error in huberLoss: ");const u=At(s),d=Gn(ut(o,i)),h=ll(d,u),f=ut(d,h),m=Me(ne(At(.5),pn(h)),ne(u,f));return wa(m,l,r)}const x9=J({huberLoss_:b9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N9(n,e,t,s=1e-7,r=Zs.SUM_BY_NONZERO_WEIGHTS){const i=H(n,"labels","logLoss"),o=H(e,"predictions","logLoss");let l=null;t!=null&&(l=H(t,"weights","logLoss")),yr(i.shape,o.shape,"Error in logLoss: ");const u=At(1),d=At(s),h=wn(ne(i,Er(Me(o,d)))),f=ne(ut(u,i),Er(Me(ut(u,o),d))),m=ut(h,f);return wa(m,l,r)}const w9=J({logLoss_:N9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A9(n,e,t,s=Zs.SUM_BY_NONZERO_WEIGHTS){const r=H(n,"labels","meanSquaredError"),i=H(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=H(t,"weights","meanSquaredError")),yr(r.shape,i.shape,"Error in meanSquaredError: ");const l=ab(r,i);return wa(l,o,s)}const T9=J({meanSquaredError_:A9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S9(n,e){const t=H(n,"labels","sigmoidCrossEntropyWithLogits"),s=H(e,"logits","sigmoidCrossEntropyWithLogits");yr(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Xi(s),i=ne(s,t),o=Pm(pr(wn(Gn(s))));return Me(ut(r,i),o)}function v9(n,e,t,s=0,r=Zs.SUM_BY_NONZERO_WEIGHTS){let i=H(n,"multiClassLabels","sigmoidCrossEntropy");const o=H(e,"logits","sigmoidCrossEntropy");let l=null;if(t!=null&&(l=H(t,"weights","sigmoidCrossEntropy")),yr(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const d=At(s),h=At(1),f=At(.5);i=Me(ne(i,ut(h,d)),ne(f,d))}const u=S9(i,o);return wa(u,l,r)}const $9=J({sigmoidCrossEntropy_:v9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _9(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return ma((r,i,o)=>{const u=Fm(i,[t],!0),d=ut(rt(i,"float32"),u);o([r,d]);const h=wn(ne(d,r));return{value:ft(h,[t]),gradFunc:(I,y)=>{const[N,w]=y,T=Fn(I.shape,[t]);return[ne(ie(I,T),ut(rt(N,"float32"),pr(w))),ne(ie(I,T),ut(pr(w),rt(N,"float32")))]}}})(n,e)}function D9(n,e,t,s=0,r=Zs.SUM_BY_NONZERO_WEIGHTS){let i=H(n,"onehotLabels","softmaxCrossEntropy");const o=H(e,"logits","softmaxCrossEntropy");let l=null;if(t!=null&&(l=H(t,"weights","softmaxCrossEntropy")),yr(i.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const d=At(s),h=At(1),f=At(i.shape[1]);i=Me(ne(i,ut(h,d)),bt(d,f))}const u=_9(i,o);return wa(u,l,r)}const E9=J({softmaxCrossEntropy_:D9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9(n,e,t,s){const r=H(n,"indices","sparseFillEmptyRows","int32"),i=H(e,"values","sparseFillEmptyRows"),o=H(t,"denseShape","sparseFillEmptyRows","int32"),l=H(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(l.rank!==0)throw new Error(`Default value should be a scalar but received shape ${l.shape}`);const u={indices:r,values:i,denseShape:o,defaultValue:l},d=se.runKernel(c2,u);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}const C9=J({sparseFillEmptyRows_:k9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L9(n,e,t){const s=H(n,"inputIndices","sparseReshape","int32"),r=H(e,"inputShape","sparseReshape","int32"),i=H(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:s,inputShape:r,newShape:i},l=se.runKernel(d2,o);return{outputIndices:l[0],outputShape:l[1]}}const O9=J({sparseReshape_:L9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R9(n,e,t){const s=H(n,"data","sparseSegmentMean"),r=H(e,"indices","sparseSegmentMean","int32"),i=H(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:s,indices:r,segmentIds:i};return se.runKernel(h2,o)}const V9=J({sparseSegmentMean_:R9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P9(n,e,t){const s=H(n,"data","sparseSegmentSum"),r=H(e,"indices","sparseSegmentSum","int32"),i=H(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:s,indices:r,segmentIds:i};return se.runKernel(p2,o)}const F9=J({sparseSegmentSum_:P9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z9(n,e,t,s,r,i,o,l){const u=H(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const d=H(e,"dataSplits","stringNGrams");if(d.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:t,nGramWidths:s,leftPad:r,rightPad:i,padWidth:o,preserveShortSequences:l},f={data:u,dataSplits:d},m=se.runKernel(I2,f,h);return{nGrams:m[0],nGramsSplits:m[1]}}const M9=J({stringNGrams_:z9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W9(n,e,t=!0){const s=H(n,"input","stringSplit","string"),r=H(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:t},o={input:s,delimiter:r},l=se.runKernel(y2,o,i);return{indices:l[0],values:l[1],shape:l[2]}}const B9=J({stringSplit_:W9});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H9(n,e){const t=H(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return se.runKernel(b2,r,s)}const U9=J({stringToHashBucketFast_:H9});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G9(n,e,t,s=!0){const r=H(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:s};return se.runKernel($m,{x:r},i)}const q9=J({staticRegexReplace_:G9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K9={fft:jm,ifft:Xc,rfft:Ym,irfft:ib},j9={hammingWindow:x7,hannWindow:jC,frame:YC,stft:T7},Pi={flipLeftRight:_7,grayscaleToRGB:E7,resizeNearestNeighbor:ZC,resizeBilinear:XC,rgbToGrayscale:C7,rotateWithOffset:O7,cropAndResize:v7,nonMaxSuppression:V7,nonMaxSuppressionAsync:U7,nonMaxSuppressionWithScore:q7,nonMaxSuppressionWithScoreAsync:j7,nonMaxSuppressionPadded:X7,nonMaxSuppressionPaddedAsync:Q7,threshold:s9,transform:i9},QC={bandPart:o9,gramSchmidt:u9,qr:d9},Y9={absoluteDifference:f9,computeWeightedLoss:wa,cosineDistance:g9,hingeLoss:y9,huberLoss:x9,logLoss:w9,meanSquaredError:T9,sigmoidCrossEntropy:$9,softmaxCrossEntropy:E9},X9={sparseFillEmptyRows:C9,sparseReshape:O9,sparseSegmentMean:V9,sparseSegmentSum:F9},Z9={stringNGrams:M9,stringSplit:B9,stringToHashBucketFast:U9,staticRegexReplace:q9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q9=new Map,J9=new Map;class Fu{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Mr{constructor(){this.classNameMap={}}static getMap(){return Mr.instance==null&&(Mr.instance=new Mr),Mr.instance}static register(e){Mr.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function He(n,e,t){W(n.className!=null,()=>"Class being registered does not have the static className property defined."),W(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),W(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return Mr.register(n),Q9.set(r,n),J9.set(n,r),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class po extends Fu{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const o=s.map(l=>({name:l.name,tensor:i[l.name]}));this.applyGradients(o)}else this.applyGradients(i);return Ft(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return TH(e,t)}dispose(){this.iterations_!=null&&Ft(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:At(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(po,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JC extends po{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:pe(()=>Zt(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:pe(()=>Zt(i).variable(o))});const l=Array.isArray(e)?e[r].tensor:e[s];if(l==null)return;const u=this.accumulatedGrads[r].variable,d=this.accumulatedUpdates[r].variable;pe(()=>{const h=Me(ne(u,this.rho),ne(pn(l),1-this.rho)),f=ne(bt(ys(Me(d,this.epsilon)),ys(Me(u,this.epsilon))),l),m=Me(ne(d,this.rho),ne(pn(f),1-this.rho));u.assign(h),d.assign(m);const I=Me(ne(f,-this.learningRate),i);i.assign(I)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ft(this.accumulatedGrads.map(e=>e.variable)),Ft(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eL extends po{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:pe(()=>Ou(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedGrads[r].variable;pe(()=>{const u=Me(l,pn(o));l.assign(u);const d=Me(ne(bt(o,ys(Me(u,se.backend.epsilon()))),-this.learningRate),i);i.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ft(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tL extends po{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],pe(()=>{this.accBeta1=At(t).variable(),this.accBeta2=At(s).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);pe(()=>{const s=ut(1,this.accBeta1),r=ut(1,this.accBeta2);t.forEach((i,o)=>{const l=se.registeredVariables[i],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:pe(()=>Zt(l).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:pe(()=>Zt(l).variable(u))});const d=Array.isArray(e)?e[o].tensor:e[i];if(d==null)return;const h=this.accumulatedFirstMoment[o].variable,f=this.accumulatedSecondMoment[o].variable,m=Me(ne(h,this.beta1),ne(d,1-this.beta1)),I=Me(ne(f,this.beta2),ne(pn(d),1-this.beta2)),y=bt(m,s),N=bt(I,r);h.assign(m),f.assign(I);const w=Me(ne(bt(y,Me(ys(N),this.epsilon)),-this.learningRate),l);l.assign(w)}),this.accBeta1.assign(ne(this.accBeta1,this.beta1)),this.accBeta2.assign(ne(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ft(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ft(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),pe(()=>{this.accBeta1.assign(fa(this.beta1,this.iterations_+1)),this.accBeta2.assign(fa(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nL extends po{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],pe(()=>{this.iteration=At(0).variable(),this.accBeta1=At(t).variable()}),r==null&&(this.epsilon=se.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);pe(()=>{const s=ut(1,this.accBeta1),r=bt(-this.learningRate,Me(ne(this.iteration,this.decay),1));t.forEach((i,o)=>{const l=se.registeredVariables[i],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Zt(l).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:Zt(l).variable(u)});const d=Array.isArray(e)?e[o].tensor:e[i];if(d==null)return;const h=this.accumulatedFirstMoment[o].variable,f=this.accumulatedWeightedInfNorm[o].variable,m=Me(ne(h,this.beta1),ne(d,1-this.beta1)),I=ne(f,this.beta2),y=Gn(d),N=Na(I,y);h.assign(m),f.assign(N);const w=Me(ne(bt(r,s),bt(m,Me(N,this.epsilon))),l);l.assign(w)}),this.iteration.assign(Me(this.iteration,1)),this.accBeta1.assign(ne(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ft(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ft(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ib extends po{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=se.registeredVariables[s];pe(()=>{const l=Me(ne(this.c,i),o);o.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=is(At(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sL extends Ib{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=At(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:pe(()=>Zt(i).variable(!1))});const o=this.accumulations[r].variable,l=Array.isArray(e)?e[r].tensor:e[s];l!=null&&pe(()=>{let u;const d=Me(ne(this.m,o),l);this.useNesterov?u=Me(ne(this.c,Me(l,ne(d,this.m))),i):u=Me(ne(this.c,d),i),o.assign(d),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ft(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rL extends po{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=se.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=se.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:pe(()=>Zt(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:pe(()=>Zt(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:pe(()=>Zt(i).variable(o))});const l=Array.isArray(e)?e[r].tensor:e[s];if(l==null)return;const u=this.accumulatedMeanSquares[r].variable,d=this.accumulatedMoments[r].variable;pe(()=>{const h=Me(ne(u,this.decay),ne(pn(l),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[r].variable,m=Me(ne(f,this.decay),ne(l,1-this.decay)),I=bt(ne(l,this.learningRate),ys(ut(h,Me(pn(m),this.epsilon)))),y=Me(ne(d,this.momentum),I);u.assign(h),f.assign(m),d.assign(y);const N=ut(i,y);i.assign(N)}else{const f=Me(ne(u,this.decay),ne(pn(l),1-this.decay)),m=Me(ne(d,this.momentum),bt(ne(l,this.learningRate),ys(Me(f,this.epsilon))));u.assign(f),d.assign(m);const I=ut(i,m);i.assign(I)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ft(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ft(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ft(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eG=[JC,eL,tL,nL,sL,rL,Ib];function tG(){for(const n of eG)He(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nG="model",sG=".json",rG=".weights.bin";function j_(n){return new Promise(e=>setTimeout(e)).then(n)}class ul{constructor(e){if(!xe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ul.URL_SCHEME)&&(e=e.slice(ul.URL_SCHEME.length)),(e==null||e.length===0)&&(e=nG),this.modelJsonFileName=e+sG,this.weightDataFileName=e+rG}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Ti.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=Vk(e,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(l.download=this.modelJsonFileName,l.href=o,await j_(()=>l.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await j_(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ah(e)}}}}ul.URL_SCHEME="downloads://";class iG{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const i=JSON.parse(r.target.result),o=i.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const u=$2(i,d=>this.loadWeights(d));e(u)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const o of e)t.push(...o.weights),s.push(...o.paths);const r=this.checkManifestAndWeightFiles(e),i=s.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(i).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((s,r)=>{const i=new FileReader;i.onload=o=>{const l=o.target.result;s(l)},i.onerror=o=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(i=>G_(i.name)),r={};for(const i of e)i.paths.forEach(o=>{const l=G_(o);if(t.indexOf(l)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${l}'`);if(t.push(l),s.indexOf(l)===-1)throw new Error(`Weight file with basename '${l}' is not provided.`);r[o]=this.weightsFiles[s.indexOf(l)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const aG=n=>xe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ul.URL_SCHEME)?oG(n.slice(ul.URL_SCHEME.length)):null;vn.registerSaveRouter(aG);function oG(n="model"){return new ul(n)}function lG(n){return new iG(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_(n,e,t,s){o(n),t=t??0,s=s??1,l(t,s);let r=0;const i=u=>(u.then(d=>{const h=t+ ++r/n.length*(s-t);return e(h),d}),u);function o(u){W(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function l(u,d){W(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),W(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${d}`),W(d>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${d}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function iL(n,e){e==null&&(e={});const t=e.fetchFunc==null?xe().platform.fetch:e.fetchFunc,s=n.map(f=>t(f,e.requestInit,{isBinary:!0})),r=0,i=.5,l=(e.onProgress==null?await Promise.all(s):await Y_(s,e.onProgress,r,i)).map(f=>f.arrayBuffer()),u=.5,d=1;return e.onProgress==null?await Promise.all(l):await Y_(l,e.onProgress,u,d)}function uG(n,e){var t;const s=e.fetchFunc==null?xe().platform.fetch:e.fetchFunc;let r=0,i;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async o=>{for(var l;r<n.length;){i||(i=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:d}=await i.read();if(u){r++,i=void 0,(l=e.onProgress)===null||l===void 0||l.call(e,r/n.length);continue}o.enqueue(d);return}o.close()}})}async function cG(n,e="",t,s){return aL(o=>iL(o,{requestInit:s}))(n,e,t)}function aL(n){return async(e,t="",s)=>{const r=e.map(()=>!1),i={},o=s!=null?s.map(()=>!1):[],l=[];if(e.forEach((I,y)=>{let N=0;I.weights.forEach(w=>{const T="quantization"in w?w.quantization.dtype:w.dtype,v=sl[T]*Te(w.shape),E=()=>{r[y]=!0,i[y]==null&&(i[y]=[]),i[y].push({manifestEntry:w,groupOffset:N,sizeBytes:v})};s!=null?s.forEach((_,L)=>{_===w.name&&(E(),o[L]=!0)}):E(),l.push(w.name),N+=v})}),!o.every(I=>I)){const I=s.filter((y,N)=>!o[N]);throw new Error(`Could not find weights in manifest with names: ${I.join(", ")}. 
Manifest JSON has weights with names: ${l.join(", ")}.`)}const u=r.reduce((I,y,N)=>(y&&I.push(N),I),[]),d=[];u.forEach(I=>{e[I].paths.forEach(y=>{const N=t+(t.endsWith("/")?"":"/")+y;d.push(N)})});const h=await n(d),f={};let m=0;return u.forEach(I=>{const y=e[I].paths.length,N=new Ti(h.slice(m,m+y));i[I].forEach(T=>{const v=N.slice(T.groupOffset,T.groupOffset+T.sizeBytes),E=Ck(v,[T.manifestEntry]);for(const _ in E)f[_]=E[_]}),m+=y}),f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dG="application/octet-stream",hG="application/json";class yb{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(W(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=xe().platform.fetch,W(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&W(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Vk(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:hG}),"model.json"),e.weightData!=null){const o=Ti.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:dG}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:ah(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return $2(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=aI(e.weightsManifest),r=()=>uG(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=pG(t),i=this.weightPathPrefix||s,o=[],l=[];for(const u of e)for(const d of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):o.push(i+d+r);return this.weightUrlConverter&&o.push(...await Promise.all(l)),o}async loadWeights(e){const t=await this.getWeightUrls(e),s=aI(e),r=await iL(t,this.loadOptions);return[s,r]}}yb.URL_SCHEME_REGEX=/^https?:\/\//;function pG(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function pI(n){return n.match(yb.URL_SCHEME_REGEX)!=null}const oL=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>pI(s)):t=pI(n),t)return bb(n,e)}return null};vn.registerSaveRouter(oL);vn.registerLoadRouter(oL);function bb(n,e){return new yb(n,e)}function fG(n,e){return bb(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p1{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class lL{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class mG{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function gG(n,e,t,s){const r=arguments;return new mG(uL(...r))}function uL(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new p1(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new p1({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new p1({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function IG(n){return new lL(n)}function yG(n){return new lL(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cL=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Ti,browserFiles:lG,browserHTTPRequest:fG,concatenateArrayBuffers:Rk,copyModel:bW,decodeWeights:Ck,decodeWeightsStream:Ok,encodeWeights:iI,fromMemory:gG,fromMemorySync:uL,getLoadHandlers:iW,getModelArtifactsForJSON:$2,getModelArtifactsForJSONSync:Pk,getModelArtifactsInfoForJSON:ah,getSaveHandlers:Fk,getWeightSpecs:aI,http:bb,isHTTPScheme:pI,listModels:IW,loadWeights:cG,moveModel:xW,registerLoadRouter:rW,registerSaveRouter:sW,removeModel:yW,weightsLoaderFactory:aL,withSaveHandler:IG,withSaveHandlerSync:yG},Symbol.toStringTag,{value:"Module"}));function xb(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(Te(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let o=1;for(let f=0;f<r.length-1;++f)o*=r[f];const l=n.shape,u=r.slice();u.pop();let d=1;for(let f=i;f<t;++f)d*=l[f],u.push(l[f]);const h=[...wt(n.shape).map(f=>f/d),1].slice(0,i);return[u,o,d,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fI=-2,bG=-1;function Nb(n,e,t){const s=n.shape.length;W(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),W(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)W(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function xG(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function wb(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function dL(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function hL(n,e,t){return t<=n?t:t-(e-1)}function pL(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function NG(n,e,t,s,r,i,o,l,u){const d=n.length;let h=new Array(d),f=new Array(d),m=new Array(d);if(e.length&&t>0){const I=e[0],y=t+1;h=fL(o,I,y,s,n),f=mL(l,I,y,r,n),m=dL(i,I,y,n)}else for(let I=0;I<d;I++)h[I]=IL(o,s,i,n,I,u),f[I]=yL(l,r,i,n,I,u),m[I]=gL(i,I,u);return{begin:h,end:f,strides:m}}function fL(n,e,t,s,r){const i=[...r],o=pL(t,e);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=0;else{const u=hL(e,t,l);let d=s[u];n&1<<u&&(d=0),i[l]=d}return i}function mL(n,e,t,s,r){const i=[...r],o=pL(t,e);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=Number.MAX_SAFE_INTEGER;else{const u=hL(e,t,l);let d=s[u];n&1<<u&&(d=Number.MAX_SAFE_INTEGER),i[l]=d}for(let l=0;l<i.length;l++){const u=r[l];i[l]<0&&(i[l]+=u),i[l]=el(0,i[l],r[l])}return i}function gL(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function IL(n,e,t,s,r,i){let o=e[r];const l=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(l>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=s[r];return o<0&&(o+=u),o=el(0,o,u-1),o}function yL(n,e,t,s,r,i){let o=e[r];const l=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(l>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=s[r];return o<0&&(o+=u),l>0?o=el(0,o,u):o=el(-1,o,u-1),o}function Ab(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function Tb(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function eg(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(o=>{W(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((o,l)=>o>=0?o:(W(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${l}.`),n.shape[l]-s[l])),[s,i]}function Sb(n,e,t,s,r,i,o,l,u){let d;if(s==null?(d=new Array(e.length),d.fill(1)):d=s,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const f={dims:d.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:d.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:u};for(let E=0;E<f.dims;E++)h&&1<<E&l&&f.numAddAxisAfterEllipsis++,1<<E&o&&(h=!0);h||(f.ellipsisMask|=1<<f.dims,f.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};wG(f,m);let I=!0,y=!0,N=!0;const w=[],T=[];for(let E=0;E<n.length;++E){if(m.strides[E]===0)throw Error(`strides[${E}] must be non-zero`);const _=!!(m.shrinkAxisMask&1<<E),L=n[E];if(L===-1){w.push(_?1:-1);continue}const P=[m.beginMask&1<<E,m.endMask&1<<E],B=[m.strides[E]>0?0:-1,m.strides[E]>0?L:L-1];if(_&&m.strides[E]<=0)throw Error("only stride 1 allowed on non-range indexing.");N=N&&m.strides[E]===1;const U=!!(m.beginMask&1<<E&&m.endMask&1<<E);if(m.beginValid&&m.endValid){if(_){const de=m.begin[E]<0?L+m.begin[E]:m.begin[E];if(m.begin[E]=de,m.end[E]=m.begin[E]+1,de<0||de>=L)throw Error(`slice index ${m.begin[E]} of dimension ${E} out of bounds.`)}else m.begin[E]=X_(m.begin[E],0,m.strides[E],L,P,B),m.end[E]=X_(m.end[E],1,m.strides[E],L,P,B);const ae=m.strides[E]===1&&m.begin[E]===0&&m.end[E]===L;I=I&&ae,y=y&&(E===0&&m.strides[E]===1||ae)}else I=I&&m.strides[E]===1&&U,y=y&&(E===0&&m.strides[E]===1||U);let Z,Y=!1;if(m.beginValid&&m.endValid?(Z=m.end[E]-m.begin[E],Y=!0):_?(Z=1,Y=!0):U&&L>=0&&(m.strides[E]<0?Z=-L:Z=L,Y=!0),Y){let ae;Z===0||Z<0!=m.strides[E]<0?ae=0:ae=Math.trunc(Z/m.strides[E])+(Z%m.strides[E]!==0?1:0),w.push(ae)}else w.push(-1)}for(let E=0;E<m.finalShapeGatherIndices.length;++E){const _=m.finalShapeGatherIndices[E];_>=0?T.push(w[_]):_===fI&&T.push(1)}return{finalShapeSparse:T.filter((E,_)=>m.finalShapeGatherIndices[_]!==fI),finalShape:T,isIdentity:I,sliceDim0:y,isSimpleSlice:N,begin:m.begin,end:m.end,strides:m.strides}}function wG(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(fI),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(bG),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function X_(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const AG=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Nb,computeFlatOffset:Tb,computeOutShape:wb,getNormalizedAxes:NG,isSliceContinous:Ab,maskToAxes:xG,parseSliceParams:eg,sliceInfo:Sb,startForAxis:IL,startIndicesWithElidedDims:fL,stopForAxis:yL,stopIndicesWithElidedDims:mL,stridesForAxis:gL,stridesWithElidedDims:dL},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TG{static sgd(e){return new Ib(e)}static momentum(e,t,s=!1){return new sL(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new rL(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new tL(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new JC(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new nL(e,t,s,r,i)}static adagrad(e,t=.1){return new eL(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wl=TG;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function bL(){return new Promise(n=>SG(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vb(n,e){const t=n[0].length;n.forEach((r,i)=>{W(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),W(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<t;o++)W(o===e||r[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function Bi(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var hi;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(hi||(hi={}));function xL(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],o=s[s.length-t.length+r],l=s[o];if(i>=0)if(l>=0){if(l!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${l}`)}else s[o]=i}return s}function NL(n){const e={FIRST_DIM_SIZE:hi.FIRST_DIM_SIZE,VALUE_ROWIDS:hi.VALUE_ROWIDS,ROW_LENGTHS:hi.ROW_LENGTHS,ROW_SPLITS:hi.ROW_SPLITS,ROW_LIMITS:hi.ROW_LIMITS,ROW_STARTS:hi.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function wL(n){return n.length===0?0:n[0]===hi.FIRST_DIM_SIZE?n.length-1:n.length}function AL(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],o=e[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $b=30;function tg(n){return n<=$b?n:j1(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _b(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fh(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(i+1))}return r}function mh(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function gh(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function Db(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Eb(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ng=1.7580993408473768,sg=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kb=.3275911,Cb=.254829592,Lb=-.284496736,Ob=1.421413741,Rb=-1.453152027,Vb=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function TL(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function SL(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function vL(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function Pb(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function $L(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function _L(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function DL(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f1="->",vG=/->/g,Z_=",",Q_="...";function Fb(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(vG,"").length)/f1.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${f1}").`);const[s,r]=n.split(f1);W(s.indexOf(Q_)===-1,()=>`The ellipsis notation ("${Q_}") is not supported yet.`);const i=s.split(Z_),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let m=0;m<r.length;++m){const I=r[m];if(!i.some(y=>y.indexOf(I)!==-1))throw new Error(`Output subscripts contain the label ${I} not present in the input subscripts.`);l.indexOf(I)===-1&&l.push(I)}for(let m=0;m<s.length;++m){const I=s[m];l.indexOf(I)===-1&&I!==Z_&&l.push(I)}const u=new Array(i.length);for(let m=0;m<o;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let I=0;I<i[m].length;++I)u[m].push(l.indexOf(i[m][I]))}const d=l.length,h=r.length,f=[];for(let m=h;m<d;++m)f.push(m);return{allDims:l,summedDims:f,idDims:u}}function zb(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Mb(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let o=0;o<e[r].length;++o)s[e[r][o]]===void 0?s[e[r][o]]=i[o]:W(s[e[r][o]]===i[o],()=>`Expected dimension ${s[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function Wb(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<t.length;++o){const l=t[o],u=$G(e,l);for(const d of u)i.indexOf(d)===-1&&(s[o].push(d),i.push(d))}return{path:t,steps:s}}function Bb(n){return n.every((e,t)=>e===t)}function $G(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Hb(n,e,t=0){let s=[];if(typeof e=="number")W(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,l)=>(l===-1&&(o+=1),o),0);W(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((l,u)=>u>0?l+u:l);e[i]=n.shape[t]-o}W(n.shape[t]===e.reduce((o,l)=>o+l),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EL(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function kL(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function CL(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LL(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function OL(n,e){return`size ${n} must be non-negative, not ${e}`}function RL(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function VL(n,e){const t=Te(n),s=Te(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function PL(n,e){const t=Te(n),s=Te(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mI(){return"segment ids must be >= 0"}function FL(){return"segment ids are not increasing"}function zL(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function ML(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WL(n,e){let t=!1,s;for(n<=$b?(s=n,t=!0):s=j1(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=j1(n,s+1);return s}function BL(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function Ub(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let f=0;f<s;++f)if(n.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${n.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const o=n.shape[t],l=[];let u=1,d=1,h=1;for(let f=0;f<s;++f)l.push(n.shape[f]),u*=n.shape[f];for(let f=s;f<t;f++)l.push(n.shape[f]),d*=n.shape[f];for(let f=s;f<r;f++)l.push(e.shape[f]);for(let f=t+1;f<i;f++)l.push(n.shape[f]),h*=n.shape[f];return{batchSize:u,sliceSize:h,outerSize:d,dimSize:o,outputShape:l}}const _G=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Ub,computeOutShape:BL,segOpComputeOptimalWindowSize:WL},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ia(n){try{return n.map(e=>Ga(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function HL(n){return n.map(e=>Ba(e))}const DG=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Cb,ERF_A2:Lb,ERF_A3:Ob,ERF_A4:Rb,ERF_A5:Vb,ERF_P:kb,PARALLELIZE_THRESHOLD:$b,get RowPartitionType(){return hi},SELU_SCALE:sg,SELU_SCALEALPHA:ng,applyActivation:Qm,assertAndGetBroadcastShape:Lt,assertAxesAreInnerMostDims:xs,assertParamsConsistent:vb,assignToTypedArray:$L,axesAreInnerMostDims:P2,calculateShapes:Sl,checkEinsumDimSizes:Mb,checkPadOnDimRoundingMode:Bs,combineLocations:yC,combineRaggedTensorToTensorShapes:xL,complexWithEvenIndex:SL,complexWithOddIndex:vL,computeConv2DInfo:ls,computeConv3DInfo:lo,computeDefaultPad:E2,computeDilation2DInfo:oh,computeOptimalWindowSize:tg,computeOutAndReduceShapes:us,computeOutShape:Bi,computePool2DInfo:ei,computePool3DInfo:ba,convertConv2DDataFormat:xa,decodeEinsumEquation:Fb,eitherStridesOrDilationsAreOne:bs,expandShapeToKeepDim:Fn,exponent:DL,exponents:_L,fromStringArrayToUint8:HL,fromUint8ToStringArray:Ia,getAxesPermutation:En,getBroadcastDims:yu,getComplexWithIndex:Pb,getEinsumComputePath:Wb,getEinsumPermutation:zb,getFusedBiasGradient:Zm,getFusedDyActivation:Xm,getImageCenter:_b,getInnerMostAxes:zn,getPermuted:mh,getRaggedRank:wL,getReductionAxes:Jn,getReshaped:fh,getReshapedPermuted:gh,getRowPartitionTypesHelper:NL,getSliceBeginCoords:Db,getSliceSize:Eb,getSparseFillEmptyRowsIndicesDenseShapeMismatch:EL,getSparseFillEmptyRowsNegativeIndexErrorMessage:kL,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:CL,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:RL,getSparseReshapeInputOutputMismatchErrorMessage:PL,getSparseReshapeInputOutputMultipleErrorMessage:VL,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:LL,getSparseReshapeNegativeOutputDimErrorMessage:OL,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:ML,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:mI,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:FL,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:zL,getUndoAxesPermutation:uo,isIdentityPermutation:Bb,log:xM,mergeRealAndImagArrays:ga,prepareAndValidate:xb,prepareSplitSize:Hb,segment_util:_G,shouldFuse:Jm,slice_util:AG,splitRealAndImagArrays:TL,stridesOrDilationsArePositive:al,tupleValuesAreOne:ja,upcastType:dr,validateDefaultValueShape:AL,validateInput:ob,validateUpdateShape:FC,warn:vr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tG();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UL={kernelName:_f,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,Vu(rt(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EG={kernelName:dd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=pn(rt(t,"float32")),r=ys(ut(At(1),s));return wn(bt(n,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kG={kernelName:hd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=ys(ut(pn(rt(t,"float32")),1));return bt(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG={kernelName:Lu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Lt(t.shape,s.shape);return{a:()=>{let l=n;const u=Jn(t.shape,r);return u.length>0&&(l=ft(l,u)),ie(l,t.shape)},b:()=>{let l=n;const u=Jn(s.shape,r);return u.length>0&&(l=ft(l,u)),ie(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LG={kernelName:Df,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG={kernelName:Ef,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Zt(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG={kernelName:kf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Zt(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VG={kernelName:pd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,ys(ut(At(1),pn(rt(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PG={kernelName:fd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=ys(Me(At(1),pn(rt(t,"float32"))));return bt(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FG={kernelName:Id,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Lt(t.shape,s.shape);return{a:()=>{const l=Me(pn(t),pn(s));let u=ne(n,bt(s,l));const d=Jn(t.shape,r);return d.length>0&&(u=ft(u,d)),ie(u,t.shape)},b:()=>{const l=Me(pn(t),pn(s));let u=wn(ne(n,bt(t,l)));const d=Jn(s.shape,r);return d.length>0&&(u=ft(u,d)),ie(u,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zG={kernelName:md,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,Me(pn(rt(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MG={kernelName:gd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,ut(At(1),pn(rt(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WG(n,e,t,s,r,i){const o=H(n,"dy","avgPool3dGrad"),l=H(e,"input","avgPool3dGrad");let u=o,d=l,h=!1;l.rank===4&&(h=!0,u=ie(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=ie(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),W(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),W(d.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Bs("avgPool3dGrad",r,i);const f={dy:u,input:d},m={filterSize:t,strides:s,pad:r,dimRoundingMode:i},I=se.runKernel(Ay,f,m);return h?ie(I,[I.shape[1],I.shape[2],I.shape[3],I.shape[4]]):I}const BG=J({avgPool3dGrad_:WG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HG={kernelName:Lf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o,dimRoundingMode:l}=t;return{x:()=>BG(n,s,r,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UG(n,e,t,s,r){const i=H(n,"dy","avgPoolGrad"),o=H(e,"input","avgPoolGrad");W(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let l=o,u=i,d=!1;o.rank===3&&(d=!0,l=ie(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=ie(i,[1,i.shape[0],i.shape[1],i.shape[2]])),W(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),W(l.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${l.rank}.`);const h={dy:u,input:l},f={filterSize:t,strides:s,pad:r},m=se.runKernel(wy,h,f);return d?ie(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const GG=J({avgPoolGrad_:UG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qG={kernelName:Cf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o}=t;return{x:()=>GG(n,s,r,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KG={kernelName:Of,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>Gt(n,r,!1,!0),b:()=>Gt(s,n,!0,!1)}:!i&&o?{a:()=>Gt(n,r,!1,!1),b:()=>Gt(n,s,!0,!1)}:i&&!o?{a:()=>Gt(r,n,!1,!0),b:()=>Gt(s,n,!1,!1)}:{a:()=>Gt(r,n,!0,!0),b:()=>Gt(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jG={kernelName:Rf,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>Bm(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YG={kernelName:gM,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,o=Array.from(i);for(let u=r.length-1;u>=0;u--)if(r[u]===i[u])o[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const l=[];for(let u=0;u<o.length;u++)o[u]>1&&l.push(u);return{x:()=>ft(n,l,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XG={kernelName:yd,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZG={kernelName:bd,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG={kernelName:xd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>vs(Ki(co(s,r),Nl(s,i)),n,Zt(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JG={kernelName:Pf,inputsToSave:["x"],gradFunc:UL.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eq={kernelName:Ff,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(u=>u.shape),{axis:r}=t,i=Bt(r,e[0].shape)[0],o=s.map(u=>u[i]);return cr(n,o,i).map(u=>()=>u)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tq={kernelName:zf,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:o,pad:l,dataFormat:u}=t;return W(ja(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>C2(s.shape,n,r,o,l,u),filter:()=>hb(s,n,r.shape,o,l,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nq={kernelName:Mf,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=t;return{dy:()=>Ya(n,r,i,o,l,1,u),filter:()=>hb(n,s,r.shape,i,o,l,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sq(n,e,t,s,r){let i=n;n.rank===4&&(i=ie(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=ie(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),W(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),W(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),W(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),W(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),W(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const l={x:i,dy:o},u={strides:s,pad:r,filterShape:t};return se.runKernel(_y,l,u)}const rq=J({conv3DBackpropFilter_:sq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iq={kernelName:Wf,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;W(ja(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,l]=e;return{x:()=>hC(o.shape,n,l,r,i),filter:()=>rq(o,n,l.shape,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aq={kernelName:Nd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(wn(nb(rt(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oq={kernelName:wd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(sb(rt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lq={kernelName:Bf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:o}=t;return{x:()=>{const l=En([r],s.rank);let u=R2(n,r,i,!o);return l!=null&&(u=Xt(u,l)),u}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uq={kernelName:Hf,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=t,l=s??[1,1];W(ja(l),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${l}'`);const[u,d]=e;return W(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),W(d.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${d.rank}.`),W(u.shape[3]===d.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),W(bs(r,l),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${l}'.`),Bs("depthwiseConv2d",i,o),{x:()=>KC(u.shape,n,d,r,i,l,o),filter:()=>qC(u,n,d.shape,r,i,l,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cq={kernelName:Uf,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>se.runKernel(Y1,i,t),filter:()=>se.runKernel(X1,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dq={kernelName:Td,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>se.runKernel(Fy,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hq={kernelName:Sd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=ne(pr(wn(pn(t))),2/Math.sqrt(Math.PI));return{x:()=>ne(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pq={kernelName:vd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fq={kernelName:qf,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ie(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mq={kernelName:$d,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,pr(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gq={kernelName:_d,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iq={kernelName:Dd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Lt(t.shape,s.shape);return{a:()=>{const l=bt(n,rt(s,"float32")),u=Jn(t.shape,r);return u.length>0?ie(ft(l,u),t.shape):l},b:()=>{let l=ne(n,rt(t,"float32"));const u=Jn(s.shape,r);u.length>0&&(l=ie(ft(l,u),s.shape));const d=pn(s);return wn(bt(l,rt(d,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yq={kernelName:Kf,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,o,l]=e,u=l??At(1),d=Jn(i.shape,r.shape),h=[];if(i.rank===1){for(let _=0;_<r.shape.length-1;++_)h.push(r.shape[_]);h.push(1)}const f=ut(r,i),m=ne(n,u),I=J2(Me(o,At(s))),y=ne(ne(ne(I,I),I),At(-.5));return{x:()=>i.rank===1?ie(ne(ne(n,Ur(ie(I,[1,1,1,i.shape[0]]),h)),u),r.shape):ie(ne(ne(n,I),u),r.shape),mean:()=>{let _=ne(ne(I,At(-1)),m);return i.rank===1&&(_=ft(_,d)),ie(_,i.shape)},variance:()=>{let _=ne(ne(y,f),m);return i.rank===1&&(_=ft(_,d)),ie(_,i.shape)},scale:()=>{const _=ne(f,I);let L=ne(n,_);return i.rank===1&&(L=ft(L,d)),ie(L,i.shape)},offset:()=>{let _=n;return i.rank===1&&(_=ft(_,d)),ie(_,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bq={kernelName:jf,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:o}=t,l=Bt(i,s.shape)[0],u=(d,h,f)=>()=>{const m=d.shape,I=h.size,y=m.slice(0,l),N=y.length,w=m.slice(i,m.length).slice(1),T=w.length,v=J_(0,N),E=J_(N+1,N+1+T),_=e3([y,[I],w]),L=ie(f,_),P=ie(h,[I]),B=e3([[N],v,E]),U=Xt(L,B);let Z=ub(U,P,d.shape[l]);const Y=uo(B);return Z=Xt(Z,Y),Z};if(o===1){const d=s.shape[0],h=s.split(d,0);return{x:()=>fr(h.map((I,y)=>u(I,r.slice(y,1),n.slice(y,1))())).reshape(s.shape),indices:()=>r}}else return{x:u(s,r,n),indices:()=>r}}};function J_(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function e3(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xq={kernelName:Ed,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Zt(t),b:()=>Zt(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nq={kernelName:kd,gradFunc:n=>({x:()=>rt(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wq={kernelName:Cd,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aq={kernelName:Ld,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tq={kernelName:Od,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sq={kernelName:Xf,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=xr(s,0);return{x:()=>vs(i,n,ne(n,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vq={kernelName:Vd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,Me(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $q={kernelName:Rd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,rt(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _q={kernelName:yM,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const o=pr(s);return ut(n,ne(ft(n,r,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dq(n,e,t,s=5,r=1,i=1,o=.5){const l={x:n,y:e,dy:t},u={depthRadius:s,bias:r,alpha:i,beta:o};return se.runKernel(qy,l,u)}const Eq=J({localResponseNormalizationBackprop_:Dq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kq={kernelName:nm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:o,alpha:l,beta:u}=t;return{x:()=>Eq(s,r,n,i,o,l,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(n,e,t,s){return e.rank<t.rank&&(e=ie(e,Fn(e.shape,s))),n.rank<t.rank&&(n=ie(n,Fn(n.shape,s))),{x:()=>ne(n,rt(yi(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t3={kernelName:sm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],o=e[1],l=Bt(r,i.shape),u=GL(n,o,i,l);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cq={kernelName:Pd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ne(n,rt(co(t,s),"float32")),b:()=>ne(n,rt(Kc(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lq(n,e,t,s,r,i,o){const l=H(n,"dy","maxPool3dGrad"),u=H(e,"input","maxPool3dGrad"),d=H(t,"output","maxPool3dGrad");let h=l,f=u,m=d,I=!1;u.rank===4&&(I=!0,h=ie(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=ie(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=ie(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),W(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),W(f.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${f.rank}.`),W(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Bs("maxPool3dGrad",i,o);const y={dy:h,input:f,output:m},N={filterSize:s,strides:r,pad:i,dimRoundingMode:o},w=se.runKernel(jy,y,N);return I?ie(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const Oq=J({maxPool3dGrad_:Lq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rq={kernelName:im,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=t;return{x:()=>Oq(n,s,r,i,o,l,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vq(n,e,t,s,r,i,o){const l=H(n,"dy","maxPoolGrad"),u=H(e,"input","maxPoolGrad"),d=H(t,"output","maxPoolGrad");W(u.rank===l.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${l.rank})`),W(l.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),W(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Bs("maxPoolGrad",i,o);const h={dy:l,input:u,output:d},f={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return se.runKernel(Ky,h,f)}const Pq=J({maxPoolGrad_:Vq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fq={kernelName:rm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:l}=t;return{x:()=>Pq(n,s,r,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zq={kernelName:am,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=Bt(r,s.shape),l=us(s.shape,i)[1],u=Te(l);return{x:()=>{const h=s.shape.slice();i.forEach(I=>{h[I]=1});const f=ie(n,h);return bt(ne(f,ur(s.shape,"float32")),u)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mq={kernelName:om,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,o]=e,l=Bt(r,i.shape),u=GL(n,o,i,l);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wq={kernelName:Fd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ne(n,rt(Nl(t,s),"float32")),b:()=>ne(n,rt(xr(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bq={kernelName:lm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>Yt(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hq={kernelName:zd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Lt(t.shape,s.shape);return{a:()=>{const l=Jn(t.shape,r);return l.length>0?ie(ft(n,l),t.shape):n},b:()=>{const l=ne(n,wn(hh(bt(t,s)))),u=Jn(s.shape,r);return u.length>0?ie(ft(l,u),s.shape):l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uq={kernelName:Md,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Lt(t.shape,s.shape);return{a:()=>{const l=ne(n,rt(s,"float32")),u=Jn(t.shape,r);return u.length>0?ie(ft(l,u),t.shape):l},b:()=>{const l=ne(n,rt(t,"float32")),u=Jn(s.shape,r);return u.length>0?ie(ft(l,u),s.shape):l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gq={kernelName:um,gradFunc:n=>({x:()=>wn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qq={kernelName:hm,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>qn(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kq={kernelName:dm,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jq={kernelName:pm,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Jr(n,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n3={kernelName:fm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>Yt(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yq={kernelName:Wd,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,o=s,l=Lt(i.shape,o.shape);return{a:()=>{const h=rt(o,"float32");let f=ne(n,ne(h,fa(i,ut(h,At(1)))));const m=Jn(i.shape,l);return m.length>0&&(f=ft(f,m)),ie(f,i.shape)},b:()=>{const h=xr(i,0),f=vs(h,Er(i),Zt(i));let m=ne(n,ne(r,f));const I=Jn(o.shape,l);return I.length>0&&(m=ft(m,I)),ie(m,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xq={kernelName:mm,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=xr(t,0);return{x:()=>vs(r,n,ne(n,s)),alpha:()=>{let i=vs(r,Zt(n),ne(n,t));const o=Jn(s.shape,n.shape);return o.length>0&&(i=ft(i,o)),ie(i,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zq(n,e,t){const s=n.shape.slice();s[t]=1;const r=ie(e,s),i=Kp(n,t,!0,!1),o=Kp(n,t,!0,!0),l=ne(i,o);return ne(r,l)}function Qq(n,e,t){const s=n.shape.length,r=s-t.length,i=En(t,s);let o=n;i!=null&&(o=Xt(n,i));const l=o.shape.slice(),d=l.splice(s-t.length,t.length).reduce((m,I)=>m*I,1);l.push(d);const h=o.reshape(l);let f=Zq(h,e,r);if(f=f.reshape(o.shape),i!=null){const m=uo(i);f=Xt(f,m)}return f}const Jq={kernelName:gm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((o,l)=>l):typeof r=="number"?i=[r]:i=r,{x:()=>Qq(s,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eK={kernelName:Ad,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Lt(t.shape,s.shape);return{a:()=>{const l=bt(n,rt(s,"float32")),u=Jn(t.shape,r);return u.length>0?ie(ft(l,u),t.shape):l},b:()=>{let l=ne(n,rt(t,"float32"));const u=Jn(s.shape,r);u.length>0&&(l=ie(ft(l,u),s.shape));const d=pn(s);return wn(bt(l,rt(d,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tK={kernelName:Bd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,wn(pn(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nK={kernelName:Ud,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=ne(Nl(t,6),Vu(t));return{x:()=>ne(n,rt(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sK={kernelName:Hd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,rt(Vu(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rK={kernelName:Im,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ie(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iK={kernelName:bm,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>se.runKernel(a2,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aK={kernelName:ym,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>se.runKernel(i2,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oK={kernelName:xm,gradFunc:(n,e,t)=>{const{dims:s}=t,r=Bt(s,n.shape);return{x:()=>Qr(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lK={kernelName:Gd,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uK={kernelName:qd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>wn(bt(n,ne(fa(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cK={kernelName:Nm,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>rt(Zt(t),"float32"),t:()=>ne(n,rt(t,n.dtype)),e:()=>ne(n,rt(zm(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dK={kernelName:Kd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=xr(t,At(0)),r=At(ng),i=At(sg),o=ne(n,i),l=ne(ne(n,r),pr(rt(t,"float32")));return vs(s,o,l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hK={kernelName:Zd,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,ne(t,ut(At(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pK={kernelName:Xd,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fK={kernelName:jd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(Om(rt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mK={kernelName:Yd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(O2(rt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gK={kernelName:wm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,o=s.shape,[l,u]=eg(s,r,i),d=[];for(let h=0;h<n.rank;h++)d.push([l[h],o[h]-l[h]-u[h]]);return{x:()=>ho(n,d)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IK={kernelName:vm,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,o=ne(n,s);return{logits:()=>ut(o,ne(ft(o,[r],i),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yK={kernelName:Qd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,Wi(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s3={kernelName:Tm,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>Lm(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r3={kernelName:Sm,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>Un(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bK={kernelName:Jd,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,ne(ys(rt(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xK={kernelName:m2,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,ne(rt(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NK={kernelName:eh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=At(2);return{a:()=>ne(n,ne(r,ut(t,s))),b:()=>ne(n,ne(r,ut(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wK={kernelName:ih,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AK={kernelName:th,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Lt(t.shape,s.shape);return{a:()=>{let l=n;const u=Jn(t.shape,r);return u.length>0&&(l=ft(l,u)),ie(l,t.shape)},b:()=>{let l=n;const u=Jn(s.shape,r);return u.length>0&&(l=ft(l,u)),ie(wn(l),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TK={kernelName:Am,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;Bt(i,s.shape).forEach(d=>{r[d]=1});const l=ie(n,r),u=ne(l,ur(s.shape,"float32"));return{x:()=>u}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SK={kernelName:nh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,pn(Om(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vK={kernelName:sh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(ut(At(1),pn(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $K={kernelName:rh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let o=Zt(s);if(s.rank===1)for(let l=0;l<r[0];++l)o=Me(o,Yt(n,[l*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let l=0;l<r[0];++l)for(let u=0;u<r[1];++u)o=Me(o,Yt(n,[l*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let l=0;l<r[0];++l)for(let u=0;u<r[1];++u)for(let d=0;d<r[2];++d)o=Me(o,Yt(n,[l*s.shape[0],u*s.shape[1],d*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let l=0;l<r[0];++l)for(let u=0;u<r[1];++u)for(let d=0;d<r[2];++d)for(let h=0;h<r[3];++h)o=Me(o,Yt(n,[l*s.shape[0],u*s.shape[1],d*s.shape[2],h*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _K={kernelName:au,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=uo(r);return{x:()=>Xt(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DK={kernelName:_m,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>fr(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EK={kernelName:Dm,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>kK(n,t)}}};function kK(n,e){const t=Na(e,Zt(e)),s=ph(n,t);let r=co(e,At(0,"int32"));const i=s.rank-r.rank;for(let l=0;l<i;++l)r=Ps(r,l+1);r=Ki(r,ur(s.shape,"bool"));const o=Zt(s);return vs(r,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CK={kernelName:Em,gradFunc:n=>({x:()=>Zt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LK=[UL,EG,kG,CG,LG,OG,RG,VG,PG,FG,zG,MG,HG,qG,KG,jG,YG,XG,ZG,QG,JG,eq,nq,tq,iq,aq,oq,lq,uq,cq,eK,dq,hq,pq,fq,mq,Iq,gq,yq,bq,xq,Nq,wq,Aq,Tq,Sq,vq,$q,_q,kq,t3,t3,Cq,Rq,Fq,zq,Mq,Wq,Bq,Hq,Uq,Gq,qq,Kq,jq,n3,n3,Yq,Xq,Jq,tK,nK,sK,rK,iK,aK,oK,lK,uK,cK,dK,hK,pK,fK,mK,gK,IK,yK,s3,s3,r3,r3,bK,NK,xK,wK,AK,TK,SK,vK,$K,_K,DK,EK,CK];for(const n of LK)NM(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.abs=function(){return this.throwIfDisposed(),Gn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.acos=function(){return this.throwIfDisposed(),Kk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.acosh=function(){return this.throwIfDisposed(),jk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.add=function(n){return this.throwIfDisposed(),Me(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.all=function(n,e){return this.throwIfDisposed(),D2(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.any=function(n,e){return this.throwIfDisposed(),qp(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.argMax=function(n){return this.throwIfDisposed(),Iu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.argMin=function(n){return this.throwIfDisposed(),Yk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.asScalar=function(){return this.throwIfDisposed(),W(this.size===1,()=>"The array must have only 1 element."),ie(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.asType=function(n){return this.throwIfDisposed(),rt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.as1D=function(){return this.throwIfDisposed(),ie(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.as2D=function(n,e){return this.throwIfDisposed(),ie(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),ie(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),ie(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),ie(this,[n,e,t,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.asin=function(){return this.throwIfDisposed(),Xk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.asinh=function(){return this.throwIfDisposed(),Zk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.atan=function(){return this.throwIfDisposed(),Qk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.atan2=function(n){return this.throwIfDisposed(),Jk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.atanh=function(){return this.throwIfDisposed(),eC(this)};ve().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),Cm(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),Lm(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),lh(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.broadcastTo=function(n){return this.throwIfDisposed(),uu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.cast=function(n){return this.throwIfDisposed(),rt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.ceil=function(){return this.throwIfDisposed(),aC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),hr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof $n&&(n=[n]),Un([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),k2(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),L2(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Ya(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.cos=function(){return this.throwIfDisposed(),Om(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.cosh=function(){return this.throwIfDisposed(),O2(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),Kp(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),R2(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),fC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),uh(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),mC(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.divNoNan=function(n){return this.throwIfDisposed(),gC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.div=function(n){return this.throwIfDisposed(),bt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.dot=function(n){return this.throwIfDisposed(),IC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.elu=function(){return this.throwIfDisposed(),ch(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.equal=function(n){return this.throwIfDisposed(),yi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.erf=function(){return this.throwIfDisposed(),V2(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),xC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.exp=function(){return this.throwIfDisposed(),pr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.expandDims=function(n){return this.throwIfDisposed(),Ps(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.expm1=function(){return this.throwIfDisposed(),NC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.fft=function(){return this.throwIfDisposed(),jm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.flatten=function(){return this.throwIfDisposed(),ie(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.floor=function(){return this.throwIfDisposed(),hh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.floorDiv=function(n){return this.throwIfDisposed(),_2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.gather=function(n,e,t){return this.throwIfDisposed(),ph(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.greaterEqual=function(n){return this.throwIfDisposed(),co(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.greater=function(n){return this.throwIfDisposed(),xr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.ifft=function(){return this.throwIfDisposed(),Xc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.irfft=function(){return this.throwIfDisposed(),ib(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.isFinite=function(){return this.throwIfDisposed(),wC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.isInf=function(){return this.throwIfDisposed(),AC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.isNaN=function(){return this.throwIfDisposed(),TC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Vm(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.lessEqual=function(n){return this.throwIfDisposed(),Nl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.less=function(n){return this.throwIfDisposed(),Kc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),SC(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.logSigmoid=function(){return this.throwIfDisposed(),vC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.logSoftmax=function(n){return this.throwIfDisposed(),z2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),Fm(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.log=function(){return this.throwIfDisposed(),Er(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.log1p=function(){return this.throwIfDisposed(),Pm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ki(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.logicalNot=function(){return this.throwIfDisposed(),zm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.logicalOr=function(n){return this.throwIfDisposed(),M2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.logicalXor=function(n){return this.throwIfDisposed(),$C(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),Gt(this,n,e,t)};ve().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),Mm(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.max=function(n,e){return this.throwIfDisposed(),Yr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.maximum=function(n){return this.throwIfDisposed(),Na(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.mean=function(n,e){return this.throwIfDisposed(),On(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.min=function(n,e){return this.throwIfDisposed(),qc(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.minimum=function(n){return this.throwIfDisposed(),ll(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),DC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.mod=function(n){return this.throwIfDisposed(),EC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.mul=function(n){return this.throwIfDisposed(),ne(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.neg=function(){return this.throwIfDisposed(),wn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.norm=function(n,e,t){return this.throwIfDisposed(),dh(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.notEqual=function(n){return this.throwIfDisposed(),bu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),B2(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.onesLike=function(){return this.throwIfDisposed(),kr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.pad=function(n,e){return this.throwIfDisposed(),ho(this,n,e)};ve().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),kC(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.pow=function(n){return this.throwIfDisposed(),fa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.prelu=function(n){return this.throwIfDisposed(),Hm(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.prod=function(n,e){return this.throwIfDisposed(),CC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.reciprocal=function(){return this.throwIfDisposed(),OC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.relu=function(){return this.throwIfDisposed(),Xi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.relu6=function(){return this.throwIfDisposed(),Z2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.reshapeAs=function(n){return this.throwIfDisposed(),ie(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.reshape=function(n){return this.throwIfDisposed(),ie(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),XC(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),ZC(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.reverse=function(n){return this.throwIfDisposed(),Qr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.rfft=function(){return this.throwIfDisposed(),Ym(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.round=function(){return this.throwIfDisposed(),Q2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.rsqrt=function(){return this.throwIfDisposed(),J2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.selu=function(){return this.throwIfDisposed(),eb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),tb(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.sigmoid=function(){return this.throwIfDisposed(),Wi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.sign=function(){return this.throwIfDisposed(),RC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.sin=function(){return this.throwIfDisposed(),nb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.sinh=function(){return this.throwIfDisposed(),sb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.slice=function(n,e){return this.throwIfDisposed(),Yt(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.softmax=function(n){return this.throwIfDisposed(),Km(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.softplus=function(){return this.throwIfDisposed(),Ru(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),Bm(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.split=function(n,e){return this.throwIfDisposed(),cr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.sqrt=function(){return this.throwIfDisposed(),ys(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.square=function(){return this.throwIfDisposed(),pn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.squaredDifference=function(n){return this.throwIfDisposed(),ab(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.squeeze=function(n){return this.throwIfDisposed(),Tl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof $n?[this,n]:[this,...n];return fr(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.step=function(n){return this.throwIfDisposed(),Vu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.stridedSlice=function(n,e,t,s,r,i,o,l){return this.throwIfDisposed(),VC(this,n,e,t,s,r,i,o,l)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.sub=function(n){return this.throwIfDisposed(),ut(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.sum=function(n,e){return this.throwIfDisposed(),ft(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.tan=function(){return this.throwIfDisposed(),PC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.tanh=function(){return this.throwIfDisposed(),ol(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.tile=function(n){return this.throwIfDisposed(),Ur(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.toBool=function(){return this.throwIfDisposed(),rt(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.toFloat=function(){return this.throwIfDisposed(),rt(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.toInt=function(){return this.throwIfDisposed(),rt(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.topk=function(n,e){return this.throwIfDisposed(),zC(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.transpose=function(n){return this.throwIfDisposed(),Xt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.unique=function(n){return this.throwIfDisposed(),MC(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),ub(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.unstack=function(n){return this.throwIfDisposed(),Jr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.where=function(n,e){return this.throwIfDisposed(),vs(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ve().prototype.zerosLike=function(){return this.throwIfDisposed(),Zt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Li extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Li.prototype)}}class Gr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Gr.prototype)}}class oe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,oe.prototype)}}class Vt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Vt.prototype)}}class Gb extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Gb.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class qL{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cl(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function Oi(n,e){if(!n)throw new Gb(e)}function i3(n,e){let t=0;for(const s of n)s===e&&t++;return t}function Xs(n){return n.length===1?n[0]:n}function ln(n){return Array.isArray(n)?n:[n]}function ra(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Mo(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Rr={};function qb(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function gI(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>gI(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:gI(s))}}}function Ih(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in Rr)o=Rr[i];else if(o=e[i],o==null)throw new oe(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new oe(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let l,u;if(o in t?[l,u]=t[o]:o in Rr?[l,u]=Rr.className:o in e&&([l,u]=e[o]),l==null)throw new oe(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const d={};for(const I of Object.keys(Rr))d[I]=Rr[I];for(const I of Object.keys(t))d[I]=t[I];const h=i.config;h.customObjects=d;const f=Object.assign({},Rr);for(const I of Object.keys(t))Rr[I]=t[I];gI(i.config);const m=u(l,i.config,t,r);return Rr=Object.assign({},f),m}else{const d=Object.assign({},Rr);for(const f of Object.keys(t))Rr[f]=t[f];const h=new l(i.config);return Rr=Object.assign({},d),h}}}function OK(n,e){return n<e?-1:n>e?1:0}function sp(n,e){return-1*OK(n,e)}function Ha(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function RK(n){if(n==null)throw new oe(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function vl(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new oe(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function Kb(n,e,t=0,s=1/0){return Oi(t>=0),Oi(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function as(n,e){Array.isArray(n)?(W(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>as(t,`element ${s+1} of ${e}`))):W(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${KL(n)}.`)}function KL(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>KL(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function VK(n,e,t){let s=t!=null?t():js(),r;return(...o)=>{const l=t!=null?t():js();return l-s<e||(s=l,r=n(...o)),r}}function jL(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let PK=0;function YL(){return PK++}const rp={};function rg(n=""){return n in rp||(rp[n]=0),rp[n]+=1,n+rp[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const FK=["channelsFirst","channelsLast"],zK=["nearest","bilinear"],MK=["valid","same","causal"],WK=["max","avg"],BK=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Bl=new Map;function Mn(n){vl(FK,"DataFormat",n)}function HK(n){vl(zK,"InterpolationFormat",n)}function Lr(n){vl(MK,"PaddingMode",n)}function XL(n){vl(WK,"PoolMode",n)}const Oc=[],a3="/";function Yo(n,e){Oc.push(n);try{const t=e();return Oc.pop(),t}catch(t){throw Oc.pop(),t}}function UK(){return Oc.length===0?"":Oc.join(a3)+a3}function ZL(n){if(!JL(n))throw new Error("Not a valid tensor name: '"+n+"'");return UK()+n}function QL(n){if(!JL(n))throw new Error("Not a valid tensor name: '"+n+"'");Bl.has(n)||Bl.set(n,0);const e=Bl.get(n);if(Bl.set(n,Bl.get(n)+1),e>0){const t=`${n}_${e}`;return Bl.set(t,1),t}else return n}const GK=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function JL(n){return!!n.match(GK)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qK(n){return n===parseInt(n.toString(),10)}function Ua(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function Nu(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Xa(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function bi(n,e){if(e<n)throw new oe(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let m1;function Kn(){return m1==null&&(m1=kk().epsilon()),m1}function xi(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hi(n,e){return rt(n,e)}function yh(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ie(n,t)}function KK(n,e){return pe(()=>{if(n.shape.length!==2)throw new oe(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=yh(n,1);return II(t,[1,e,1])})}function jK(n){const e=[Ua(n.shape)];return ie(n,e)}function YK(n){if(n.rank<=1)throw new oe(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Ua(n.shape,1)];return ie(n,e)}function Xo(n,e,t){return pe(()=>{switch(n.rank){case 1:return Gm(n,e,t);case 2:return rb(n,[e,0],[t,n.shape[1]]);case 3:return qm(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Yc(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Yt(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Yt(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new oe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function g1(n,e,t){return pe(()=>{switch(n.rank){case 1:return Gm(n,e,t);case 2:return rb(n,[0,e],[n.shape[0],t]);case 3:return qm(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Yc(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new oe(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function ip(n,e,t,s){return pe(()=>{switch(n.rank){case 1:return Gm(n,e,t);case 2:switch(s){case 1:return Xo(n,e,t);case 2:return g1(n,e,t);default:throw new oe(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Xo(n,e,t);case 2:return qm(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return g1(n,e,t);default:throw new oe(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Xo(n,e,t);case 2:return Yc(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Yc(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return g1(n,e,t);default:throw new oe(`The axis is not within the rank of the tensor ${s}`)}default:throw new oe(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function jb(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),Un(n,e)}function o3(n,e){switch(n.rank){case 1:return oC([n,e]);case 2:return lC([n,e],0);case 3:return uC([n,e],0);case 4:return cC([n,e],0);default:throw new oe(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function II(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new oe(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return Ur(n,e)}function ig(n,e=0,t=1,s,r){return X2(n,e,t,s,r)}function Ui(n,e,t,s){if(n.rank<2||e.rank<2)throw new Vt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new Vt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return hI({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?yI(n.rank,s,xi()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=ie(n,[-1,i]);const o=e.shape.slice(),l=o.pop(),u=o.pop(),d=[...o,l],h=Array.from({length:e.rank},(y,N)=>N===0?e.rank-2:N<=e.rank-2?N-1:N);e=ie(Xt(e,h),[u,-1]);const f=[...r,...d];return ie(hI({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?yI(n.rank,s,xi()):null,activation:t}),f)}}function e4(n,e,t){return pe(()=>(Array.isArray(e)?e=Ms(e,"int32"):e=rt(e,"int32"),ph(n,e,t)))}function bh(n){return ne(n,n)}function yI(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new oe(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?ie(e,[1,s[0],1,1,1]):ie(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?ie(e,[1,1,1,1,s[0]]):ie(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?ie(e,[1,s[0],1,1]):ie(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?ie(e,[1,1,1,s[0]]):ie(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?ie(e,[1,s[0],1]):ie(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?ie(e,[1,1,s[0]]):ie(e,[1].concat(s))}else if(n<3)return e;throw new oe(`Unsupported input rank by biasAdd: ${e.rank}`)}function Si(n,e,t){return pe(()=>(t==null&&(t=xi()),Mn(t),Me(n,yI(n.rank,e,t))))}function XK(n,e=1){if(e!==1)throw new Vt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return ch(n)}function ZK(n){return pe(()=>bt(n,Me(Gn(n),1)))}function t4(n,e,t,s){return pe(()=>HC(n,e,t,s))}function QK(n){return pe(()=>{const e=Me(.5,ne(.2,n));return hr(e,0,1)})}function xh(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const JK=["fanIn","fanOut","fanAvg"],ej=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tj(n){vl(JK,"FanMode",n)}function nj(n){vl(ej,"Distribution",n)}class ti extends Fu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class n4 extends ti{apply(e,t){return qn(e,t)}}n4.className="Zeros";He(n4);class Yb extends ti{apply(e,t){return ur(e,t)}}Yb.className="Ones";He(Yb);class s4 extends ti{constructor(e){if(super(),typeof e!="object")throw new oe(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new oe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return pe(()=>ne(At(this.value),ur(e,t)))}getConfig(){return{value:this.value}}}s4.className="Constant";He(s4);class r4 extends ti{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Al(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}r4.className="RandomUniform";He(r4);class i4 extends ti{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Vt(`randomNormal does not support dType ${t}.`);return ig(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}i4.className="RandomNormal";He(i4);class a4 extends ti{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Vt(`truncatedNormal does not support dType ${t}.`);return lb(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}a4.className="TruncatedNormal";He(a4);class o4 extends ti{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return pe(()=>{if(e.length!==2||e[0]!==e[1])throw new oe("Identity matrix initializer can only be used for 2D square matrices.");return ne(this.gain,F2(e[0]))})}getConfig(){return{gain:this.gain}}}o4.className="Identity";He(o4);function sj(n,e="channelsLast"){let t,s;if(Mn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=Ua(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=Ua(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Ua(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class mr extends ti{constructor(e){if(super(),e.scale<0)throw new oe(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,tj(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,nj(this.distribution),this.seed=e.seed}apply(e,t){const s=sj(e),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const l=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Vt(`${this.getClassName()} does not support dType ${t}.`);return lb(e,0,l,t,this.seed)}else{const l=Math.sqrt(3*o);return Al(e,-l,l,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}mr.className="VarianceScaling";He(mr);class Xb extends mr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return mr.className}}Xb.className="GlorotUniform";He(Xb);class Zb extends mr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return mr.className}}Zb.className="GlorotNormal";He(Zb);class Qb extends mr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return mr.className}}Qb.className="HeNormal";He(Qb);class Jb extends mr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return mr.className}}Jb.className="HeUniform";He(Jb);class ex extends mr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return mr.className}}ex.className="LeCunNormal";He(ex);class tx extends mr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return mr.className}}tx.className="LeCunUniform";He(tx);class l4 extends ti{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return pe(()=>{if(e.length<2)throw new Vt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=Te(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],l=ig(o,0,1,t,this.seed),u=QC.qr(l,!1);let d=u[0];const f=u[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return d=ne(d,f.sign()),s<r&&(d=d.transpose()),ne(At(this.gain),d.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}l4.className="Orthogonal";He(l4);const l3={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function u3(n,e={}){return Ih(n,Mr.getMap().classNameMap,e,"initializer")}function _n(n){return qb(n)}function An(n){if(typeof n=="string"){const e=n in l3?l3[n]:n;if(e==="GlorotNormal")return new Zb;if(e==="GlorotUniform")return new Xb;if(e==="HeNormal")return new Qb;if(e==="HeUniform")return new Jb;if(e==="LeCunNormal")return new ex;if(e==="LeCunUniform")return new tx;{const t={};return t.className=e,t.config={},u3(t)}}else return n instanceof ti?n:u3(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bI(n){return Array.isArray(n)&&Array.isArray(n[0])}function jp(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function $t(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new oe(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function tn(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new oe(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yp(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const c3="Variable";class rj{constructor(e,t="float32",s=c3,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=YL(),s=s??c3,this.originalName=ZL(s),this.name=QL(this.originalName),this.trainable_=r,this.constraint=i,this.val=WC(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),ij(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function ij(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function xI(n){return n.map(e=>e.read())}function nx(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class ji{constructor(e,t,s,r,i,o,l){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=l,this.id=YL(),o!=null&&(this.originalName=ZL(o),this.name=QL(this.originalName)),this.rank=t.length}}let aj=0;class ag{constructor(e,t){this.callArgs=t,this.id=aj++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let oj=0;class Ht extends Fu{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=oj++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=ra(s)+"_"+rg(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Gr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new oe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Xs(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Xs(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Li(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Li(`Layer ${this.name} is not connected, no input to return.`);return Xs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Li(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Li(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Xs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=ln(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=ln(this.inputSpec);if(t.length!==s.length)throw new oe(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],o=s[r];if(o==null)continue;const l=i.rank;if(o.ndim!=null&&l!==o.ndim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${l}`);if(o.maxNDim!=null&&l>o.maxNDim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${l}`);if(o.minNDim!=null&&l<o.minNDim)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${l}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new oe(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const u=i.shape;for(const d in o.axes){const h=Number(d),f=o.axes[d],m=h>=0?u[h]:u[u.length+h];if(f!=null&&[f,null].indexOf(m)===-1)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected axis ${h} of input shape to have value ${f} but got shape ${u}.`)}}if(o.shape!=null)for(let u=0;u<o.shape.length;++u){const d=o.shape[u],h=i.shape[u];if(d!=null&&h!=null&&d!==h)throw new oe(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=ln(e),r=cj(e),i=dj(e);if(r===i)throw new oe("Arguments to apply() must be all SymbolicTensors or all Tensors");return Yo(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const l of ln(e))o.push(l.shape);this.build(Xs(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const l=ln(o),u=[];for(let d of l)s.indexOf(d)!==-1&&(d=d.clone()),u.push(d);if(o=Xs(u),this.activityRegularizer!=null)throw new Vt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=lj(e),l=this.computeOutputShape(o);let u;const d=uj(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),l!=null&&l.length>0&&Array.isArray(l[0])?u=l.map((h,f)=>new ji(d,h,this,ln(e),t,this.name,f)):u=new ji(d,l,this,ln(e),t,this.name),this.addInboundNode(e,u,null,null,o,l,t),this._refCount++,this.activityRegularizer!=null)throw new Vt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Li(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Li(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Gr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Yp(this.weights)}build(e){this.built=!0}getWeights(e=!1){return xI(e?this.trainableWeights:this.weights)}setWeights(e){pe(()=>{const t=this.weights;if(t.length!==e.length)throw new oe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=xI(t);for(let i=0;i<r.length;++i){const o=r[i],l=t[i],u=e[i];if(!Kt(o.shape,u.shape))throw new oe(`Layer weight shape ${o.shape} not compatible with provided weight shape ${u.shape}`);s.push([l,u])}nx(s)})}addWeight(e,t,s,r,i,o,l,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new oe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=u!=null?u():An("zeros"));const d=r.apply(t,s),h=new rj(d,s,e,o,l);return d.dispose(),i!=null&&this.addLoss(()=>i.apply(h.read())),o==null&&(o=!0),o?this._trainableWeights.push(h):this._nonTrainableWeights.push(h),h}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=ln(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=ln(t),o=ln(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let l=0;l<i.length;l++)i[l].kerasMask=o[l]}addInboundNode(e,t,s,r,i,o,l=null){const u=ln(e);t=ln(t),s=ln(s),r=ln(r),i=jp(i),o=jp(o);const d=[],h=[],f=[];for(const m of u)d.push(m.sourceLayer),h.push(m.nodeIndex),f.push(m.tensorIndex);new ag({outboundLayer:this,inboundLayers:d,nodeIndices:h,tensorIndices:f,inputTensors:u,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},l);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function lj(n){n=ln(n);const e=[];for(const t of n)e.push(t.shape);return Xs(e)}function uj(n){return"float32"}function u4(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],l=s.inboundLayers[i],u=s.nodeIndices[i],d=u4(o,l,u);for(const h of d)r.indexOf(h)===-1&&r.push(h)}return r}}}function cj(n){let e=!0;for(const t of ln(n))if(!(t instanceof ji)){e=!1;break}return e}function dj(n){let e=!0;for(const t of ln(n))if(t instanceof ji){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Nh extends Ht{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:rg("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new oe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new oe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new oe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new ji(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new ag({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new oe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Nh.className="InputLayer";He(Nh);function hj(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new oe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new Nh({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pj(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return rt(e,n.dtype)}catch{throw new oe(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Fa{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Fa)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=pj(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new oe(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ji){if(this.id2Value[e.id]==null)throw new oe(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new oe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ji){if(this.id2Value[e.id]==null)throw new oe(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new oe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Ft(this.id2Mask)}}const Xp=new qL,Zp=new qL;function fj(n){Xp!=null&&Xp.setMaxEntries(n),Zp!=null&&Zp.setMaxEntries(n)}function Nc(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],l=o.map(y=>y.name),u=[],d=e.names();for(const y of l)d.indexOf(y)!==-1?u.push(e.getValue(y)):u.push(null);s!=null&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const h=l.join(",")+"|"+e.names().sort().join(",");let f=Xp.get(h),m;if(f==null){const y=mj(o,e);f=y.sorted,m=y.recipientCounts,Xp.put(h,f),Zp.put(h,m)}m={},r||Object.assign(m,Zp.get(h));const I=new Fa(e);for(let y=0;y<f.length;++y){if(s!=null){const Z=rI().numTensors;Z>s.maxNumTensors&&(s.maxNumTensors=Z),Z<s.minNumTensors&&(s.minNumTensors=Z)}const N=f[y],w=N.sourceLayer;if(w instanceof Nh)continue;const T=[],v=[],E=[];let _=!1;for(const Z of N.inputs){const Y=I.getValue(Z),ae=I.getMask(Z);T.push(Y),v.push(ae),ae!=null&&(_=!0),r||(m[Z.name]--,m[Z.name]===0&&!e.hasKey(Z)&&l.indexOf(Z.name)===-1&&!Y.isDisposed&&Z.sourceLayer.stateful!==!0&&E.push(Y))}_&&(t=t||{},t.mask=v[0]);const L=ln(w.apply(T,t));let P=null;w.supportsMasking&&(P=w.computeMask(T,v));const B=Ij(N),U=Array.isArray(B)?B:[B];for(let Z=0;Z<U.length;++Z){I.hasKey(U[Z])||I.add(U[Z],L[Z],Array.isArray(P)?P[0]:P);const Y=l.indexOf(U[Z].name);Y!==-1&&(u[Y]=L[Z])}r||Ft(E)}return I.disposeMasks(),i?u:u[0]}function mj(n,e){W(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=d3(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:l}=d3(i,e);for(const u of o)r.has(u.name)||(t.push(u),r.add(u.name));for(const u in l)s[u]==null&&(s[u]=new Set),l[u].forEach(d=>s[u].add(d))}}return{sorted:t,recipientCounts:gj(s)}}function gj(n){const e={};for(const t in n)e[t]=n[t].size;return e}function d3(n,e){const t=new Set,s=[],r={};for(const l of e.names())t.add(l);const i=[],o=[];for(i.push(n);i.length>0;){const l=i[i.length-1];if(t.has(l.name)){i.pop();continue}const u=o[o.length-1]===i.length-1;if(l.inputs.length===0||u)i.pop(),s.push(l),t.add(l.name),u&&o.pop();else{o.push(i.length-1);for(const d of l.inputs)r[d.name]==null&&(r[d.name]=new Set),r[d.name].add(l.name),!t.has(d.name)&&i.push(d)}}return{sorted:s,recipientMap:r}}function Ij(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yj=xe();yj.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,fj);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sx(n,e){return pe(()=>ys(ft(ne(n,n),e,!0)))}class wh extends Fu{getConfig(){return{}}}class c4 extends wh{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return pe(()=>{const t=sx(e,this.axis),s=hr(t,0,this.maxValue);return ne(e,bt(s,Me(Kn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}c4.className="MaxNorm";He(c4);class d4 extends wh{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return pe(()=>bt(e,Me(Kn(),sx(e,this.axis))))}getConfig(){return{axis:this.axis}}}d4.className="UnitNorm";He(d4);class h4 extends wh{apply(e){return Xi(e)}}h4.className="NonNeg";He(h4);class p4 extends wh{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return pe(()=>{const t=sx(e,this.axis),s=Me(ne(this.rate,hr(t,this.minValue,this.maxValue)),ne(1-this.rate,t));return ne(e,bt(s,Me(Kn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}p4.className="MinMaxNorm";He(p4);const h3={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Xn(n){return qb(n)}function p3(n,e={}){return Ih(n,Mr.getMap().classNameMap,e,"constraint")}function Zn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in h3?h3[n]:n,config:{}};return p3(t)}else return n instanceof wh?n:p3(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Oo(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(r),s.push(o)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];Ft(s)}}function f4(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var f3;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(f3||(f3={}));const bj=125;class Zc{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class xj{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Nj extends Zc{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const l=pe(()=>Me(this.totals[r],ne(i,s)));this.totals[r]=l,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:pe(()=>{const r=ne(bt(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),is(t[s])}))}}class wj extends Zc{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const o=this.history[i];for(let l=0;l<o.length;++l)if(typeof o[l]!="number"){const u=o[l];e.push(u.data()),t.push(i),s.push(l)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class Aj extends Zc{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||bL,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=bj),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");q1(this.yieldEvery)&&(this.maybeWait=VK(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await Oo(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Oo(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await Oo(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Oo(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await Oo(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):q1(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Oo(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Oo(e),await this.trainEnd(e))}}function m4(n,e){return n==null&&(n={}),n instanceof Zc?[n]:Array.isArray(n)&&n[0]instanceof Zc?n:ln(n).map(s=>new Aj(s,e))}class Pr{constructor(){}static registerCallbackConstructor(e,t){W(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Pr.checkForDuplicate(t),Pr.constructors[e]==null&&(Pr.constructors[e]=[]),Pr.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Pr.constructors)Pr.constructors[+t].forEach(r=>{if(r===e)throw new oe("Duplicate callback constructor.")})}static clear(){Pr.constructors={}}static createCallbacks(e){const t=[];for(const s in Pr.constructors){const r=+s;e>=r&&t.push(...Pr.constructors[r])}return t.map(s=>new s)}}Pr.constructors={};function g4(n,e,t,s,r,i,o,l,u){const d=new wj,h=[new Nj,...Pr.createCallbacks(e)];n!=null&&h.push(...n),h.push(d);const f=new xj(h);return f.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:e,doValidation:l,metrics:u}),{callbackList:f,history:d}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pa(n,e={},t=!1){return Ih(n,Mr.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qp(n,e){return pe(()=>{n.dtype!=="float32"&&(n=rt(n,"float32"));const t=ft(bh(n),e,!0),s=Ou(t.shape,Kn()),r=ys(Na(t,s));return bt(n,r)})}function og(n,e){return pe(()=>On(bh(ut(e,n)),-1))}function rx(n,e){return pe(()=>On(Gn(ut(e,n)),-1))}function ix(n,e){return pe(()=>{const t=ut(n,e),s=hr(Gn(n),Kn(),Number.MAX_VALUE),r=Gn(bt(t,s));return ne(100,On(r,-1))})}function Tj(n,e){return pe(()=>{const t=hr(e,Kn(),Number.MAX_VALUE),s=Er(Me(1,t)),r=hr(n,Kn(),Number.MAX_VALUE),i=Er(Me(1,r));return On(bh(ut(s,i)),-1)})}function Sj(n,e){return pe(()=>{const t=Na(0,ut(1,ne(n,e)));return On(bh(t),-1)})}function vj(n,e){return pe(()=>{const t=Na(0,ut(1,ne(n,e)));return On(t,-1)})}function $j(n,e){return pe(()=>{const t=ft(ne(n,e),-1),s=Yr(ne(ut(1,n),e),-1);return Na(0,Me(1,ut(s,t)))})}function _j(n,e){return pe(()=>{const t=Math.log(2),s=ut(e,n),r=ut(Me(s,Ru(ne(-2,s))),t);return On(r,-1)})}function Qc(n,e,t=!1){return pe(()=>{if(t)e=Km(e);else{const s=ft(e,e.shape.length-1,!0);e=bt(e,s)}return e=hr(e,Kn(),1-Kn()),wn(ft(ne(rt(n,"float32"),Er(e)),e.shape.length-1))})}function Jp(n,e,t=!1){return pe(()=>{const s=rt(hh(jK(n)),"int32");e=hr(e,Kn(),1-Kn());const r=e.shape,i=ie(B2(s,r[r.length-1]),r);return Qc(i,e,t)})}function Dj(n,e){if(!Kt(n.shape,e.shape))throw new oe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return pe(()=>{const t=Xi(e),s=wn(Gn(e));return Me(ut(t,ne(e,n)),Pm(pr(s)))})}function lg(n,e){return pe(()=>{let t;return t=hr(e,Kn(),1-Kn()),t=Er(bt(t,ut(1,t))),On(Dj(n,t),-1)})}function Ej(n,e){return pe(()=>{const t=hr(n,Kn(),1),s=hr(e,Kn(),1);return ft(ne(n,Er(bt(t,s))),-1)})}function kj(n,e){return pe(()=>{const t=Er(Me(Kn(),e));return On(ut(e,ne(n,t)),-1)})}function I4(n,e){return pe(()=>{const t=Qp(n,-1),s=Qp(e,-1),r=ne(t,s);return wn(ft(r,-1))})}const ef={meanSquaredError:og,meanAbsoluteError:rx,meanAbsolutePercentageError:ix,meanSquaredLogarithmicError:Tj,squaredHinge:Sj,hinge:vj,categoricalHinge:$j,logcosh:_j,categoricalCrossentropy:Qc,sparseCategoricalCrossentropy:Jp,binaryCrossentropy:lg,kullbackLeiblerDivergence:Ej,poisson:kj,cosineProximity:I4};function I1(n){if(typeof n=="string"){if(n in ef)return ef[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new oe(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function y4(n,e){return pe(()=>{const t=ne(.5,kr(e)),s=Hi(xr(e,t),n.dtype);return On(yi(n,s),-1)})}function b4(n,e){return pe(()=>Hi(yi(Iu(n,-1),Iu(e,-1)),"float32"))}function Cj(n,e){return pe(()=>rt(ft(Ki(yi(n,1),yi(e,1))),"float32"))}function Lj(n,e){return pe(()=>rt(ft(Ki(yi(n,0),yi(e,1))),"float32"))}function Oj(n,e){return pe(()=>{const t=Cj(n,e),s=Lj(n,e),r=Me(t,s);return rt(vs(xr(r,0),bt(t,r),0),"float32")})}function Rj(n,e){return lg(n,e)}function Vj(n,e){return n.rank===e.rank&&(n=Tl(n,[n.rank-1])),e=Iu(e,-1),e.dtype!==n.dtype&&(e=rt(e,n.dtype)),rt(yi(n,e),"float32")}const Pj=og,Fj=og,zj=rx,Mj=rx,Wj=ix,Bj=ix,x4=Qc,Hj=I4,N4=Jp,tf={binaryAccuracy:y4,categoricalAccuracy:b4,precision:Oj,categoricalCrossentropy:x4,sparseCategoricalCrossentropy:N4,mse:Pj,MSE:Fj,mae:zj,MAE:Mj,mape:Wj,MAPE:Bj,cosine:Hj};function Uj(n){if(typeof n=="string"&&n in tf)return tf[n];if(typeof n!="string"&&n!=null)return n;throw new oe(`Unknown metric ${n}`)}function ap(n){if(Oi(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(ef))if(ef[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(tf))if(tf[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gj(n){const e={Adagrad:()=>Wl.adagrad(.01),Adadelta:()=>Wl.adadelta(1,.95,Kn()),Adam:()=>Wl.adam(.001,.9,.999,Kn()),Adamax:()=>Wl.adamax(.002,.9,.999,Kn(),0),RMSProp:()=>Wl.rmsprop(.001,.9,0,Kn()),SGD:()=>Wl.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new oe(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const m3=1*1024*1024;function g3(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!NI(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>m3&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${m3}.`)}}function NI(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!NI(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!NI(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qj(n,e,t,s=console.log){const r=jj(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(h=>Math.floor(e*h)));let o;if(!r){i.push("Receives inputs"),o=[];for(const h in n.nodesByDepth)o.push(...n.nodesByDepth[h])}s("_".repeat(e)),nf(i,t,s),s("=".repeat(e));const l=n.layers;for(let h=0;h<l.length;++h)r?Yj(l[h],t,s):Xj(l[h],t,o,s),s((h===l.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const u=Kj(n),d=Yp(n.nonTrainableWeights);s(`Total params: ${u+d}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${d}`),s("_".repeat(e))}function Kj(n){let e;return n.collectedTrainableWeights!=null?e=Yp(n.collectedTrainableWeights):e=Yp(n.trainableWeights),e}function jj(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function nf(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function Yj(n,e,t){let s,r;try{r=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),l=[`${i} (${o})`,r,s,n.countParams().toString()];nf(l,e,t)}function Xj(n,e,t,s){let r,i;try{i=n.inboundNodes.map(f=>JSON.stringify(f.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const f of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(f)===-1))for(let m=0;m<f.inboundLayers.length;++m){const I=f.inboundLayers[m].name,y=f.nodeIndices[m],N=f.tensorIndices[m];o.push(`${I}[${y}][${N}]`)}const l=n.name,u=n.getClassName(),d=o.length===0?"":o[0],h=[`${l} (${u})`,i,r,n.countParams().toString(),d];nf(h,e,s);for(let f=1;f<o.length;++f)nf(["","","","",o[f]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function w4(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function wI(n,e){if(n===null)return null;if(typeof n=="string")return Mo(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];w4(e,r,i)?t.push(i):t.push(wI(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=Mo(s);t[i]=wI(r,i)}}return t}}function AI(n,e){if(n==null)return null;if(typeof n=="string")return ra(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];w4(e,r,i)?t.push(i):t.push(AI(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=ra(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=AI(r,s)}return t}}/** @license See the LICENSE file. */const A4="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Zj=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class ui extends Ht{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const v=this.getClassName().toLowerCase();this.name=rg(v)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Ha(this.inputs).length!==this.inputs.length)throw new oe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);Ha(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const v of this.outputs){const E=v.sourceLayer,_=v.nodeIndex,L=v.tensorIndex;this.outputLayers.push(E),this.outputLayersNodeIndices.push(_),this.outputLayersTensorIndices.push(L)}for(const v of this.inputs){const E=v.sourceLayer,_=v.nodeIndex,L=v.tensorIndex;Oi(_===0,"input layer has >1 nodes"),Oi(L===0,"input layer has >1 tensors"),this.inputLayers.push(E),this.inputLayersNodeIndices.push(_),this.inputLayersTensorIndices.push(L)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){const E=this.inputLayers[v];if(!(E instanceof Nh))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${v} (0-based) originates from layer type ${E.getClassName()}.`);this.inputNames.push(E.name),this.feedInputShapes.push(E.batchInputShape),this.feedInputNames.push(E.name)}for(const v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);const t={},s={},r={},i={},o={},l=[],u=(v,E,_,L,P,B)=>{(L==null||P==null||B==null)&&(L=v.sourceLayer,P=v.nodeIndex,B=v.tensorIndex);const U=L.inboundNodes[P];if(_.indexOf(U)!==-1)throw new Gr(`The tensor ${v.name} at layer "${L.name}" is part of a cycle.`);if(E.indexOf(U)!==-1)return;this.containerNodes.add(ui.nodeKey(L,P)),L.id in o||(o[L.id]=Object.keys(o).length),_.indexOf(U)===-1&&_.push(U);const Z=U.inboundLayers.length;for(let Y=0;Y<Z;Y++){const ae=U.inputTensors[Y],de=U.inboundLayers[Y],ce=U.nodeIndices[Y],Ie=U.tensorIndices[Y];u(ae,E,_,de,ce,Ie)}for(E.push(U);_.indexOf(U)>=0;)_.splice(_.indexOf(U),1);l.push(U)},d=[],h=[];for(const v of this.outputs)u(v,d,h);const f=l.slice().reverse();for(const v of f){s[v.id]=v,v.id in t||(t[v.id]=0);let E=t[v.id];const _=r[v.outboundLayer.id]==null?0:r[v.outboundLayer.id];E=Math.max(E,_),r[v.outboundLayer.id]=E,i[v.outboundLayer.id]=v.outboundLayer,t[v.id]=E;for(let L=0;L<v.inboundLayers.length;L++){const P=v.inboundLayers[L],B=v.nodeIndices[L],U=P.inboundNodes[B],Z=t[U.id]==null?0:t[U.id];t[U.id]=Math.max(E+1,Z),s[U.id]=U}}const m={};for(const v in t){const E=t[v];E in m||(m[E]=[]),m[E].push(s[v])}const I={};for(const v in r){const E=r[v];E in I||(I[E]=[]),I[E].push(i[v])}let y=Object.keys(I).map(v=>parseInt(v,10)).sort(sp);this.layers=[];for(const v of y){const E=I[v];E.sort((_,L)=>{const P=o[_.id],B=o[L.id];return P<B?-1:P>B?1:0});for(const _ of E)_ instanceof ui&&this.internalContainerRefs.push(_),this.layers.push(_)}this.layersByDepth=I,y=Object.keys(m).map(v=>parseInt(v,10)).sort(sp);const N=this.inputs.slice(),w=[];for(const v of y)for(const E of m[v]){const _=E.outboundLayer;if(_!=null){for(const L of E.inputTensors)if(N.indexOf(L)===-1)throw new Gr(`Graph disconnected: cannot obtain value for tensor ${L} at layer "${_.name}". The following previous layers were accessed without issue: ${w}`);for(const L of E.outputTensors)N.push(L);w.push(_.name)}}this.nodesByDepth=m;const T=this.layers.map(v=>v.name);for(const v of T){const E=T.filter(_=>_===v).length;if(E!==1)throw new Gr(`The name "${v}" is used ${E} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(T))}this.outboundNodes=[],this.inboundNodes=[],new ag({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new oe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=Zj(e);i&&this.parseWeights(e);for(const l of this.layers)for(const[u,d]of l.weights.entries()){const h=i?`${d.name.split("/").slice(0,-1).join("/")+"/"}${u}`:d.originalName;if(s[h]!=null)throw new oe(`Duplicate weight name: ${h}`);s[h]=d,r++}const o=[];for(const l in e){let u=l;if(s[l]==null){const d=l.split("/");u=d.slice(0,-2).concat([d[d.length-1]]).join("/")}if(s[u]!=null)o.push([s[u],e[l]]);else if(t)throw new oe(`Provided weight data has no target variable: ${l}`);delete s[u]}if(t){const l=[];for(const u in s)l.push(u);if(l.length>0)throw new oe(`${l.length} of ${r} weights are not set: ${l}`)}nx(o)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${A4}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=AI(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return pe(()=>{e=ln(e);const s=new Fa;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Nc(this.outputs,s,t)})}computeMask(e,t){return pe(()=>{e=ln(e);let s;return t==null?s=cl(null,e.length):s=ln(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=jp(e);if(t.length!==this.inputLayers.length)throw new oe(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let l=0;l<t.length;l++){const u=this.inputLayers[l],d=t[l],h=u.name+"_0_0";s[h]=d}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(sp);if(r.length>1)for(const l of r){const u=this.nodesByDepth[l];for(const d of u){const h=d.outboundLayer;if(this.inputLayers.map(N=>N.id).indexOf(h.id)!==-1)continue;const f=[];for(let N=0;N<d.inboundLayers.length;N++){const w=d.inboundLayers[N],T=d.nodeIndices[N],v=d.tensorIndices[N],E=`${w.name}_${T}_${v}`,_=s[E];f.push(_)}const m=h.computeOutputShape(Xs(f)),I=jp(m),y=h.inboundNodes.indexOf(d);for(let N=0;N<I.length;N++){const w=`${h.name}_${y}_${N}`;s[w]=I[N]}}}const i=[],o=[];for(let l=0;l<this.outputLayers.length;l++){const u=this.outputLayers[l],d=this.outputLayersNodeIndices[l],h=this.outputLayersTensorIndices[l],f=`${u.name}_${d}_${h}`;o.push(f)}for(let l=0;l<o.length;l++){const u=o[l];Oi(u in s),i.push(s[u])}return Xs(i)}runInternalGraph(e,t){t==null&&(t=cl(null,e.length));const s={};for(let u=0;u<this.inputs.length;++u){const d=this.inputs[u],h=e[u],f=t[u];s[d.id]=[h,f]}const r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(sp);for(const u of r){const d=this.nodesByDepth[u];for(const h of d){const f=h.outboundLayer,m=h.inputTensors,I=h.outputTensors,y=new Array;for(const N of m)N.id in s&&y.push(s[N.id]);if(y.length===m.length){let N={},w,T,v,E;if(h.callArgs!=null&&(N=h.callArgs),y.length===1){const[_,L]=y[0];N.mask==null&&(N.mask=L),v=ln(f.call(_,N)),E=ln(f.computeMask(_,L)),w=[_],T=[L]}else w=y.map(_=>_[0]),T=y.map(_=>_[1]),N.mask==null&&(N.mask=T),v=ln(f.call(w,N)),E=ln(f.computeMask(w,T));if(f.activityRegularizer)throw new Vt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let _=0;_<I.length;++_){const L=I[_],P=v[_],B=E[_];s[L.id]=[P,B]}}}}const i=[],o=[],l=[];for(const u of this.outputs){Oi(u.id in s,`Could not compute output ${u.name} : ${u.id}`);const[d,h]=s[u.id];l.push(d.shape),i.push(d),o.push(h)}return[i,o,l]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof ui?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=ui.nodeKey(r,i);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new oe("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new oe(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new oe(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return pe(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=ui.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const l=o.getClassName(),u=o.getConfig(),d=[];for(let f=0;f<o.inboundNodes.length;f++){const m=o.inboundNodes[f],I=ui.nodeKey(o,f);let y={};if(this.containerNodes.has(I)){if(m.callArgs)try{JSON.stringify(m.callArgs),y=m.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),y={}}if(m.inboundLayers.length>0){const N=[];for(let w=0;w<m.inboundLayers.length;w++){const T=m.inboundLayers[w],v=m.nodeIndices[w],E=m.tensorIndices[w],_=ui.nodeKey(T,v);let L=t[_];L==null&&(L=0),N.push([T.name,L,E,y])}d.push(N)}}}const h={};h.name=o.name,h.className=l,h.config=u,h.inboundNodes=d,s.push(h)}e.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const l=this.inputLayers[o],u=this.inputLayersNodeIndices[o],d=ui.nodeKey(l,u);if(!this.containerNodes.has(d))continue;let h=t[d];h==null&&(h=0);const f=this.inputLayersTensorIndices[o];r.push([l.name,h,f])}e.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],d=ui.nodeKey(l,u);if(!this.containerNodes.has(d))continue;let h=t[d];h==null&&(h=0);const f=this.outputLayersTensorIndices[o];i.push([l.name,h,f])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},o={};function l(w,T){w.name in o?o[w.name].push(T):o[w.name]=[T]}function u(w,T){const v=[];let E;for(const _ of T){const L=_[0],P=_[1],B=_[2];if(E=_[3]==null?{}:_[3],!(L in i)){l(w,T);return}const U=i[L];if(U.inboundNodes.length<=P){l(w,T);return}const Z=U.inboundNodes[P];v.push(Z.outputTensors[B])}v.length>0&&w.apply(Xs(v),E)}function d(w){const T=w.name,v=pa(w,t.customObjects!=null?t.customObjects:{});v.setFastWeightInitDuringBuild(r),i[T]=v,w.inboundNodes.forEach(_=>{if(!(_ instanceof Array))throw new oe(`Corrupted configuration, expected array for nodeData: ${_}`);l(v,_)})}const h=t.name,f=t.layers;for(const w of f)d(w);for(;!RK(o);)for(const w of f){const T=i[w.name];if(T.name in o){const v=o[T.name];delete o[T.name];for(const E of v)u(T,E)}}const m=[],I=[],y=t.inputLayers;for(const w of y){const T=w[0],v=w[1],E=w[2];Oi(T in i);const L=i[T].inboundNodes[v].outputTensors;m.push(L[E])}const N=t.outputLayers;for(const w of N){const T=w[0],v=w[1],E=w[2];Oi(T in i);const L=i[T].inboundNodes[v].outputTensors;I.push(L[E])}return new e({inputs:m,outputs:I,name:h})}get stateful(){if(this._stateful)throw new oe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){pe(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qj(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function T4(n,e){return Qj(n,e,"classWeight")}async function S4(n,e,t,s){if(e!=null||s!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const r=pe(()=>{if(n.shape.length===1)return ha(n);if(n.shape.length===2){if(n.shape[1]>1)return Iu(n,1);if(n.shape[1]===1)return ie(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Ft(r);const o=[];return i.forEach(l=>{if(t[l]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${l} exists in the data but not in classWeight`);o.push(t[l])}),Ms(o,"float32")}else return null}function Jj(n,e){return ne(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const eY=32;function v4(n,e){let t,s;const r=e;t=r.xs,s=r.ys,W(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=I3("input",n.inputNames,t),o=I3("output",n.outputNames,s),l=i[0].shape[0];W(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),W(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let u=0;u<i.length;u++)W(i[u].shape[0]===l,()=>`Batch size mismatch: input ${n.inputNames[u]} has ${i[u].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);for(let u=0;u<o.length;u++)W(o[u].shape[0]===l,()=>`Batch size mismatch: output ${n.outputNames[u]} has ${o[u].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function I3(n,e,t){if(t instanceof $n)return[t];if(Array.isArray(t))return W(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new oe(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function tY(n){if(n.length===3)throw new Vt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function nY(n,e,t){const s=t.batchesPerEpoch!=null;if(W(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),W(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),W(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),W(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),W(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,o;if(r)if(y3(t.validationData))W(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const w=tY(t.validationData);i=w.xs,o=w.ys}const l=n.makeTrainFunction(),u=n.getDedupedMetricsNames();let d;r?d=u.slice().concat(u.map(w=>"val_"+w)):d=u.slice();const h=m4(t.callbacks,t.yieldEvery),f=t.verbose==null?1:t.verbose,{callbackList:m,history:I}=g4(h,f,t.epochs,null,null,sY(e,t),null,r,d);m.setModel(n),n.history=I,await m.onTrainBegin(),n.stopTraining_=!1;let y=t.initialEpoch==null?0:t.initialEpoch,N=await e.iterator();for(;y<t.epochs;){const w={};await m.onEpochBegin(y);let T=0,v=0;for(s||(N=await e.iterator());!s||T<t.batchesPerEpoch;){const E=await N.next();if(s&&E.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${T} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(E.value!=null){const{xs:_,ys:L}=v4(n,E.value),P={};P.batch=v,P.size=_[0].shape[0],await m.onBatchBegin(v,P);const B=[];if(t.classWeight!=null){const Y=T4(t.classWeight,n.outputNames);for(let ae=0;ae<Y.length;++ae)B.push(await S4(L[ae],null,Y[ae]))}const U=_.concat(L).concat(B),Z=l(U);Ft(U);for(let Y=0;Y<u.length;++Y){const ae=u[Y],de=Z[Y];P[ae]=de,is(de)}await m.onBatchEnd(v,P),f4(P),v++,T++}if(s?T>=t.batchesPerEpoch:E.done){if(r){let _;y3(t.validationData)?_=ln(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):_=ln(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?eY:t.validationBatchSize,verbose:0}));for(let L=0;L<n.metricsNames.length;++L)w[`val_${n.metricsNames[L]}`]=_[L]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(y,w),y++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function sY(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function y3(n){return typeof n.iterator=="function"}function rY(n){return typeof n.next=="function"}async function iY(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new Vt("Verbose mode is not implemented yet.");W(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=rY(e)?e:await e.iterator();let l=0,u=0;for(;!s||u<t.batches;){const d=await o.next();if(i=pe(()=>{if(d.value){const{xs:h,ys:f}=v4(n,d.value),m=h.concat(f),I=pe(()=>r(m));if(Ft(m),u===0)for(let N=0;N<I.length;++N)i.push(At(0));const y=m[0].shape[0];for(let N=0;N<I.length;++N){const w=I[N],T=i[N];i[N]=pe(()=>Me(i[N],ne(y,w))),u>0&&Ft(T)}Ft(I),l+=y,++u}return i}),d.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let d=0;d<i.length;++d){const h=i[d];i[d]=bt(i[d],l),Ft(h)}return Xs(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function y1(n){W(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function dc(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Xo(s,e,t-e)):Xo(n,e,t-e)}function TI(n,e){return pe(()=>n==null?null:Array.isArray(n)?n.map(t=>TI(t,e)):e4(n,e.dtype==="int32"?e:rt(e,"int32")))}function b1(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function $4(n){const e=[];n instanceof $n&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(yh(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function li(n,e){if(n==null)return;const t=[];if(e instanceof $n)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof $n)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aY(n){return n instanceof $n}function SI(n){return Array.isArray(n)}function b3(n){return!aY(n)&&!SI(n)}function x3(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(SI(n)&&n.length>0)o=!0;else if(b3(n)){for(const l in n)if(n.hasOwnProperty(l)){o=!0;break}}else o=!0;if(o)throw new oe(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(b3(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new oe(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if(SI(n)){if(n=n,n.length!==e.length)throw new oe(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new oe(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=$4(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const l=i[o];if(l.shape.length!==t[o].length)throw new oe(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${l.shape}`);for(let u=0;u<t[o].length;++u){if(u===0&&!s)continue;const d=l.shape[u],h=t[o][u];if(h!=null&&h>=0&&d!==h)throw new oe(`${r} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${r} received an input with ${l.shape[0]} examples, each with shape [${l.shape.slice(1,l.shape.length)}] (tensor shape [${l.shape}])`)}}return i}function oY(n,e,t){const s=Ha(n.map(i=>i.shape[0]));s.sort();const r=Ha(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new oe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new oe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!Kt(s,r))throw new oe(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function lY(n,e,t){const s=[og,lg,Qc];for(let r=0;r<n.length;++r){const i=n[r],o=e[r],l=t[r];if(o!=null){if(o===Qc&&i.shape[i.shape.length-1]===1)throw new oe(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const u=i.shape.slice(1),d=l.slice(1);for(let h=0;h<u.length;++h){const f=u[h],m=d[h];if(m!=null&&f!==m)throw new oe(`A target Tensor with shape ${i.shape} was passed for an output of shape ${l}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function N3(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new oe(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new oe(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const l=i[o];if(l.shape.length!==t[o].length)throw new oe(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(l.shape)}`);for(let u=0;u<t[o].length;++u){if(u===0&&!s)continue;const d=l.shape[u],h=t[o][u];if(h!=null&&h!==d)throw new oe(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(l.shape)}.`)}}}function uY(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const cY="layers-model";class cu extends ui{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new oe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");qj(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Gj(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof po))throw new oe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new oe(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(I1(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new oe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(l=>I1(l))}else{const o=I1(e.loss);this.outputs.forEach(l=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const l=this.internalOutputShapes[o],u=this.outputNames[o];this.feedOutputNames.push(u),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Yo("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([l,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=uY(e.metrics,this.outputNames),i=(o,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[o]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,o])};Yo("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=r[o];(d=>{const h="";let f,m,I;for(const y of d){if(typeof y=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(y)!==-1){const w=this.internalOutputShapes[o];w[w.length-1]===1||this.lossFunctions[o]===lg?["accuracy","acc"].indexOf(y)!==-1?m=y4:["crossentropy","ce"].indexOf(y)!==-1&&(m=Rj):this.lossFunctions[o]===Jp?["accuracy","acc"].indexOf(y)!==-1?m=Vj:["crossentropy","ce"].indexOf(y)!==-1&&(m=N4):["accuracy","acc"].indexOf(y)!==-1?m=b4:["crossentropy","ce"].indexOf(y)!==-1&&(m=x4);let T;["accuracy","acc"].indexOf(y)!==-1?T="acc":["crossentropy","ce"].indexOf(y)!==-1&&(T="ce"),I=m,f=h+T}else I=Uj(y),f=h+ap(y);let N;Yo(f,()=>{N=I}),i(o,f,N)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;y1(r);const i=!0,o=this.standardizeUserDataXY(e,t,i,r);try{const l=o[0].concat(o[1]);this.makeTestFunction();const u=this.testFunction,d=this.testLoop(u,l,r,s.verbose,s.steps);return Xs(d)}finally{li(o[0],e),li(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),iY(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new oe(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new oe(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new oe("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),o=new Fa;if(e instanceof $n&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new oe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)o.add(this.inputs[u],e[u])}else for(const u of this.inputs){const d=e[u.name];if(d==null)throw new oe(`No value is provided for the model's input ${u.name}`);o.add(u,d)}const l=Nc(i,o);return s?l:l[0]}retrieveSymbolicTensors(e){const t=cl(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(l=>l.name);for(let l=0;l<e.length;++l){const u=o.indexOf(e[l]);if(u!==-1&&(t[l]=i[u],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,o)=>{i==null&&r.push(e[o])}),new oe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return pe(()=>{const r=this.checkNumSamples(e);if(s)throw new Vt("Verbose predictLoop() is not implemented yet.");const i=b1(r,t),o=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)pe(()=>{const d=i[l][0],h=i[l][1],f=dc(e,d,h),m=[];if(Array.isArray(f))for(let y=0;y<f.length;++y)m.push({key:this.inputs[y],value:f[y]});else m.push({key:this.inputs[0],value:f});const I=new Fa(m);return Nc(this.outputs,I)}).forEach((d,h)=>o[h].push(d));return Xs(o.map(l=>Un(l,0)))})}predict(e,t={}){const s=$4(e);N3(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return y1(r),this.predictLoop(s,r)}finally{li(s,e)}}predictOnBatch(e){N3(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new Gr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const l=this.feedOutputShapes[o];this.feedLossFns[o]===Jp?i.push(l.slice(0,l.length-1).concat([1])):i.push(l)}if(e=x3(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=x3(t,this.feedOutputNames,i,!1,"target"),oY(e,t),lY(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new oe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,o){const[l,u]=this.standardizeUserDataXY(e,t,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let d=null;if(r!=null){const h=T4(r,this.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(await S4(u[f],null,h[f]))}return[l,u,d]}testLoop(e,t,s,r=0,i){return pe(()=>{const o=this.checkNumSamples(t,s,i,"steps"),l=[];if(r>0)throw new Vt("Verbose mode is not implemented yet.");if(i!=null)throw new Vt("steps mode in testLoop() is not implemented yet");{const u=b1(o,s),d=Ms(bi(0,o));for(let h=0;h<u.length;++h){const f=u[h][0],m=u[h][1],I=Xo(d,f,m-f),y=TI(t,I),N=e(y);if(h===0)for(let w=0;w<N.length;++w)l.push(At(0));for(let w=0;w<N.length;++w){const T=N[w];l[w]=Me(l[w],ne(m-f,T))}}for(let h=0;h<l.length;++h)l[h]=bt(l[h],o)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(i3(e,r)>1){const o=i3(e.slice(0,s),r);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],l=()=>{const f=[];for(let N=0;N<this.inputs.length;++N)f.push({key:this.inputs[N],value:s[N]});const m=new Fa(f),I=Nc(this.outputs,m,{training:!0});let y;for(let N=0;N<this.lossFunctions.length;++N){const w=this.lossFunctions[N];let T=w(r[N],I[N]);i[N]!=null&&(T=Jj(T,i[N]));const v=On(T);t.push(v),N===0?y=T:y=Me(y,T)}for(let N=0;N<this.metricsTensors.length;++N){let w;if(this.outputs.length>1&&N<this.outputs.length)w=t[N];else{const T=this.metricsTensors[N][0],v=this.metricsTensors[N][1];w=On(T(r[v],I[v]))}is(w),o.push(w)}return y=On(y),this.calculateLosses().forEach(N=>{y=Me(y,N)}),y},u=this.collectedTrainableWeights.map(f=>f.read()),d=!0;return[this.optimizer_.minimize(l,d,u)].concat(o)}}makeTestFunction(){this.testFunction=e=>pe(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let d=0;d<this.inputs.length;++d)o.push({key:this.inputs[d],value:r[d]});const l=new Fa(o),u=Nc(this.outputs,l);for(let d=0;d<this.lossFunctions.length;++d){const h=this.lossFunctions[d],f=On(h(i[d],u[d]));d===0?s=f:s=Me(s,f),t.push(s)}for(let d=0;d<this.metricsTensors.length;++d){const h=this.metricsTensors[d][0],f=this.metricsTensors[d][1],m=On(h(i[f],u[f]));t.push(m)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,l,u,d,h,f,m;try{const I=s.batchSize==null?32:s.batchSize;y1(I);const y=!1,N=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,y,I);r=N[0],i=N[1],m=N[2];let w=!1,T;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)u=s.validationData[0],d=s.validationData[1];else throw s.validationData.length===3?new Vt("validationData including sample weights is not supported yet."):new oe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const Z=!0,Y=await this.standardizeUserData(u,d,null,null,Z,I);h=Y[0],f=Y[1],T=h.concat(f)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const Z=Math.floor(r[0].shape[0]*(1-s.validationSplit)),Y=r[0].shape[0];h=dc(r,Z,Y),o=r,r=dc(r,0,Z),f=dc(i,Z,Y),l=i,i=dc(i,0,Z),T=h.concat(f)}else s.validationSteps!=null&&(w=!0);const v=r.concat(i).concat(m);this.checkTrainableWeightsConsistency();const E=this.makeTrainFunction(),_=this.getDedupedMetricsNames();let L,P;w?(this.makeTestFunction(),L=this.testFunction,P=_.slice().concat(_.map(Z=>"val_"+Z))):(L=null,T=[],P=_.slice());const B=m4(s.callbacks,s.yieldEvery);return await this.fitLoop(E,v,_,I,s.epochs,s.verbose,B,L,T,s.shuffle,P,s.initialEpoch,null,null)}finally{this.isTraining=!1,li(r,e),li(i,t),li(o,e),li(l,t),li(h,u),li(f,d),m!=null&&Ft(m)}}async fitLoop(e,t,s,r,i,o,l,u,d,h,f,m,I,y){r==null&&(r=32),i==null&&(i=1),h==null&&(h=!0),m==null&&(m=0);let N=!1;if(u!=null&&d!=null&&(N=!0),y!=null&&(N=!0,I==null))throw new oe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(t,r,I,"steps_per_epoch");let T;w!=null&&(T=bi(0,w)),o==null&&(o=1);const{callbackList:v,history:E}=g4(l,o,i,m,w,I,r,N,f);v.setModel(this),this.history=E,await v.onTrainBegin(),this.stopTraining_=!1;for(let _=m;_<i;++_){await v.onEpochBegin(_);const L={};if(I!=null)throw new Vt("stepsPerEpoch mode is not implemented yet.");{if(h==="batch")throw new Vt("batch shuffling is not implemneted yet");h&&nM(T);const P=Ms(T),B=b1(w,r);for(let U=0;U<B.length;++U){const Z={};if(await v.onBatchBegin(U,Z),pe(()=>{const Y=B[U][0],ae=B[U][1],de=Xo(P,Y,ae-Y);Z.batch=U,Z.size=ae-Y;const ce=TI(t,de),Ie=e(ce);for(let be=0;be<s.length;++be){const ye=s[be],we=Ie[be];Z[ye]=we,is(we)}if(U===B.length-1&&N){const be=this.testLoop(u,d,r);for(let ye=0;ye<s.length;++ye){const we=s[ye],fe=be[ye];is(fe),L["val_"+we]=fe}}}),await v.onBatchEnd(U,Z),f4(Z),this.stopTraining_)break}P.dispose()}if(await v.onEpochEnd(_,L),this.stopTraining_)break}return await v.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return nY(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],l=this.makeTrainFunction()(r.concat(i)),u=[];for(const d of l){const h=await d.data();u.push(h[0])}return Ft(l),li(s[0],e),li(s[1],t),Xs(u)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||t.push({name:r[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=rI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-rI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ra(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ra(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=ra(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ra(ap(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ra(ap(e)));{const e={};for(const t in this.metrics)e[t]=ra(ap(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=wI(e.optimizer_config),s=pa(t);let r;if(typeof e.loss=="string")r=Mo(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>Mo(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=Mo(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>Mo(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=Mo(e.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const d=Fk(e);if(d.length===0)throw new oe(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new oe(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(e.save==null)throw new oe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await iI(this.getNamedWeights(t)),r=!1,i=null,l={modelTopology:this.toJSON(i,r),format:cY,generatedBy:`TensorFlow.js tfjs-layers v${A4}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();const d="optimizer",{data:h,specs:f}=await iI(await this.optimizer.getWeights(),d);s.specs.push(...f),s.data=Rk([s.data,h])}return this.userDefinedMetadata!=null&&(g3(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=s.data,l.weightSpecs=s.specs,e.save(l)}setUserDefinedMetadata(e){g3(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}cu.className="Model";He(cu);class _4 extends cu{}_4.className="Functional";He(_4);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Jc extends cu{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:rg("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new oe(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Jc||e instanceof cu;let s;if(t){if(s=e,s.outputs.length!==1)throw new oe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new oe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new oe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=hj({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new oe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new oe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=u4(this.outputs[0])}this.inboundNodes=[],new ag({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:cl(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(tn(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new cu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new oe("Legacy serialization format not supported yet.");i=t}else W(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const l=new e(o);if(!(l instanceof Jc))throw new Vt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of i){const h=pa(u,void 0,r);r&&h.setFastWeightInitDuringBuild(!0),l.add(h)}return l}set stopTraining(e){if(this.model==null)throw new oe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new oe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Jc.className="Sequential";He(Jc);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let _s=class extends Fu{getConfig(){return{}}};class D4 extends _s{apply(e,t=1){return XK(e,t)}}D4.className="elu";He(D4);class E4 extends _s{apply(e){return eb(e)}}E4.className="selu";He(E4);class k4 extends _s{apply(e){return Xi(e)}}k4.className="relu";He(k4);class C4 extends _s{apply(e){return pe(()=>ll(6,Xi(e)))}}C4.className="relu6";He(C4);class L4 extends _s{apply(e){return e}}L4.className="linear";He(L4);class O4 extends _s{apply(e){return Wi(e)}}O4.className="sigmoid";He(O4);class R4 extends _s{apply(e){return QK(e)}}R4.className="hardSigmoid";He(R4);class V4 extends _s{apply(e){return Ru(e)}}V4.className="softplus";He(V4);class P4 extends _s{apply(e){return ZK(e)}}P4.className="softsign";He(P4);class F4 extends _s{apply(e){return ol(e)}}F4.className="tanh";He(F4);let ax=class extends _s{apply(e,t=-1){return Km(e,t)}};ax.className="softmax";He(ax);class z4 extends _s{apply(e,t=-1){return z2(e,t)}}z4.className="logSoftmax";He(z4);class M4 extends _s{apply(e){return pe(()=>pe(()=>{const t=Math.sqrt(2),s=ne(.5,Me(1,V2(bt(e,t))));return ne(e,s)}))}}M4.className="gelu";He(M4);class W4 extends _s{apply(e){return pe(()=>ne(.5,ne(e,Me(1,ol(ne(ys(bt(2,Math.PI)),Me(e,ne(.044715,fa(e,3)))))))))}}W4.className="gelu_new";He(W4);class B4 extends _s{apply(e){return pe(()=>ne(e,ol(Ru(e))))}}B4.className="mish";He(B4);class H4 extends _s{apply(e,t=1){return pe(()=>ne(Wi(ne(e,t)),e))}}H4.className="swish";He(H4);function Za(n){return n.getClassName()}function x1(n,e={}){return Ih(n,Mr.getMap().classNameMap,e,"activation")}function Qa(n){if(n==null){const e={};return e.className="linear",e.config={},x1(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},x1(e)}else return n instanceof _s?n:x1(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function dY(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class U4 extends Fu{}class G4 extends U4{constructor(e){super(),dY(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return pe(()=>{let t=qn([1]);return this.hasL1&&(t=Me(t,ft(ne(this.l1,Gn(e))))),this.hasL2&&(t=Me(t,ft(ne(this.l2,bh(e))))),ie(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}G4.className="L1L2";He(G4);const w3={l1l2:"L1L2"};function fn(n){return qb(n)}function A3(n,e={}){return Ih(n,Mr.getMap().classNameMap,e,"regularizer")}function Tn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in w3?w3[n]:n,config:{}};return A3(t)}else return n instanceof U4?n:A3(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class q4 extends Ht{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=$t(e);let s=Xi(e);return this.maxValue!=null&&(s=hr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}q4.className="ReLU";He(q4);class K4 extends Ht{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=$t(e);return Vm(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}K4.className="LeakyReLU";He(K4);class j4 extends Ht{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=An(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Tn(e.alphaRegularizer),this.alphaConstraint=Zn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new oe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=tn(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new jn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=$t(e),Hm(e,this.alpha.read())}getConfig(){const e={alphaInitializer:_n(this.alphaInitializer),alphaRegularizer:fn(this.alphaRegularizer),alphaConstraint:Xn(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}j4.className="PReLU";He(j4);let Y4=class extends Ht{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Vt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=$t(e);return ch(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Y4.className="ELU";He(Y4);class X4 extends Ht{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=$t(e);return ne(s,rt(xr(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}X4.className="ThresholdedReLU";He(X4);class Z4 extends Ht{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new ax().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return pe(()=>{let s=$t(e);const r=t.mask;if(r!=null){const i=ne(ut(ur(s.shape),rt(r,s.dtype)),At(-1e9));s=Me(s,i)}return this.axis instanceof Array?this.axis.length>1?pr(ut(s,Fm(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}Z4.className="Softmax";He(Z4);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function du(n,e,t){if(typeof n=="number")return cl(n,e);if(n.length!==e)throw new oe(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!qK(r))throw new oe(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Ii(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function Ri(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Xa([t-e,0]);else if(s==="same")n=n*e;else throw new oe(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ox(n,e){return pe(()=>(Mn(e),e==="channelsFirst"?Xt(n,[0,2,3,1]):n))}function Q4(n,e){return pe(()=>(Mn(e),e==="channelsFirst"?Xt(n,[0,2,3,4,1]):n))}function hY(n,e,t,s=1,r="valid",i,o=1){return pe(()=>{if(i==null&&(i=xi()),Mn(i),n.shape.length!==3)throw new oe(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new oe(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new oe(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=Xt(n,[0,2,1])),r==="causal")throw new Vt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let l=k2(n,e,s,r==="same"?"same":"valid","NWC",o);return t!=null&&(l=Si(l,t)),l})}function T3(n,e,t,s=[1,1],r="valid",i,o,l=null){return pe(()=>{if(i==null&&(i=xi()),Mn(i),n.rank!==3&&n.rank!==4)throw new oe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new oe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let u=ox(n,i);if(r==="causal")throw new Vt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=GC({x:u,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:l}),i==="channelsFirst"&&(u=Xt(u,[0,3,1,2])),u})}function pY(n,e,t,s=[1,1,1],r="valid",i,o){return pe(()=>{if(i==null&&(i=xi()),Mn(i),n.rank!==4&&n.rank!==5)throw new oe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new oe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let l=Q4(n,i);if(r==="causal")throw new Vt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return l=dC(l,e,s,r==="same"?"same":"valid","NDHWC",o),t!=null&&(l=Si(l,t)),i==="channelsFirst"&&(l=Xt(l,[0,4,1,2,3])),l})}class ug extends Ht{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",ug.verifyArgs(t),this.rank=e,as(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Vt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=du(t.kernelSize,e,"kernelSize"),this.strides=du(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Lr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Mn(this.dataFormat),this.activation=Qa(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=An(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Zn(t.biasConstraint),this.biasRegularizer=Tn(t.biasRegularizer),this.activityRegularizer=Tn(t.activityRegularizer),this.dilationRate=du(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new oe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new oe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new oe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Oi("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Kb(e.kernelSize,"number",1,3))throw new oe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Za(this.activation),useBias:this.useBias,biasInitializer:_n(this.biasInitializer),biasRegularizer:fn(this.biasRegularizer),activityRegularizer:fn(this.activityRegularizer),biasConstraint:Xn(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class zu extends ug{constructor(e,t){super(e,t),this.kernel=null,zu.verifyArgs(t),this.filters=t.filters,as(this.filters,"filters"),this.kernelInitializer=An(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Zn(t.kernelConstraint),this.kernelRegularizer=Tn(t.kernelRegularizer)}build(e){e=tn(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new oe(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return pe(()=>{e=$t(e);let s;const r=this.bias==null?null:this.bias.read(),i=jL(this.activation.getClassName());if(i!=null&&this.rank===2)s=T3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=hY(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=T3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=pY(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Vt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=tn(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const o=Ii(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:_n(this.kernelInitializer),kernelRegularizer:fn(this.kernelRegularizer),kernelConstraint:Xn(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new oe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Ah extends zu{constructor(e){super(2,e),Ah.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Kb(e.kernelSize,"number",1,2))throw new oe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Ah.className="Conv2D";He(Ah);class Th extends zu{constructor(e){super(3,e),Th.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new oe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Th.className="Conv3D";He(Th);class J4 extends Ah{constructor(e){if(super(e),this.inputSpec=[new jn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new oe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=tn(e),e.length!==4)throw new oe("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new oe("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new jn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return pe(()=>{let s=$t(e);if(s.shape.length!==4)throw new oe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,l;this.dataFormat==="channelsFirst"?(o=2,l=3):(o=1,l=2);const u=r[o],d=r[l],h=this.kernelSize[0],f=this.kernelSize[1],m=this.strides[0],I=this.strides[1],y=Ri(u,m,h,this.padding),N=Ri(d,I,f,this.padding),w=[i,y,N,this.filters];this.dataFormat!=="channelsLast"&&(s=Xt(s,[0,2,3,1]));let T=L2(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(T=Xt(T,[0,3,1,2])),this.bias!=null&&(T=Si(T,this.bias.read(),this.dataFormat)),this.activation!=null&&(T=this.activation.apply(T)),T})}computeOutputShape(e){e=tn(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],d=this.strides[1];return t[s]=this.filters,t[r]=Ri(t[r],u,o,this.padding),t[i]=Ri(t[i],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}J4.className="Conv2DTranspose";He(J4);class eO extends Th{constructor(e){if(super(e),this.inputSpec=[new jn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new oe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=tn(e),e.length!==5)throw new oe("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new oe("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new jn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return pe(()=>{let s=$t(e);if(s.shape.length!==5)throw new oe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,l,u;this.dataFormat==="channelsFirst"?(u=2,o=3,l=4):(u=1,o=2,l=3);const d=r[u],h=r[o],f=r[l],m=this.kernelSize[0],I=this.kernelSize[1],y=this.kernelSize[2],N=this.strides[0],w=this.strides[1],T=this.strides[2],v=Ri(d,N,m,this.padding),E=Ri(h,w,I,this.padding),_=Ri(f,T,y,this.padding),L=[i,v,E,_,this.filters];this.dataFormat!=="channelsLast"&&(s=Xt(s,[0,2,3,4,1]));let P=pC(s,this.kernel.read(),L,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(P=Xt(P,[0,4,1,2,3])),this.bias!==null&&(P=Si(P,this.bias.read(),this.dataFormat)),this.activation!==null&&(P=this.activation.apply(P)),P})}computeOutputShape(e){e=tn(e);const t=e.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const l=this.kernelSize[0],u=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],f=this.strides[1],m=this.strides[2];return t[s]=this.filters,t[r]=Ri(t[r],h,l,this.padding),t[i]=Ri(t[i],f,u,this.padding),t[o]=Ri(t[o],m,d,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}eO.className="Conv3DTranspose";He(eO);class tO extends zu{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new oe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new oe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new oe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=An(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Tn(t.depthwiseRegularizer),this.depthwiseConstraint=Zn(t.depthwiseConstraint),this.pointwiseInitializer=An(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Tn(t.pointwiseRegularizer),this.pointwiseConstraint=Zn(t.pointwiseConstraint)}build(e){if(e=tn(e),e.length<this.rank+2)throw new oe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new oe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new jn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return pe(()=>{e=$t(e);let s;if(this.rank===1)throw new Vt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Xt(e,[0,2,3,1])),s=tb(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Si(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Xt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=_n(this.depthwiseInitializer),e.pointwiseInitializer=_n(this.pointwiseInitializer),e.depthwiseRegularizer=fn(this.depthwiseRegularizer),e.pointwiseRegularizer=fn(this.pointwiseRegularizer),e.depthwiseConstraint=Xn(this.depthwiseConstraint),e.pointwiseConstraint=Xn(this.pointwiseConstraint),e}}tO.className="SeparableConv";class nO extends tO{constructor(e){super(2,e)}}nO.className="SeparableConv2D";He(nO);class cg extends zu{constructor(e){super(1,e),cg.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Kb(e.kernelSize,"number",1,1))throw new oe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}cg.className="Conv1D";He(cg);class sO extends Ht{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return pe(()=>{if(e=$t(e),this.dataFormat==="channelsLast"){const s=ip(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return ip(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=ip(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return ip(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}sO.className="Cropping2D";He(sO);class rO extends Ht{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Mn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,HK(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return pe(()=>{let s=$t(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=Xt(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],l=this.interpolation==="nearest"?Pi.resizeNearestNeighbor(s,[i,o]):Pi.resizeBilinear(s,[i,o]);return Xt(l,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Pi.resizeNearestNeighbor(s,[i,o]):Pi.resizeBilinear(s,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}rO.className="UpSampling2D";He(rO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fY(n,e,t=[1,1],s="valid",r,i){return pe(()=>{r==null&&(r=xi()),Mn(r);let o=ox(n,r);if(n.rank!==4)throw new oe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new oe(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=uh(o,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=Xt(o,[0,3,1,2])),o})}class iO extends ug{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=An(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Zn(e.depthwiseConstraint),this.depthwiseRegularizer=Tn(e.depthwiseRegularizer)}build(e){if(e=tn(e),e.length<4)throw new oe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new oe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return pe(()=>{e=$t(e);let s=fY(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Si(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=tn(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Ii(t,this.kernelSize[0],this.padding,this.strides[0]),o=Ii(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,o]:[e[0],i,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=_n(this.depthwiseInitializer),e.depthwiseRegularizer=fn(this.depthwiseRegularizer),e.depthwiseConstraint=Xn(this.depthwiseRegularizer),e}}iO.className="DepthwiseConv2D";He(iO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aO(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new oe("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function oO(n,e,t,s=!1,r,i,o=!1,l=!1){return pe(()=>{const u=e.shape.length;if(u<3)throw new oe(`Input should be at least 3D, but is ${u}D.`);const d=[1,0].concat(bi(2,u));if(e=Xt(e,d),i!=null)throw new Vt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=rt(rt(r,"bool"),"float32"),r.rank===u-1&&(r=Ps(r,-1)),r=Xt(r,d)),s&&(e=Qr(e,0),r!=null&&(r=Qr(r,0)));const h=[];let f,m=t;const I=e.shape[0],y=Jr(e);let N;r!=null&&(N=Jr(r));for(let T=0;T<I;++T){const v=y[T],E=pe(()=>n(v,m));if(r==null)f=E[0],m=E[1];else{const _=pe(()=>{const L=N[T],P=ut(kr(L),L),B=Me(ne(E[0],L),ne(m[0],P)),U=m.map((Z,Y)=>Me(ne(E[1][Y],L),ne(Z,P)));return{output:B,newStates:U}});f=_.output,m=_.newStates}l&&h.push(f)}let w;return l&&(w=fr(h,1)),[f,w,m]})}class fo extends Ht{constructor(e){super(e);let t;if(e.cell==null)throw new oe("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new cx({cells:e.cell}):t=e.cell,t.stateSize==null)throw new oe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new jn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return bi(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){bI(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[r].concat(i)}else return r}computeMask(e,t){return pe(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Vt("Constants support is not implemented in RNN yet.");bI(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new jn({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!Kt(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new oe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new jn({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){pe(()=>{if(!this.stateful)throw new Li("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new oe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>qn([s,r])):this.states_=[qn([s,this.cell.stateSize])];else if(e==null)Ft(this.states_),this.keptStates!=null&&(Ft(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>qn([s,r])):this.states_[0]=qn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new oe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Ft(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,l=[s,o];if(!Kt(i.shape,l))throw new oe(`State ${r} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>is(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=aO(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let o=[],l=[];if(s!=null){t.initialState=s,o=o.concat(s),this.stateSpec=[];for(const d of s)this.stateSpec.push(new jn({shape:d.shape}));l=l.concat(this.stateSpec)}if(r!=null&&(t.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof ji){const d=[e].concat(o),h=this.inputSpec.concat(l),f=this.inputSpec;this.inputSpec=h;const m=super.apply(d,t);return this.inputSpec=f,m}else return super.apply(e,t)}call(e,t){return pe(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=$t(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new oe(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:r},d=oO((y,N)=>{const w=this.cell.call([y].concat(N),l);return[w[0],w.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),h=d[0],f=d[1],m=d[2];this.stateful&&this.resetStates(m,r);const I=this.returnSequences?f:h;return this.returnState?[I].concat(m):I})}getInitialState(e){return pe(()=>{let t=qn(e.shape);return t=ft(t,[1,2]),t=yh(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?II(t,[1,s]):t):this.cell.stateSize>1?[II(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===fo.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=pa(r,s);return new e(Object.assign(t,{cell:i}))}}fo.className="RNN";He(fo);class dg extends Ht{}class lx extends dg{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,as(this.units,"units"),this.activation=Qa(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=An(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=An(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=An(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Tn(e.kernelRegularizer),this.recurrentRegularizer=Tn(e.recurrentRegularizer),this.biasRegularizer=Tn(e.biasRegularizer),this.kernelConstraint=Zn(e.kernelConstraint),this.recurrentConstraint=Zn(e.recurrentConstraint),this.biasConstraint=Zn(e.biasConstraint),this.dropout=Nu([1,Xa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Nu([1,Xa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=tn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return pe(()=>{if(e=e,e.length!==2)throw new oe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ja({ones:()=>kr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ja({ones:()=>kr(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,l=this.recurrentDropoutMask;o!=null?i=Ui(ne(e,o),this.kernel.read()):i=Ui(e,this.kernel.read()),this.bias!=null&&(i=Si(i,this.bias.read())),l!=null&&(s=ne(s,l));let u=Me(i,Ui(s,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Za(this.activation),useBias:this.useBias,kernelInitializer:_n(this.kernelInitializer),recurrentInitializer:_n(this.recurrentInitializer),biasInitializer:_n(this.biasInitializer),kernelRegularizer:fn(this.kernelRegularizer),recurrentRegularizer:fn(this.recurrentRegularizer),biasRegularizer:fn(this.biasRegularizer),activityRegularizer:fn(this.activityRegularizer),kernelConstraint:Xn(this.kernelConstraint),recurrentConstraint:Xn(this.recurrentConstraint),biasConstraint:Xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}lx.className="SimpleRNNCell";He(lx);class lO extends fo{constructor(e){e.cell=new lx(e),super(e)}call(e,t){return pe(()=>{this.cell.dropoutMask!=null&&(Ft(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}lO.className="SimpleRNN";He(lO);class ux extends dg{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new oe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,as(this.units,"units"),this.activation=Qa(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Qa(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=An(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=An(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=An(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Tn(e.kernelRegularizer),this.recurrentRegularizer=Tn(e.recurrentRegularizer),this.biasRegularizer=Tn(e.biasRegularizer),this.kernelConstraint=Zn(e.kernelConstraint),this.recurrentConstraint=Zn(e.recurrentConstraint),this.biasConstraint=Zn(e.biasConstraint),this.dropout=Nu([1,Xa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Nu([1,Xa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=tn(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return pe(()=>{if(e=e,e.length!==2)throw new oe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ja({ones:()=>kr(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ja({ones:()=>kr(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,u,d;0<this.dropout&&this.dropout<1&&(e=ne(e,i[0]));let h=Ui(e,this.kernel.read());this.useBias&&(h=Si(h,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ne(r,o[0]));const f=this.recurrentKernel.read(),[m,I]=cr(f,[2*this.units,this.units],f.rank-1),y=Ui(r,m),[N,w,T]=cr(h,3,h.rank-1),[v,E]=cr(y,2,y.rank-1);l=this.recurrentActivation.apply(Me(N,v)),u=this.recurrentActivation.apply(Me(w,E));const _=Ui(ne(u,r),I);d=this.activation.apply(Me(T,_));const L=Me(ne(l,r),ne(Me(1,wn(l)),d));return[L,L]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Za(this.activation),recurrentActivation:Za(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_n(this.kernelInitializer),recurrentInitializer:_n(this.recurrentInitializer),biasInitializer:_n(this.biasInitializer),kernelRegularizer:fn(this.kernelRegularizer),recurrentRegularizer:fn(this.recurrentRegularizer),biasRegularizer:fn(this.biasRegularizer),activityRegularizer:fn(this.activityRegularizer),kernelConstraint:Xn(this.kernelConstraint),recurrentConstraint:Xn(this.recurrentConstraint),biasConstraint:Xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}ux.className="GRUCell";He(ux);class uO extends fo{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ux(e),super(e)}call(e,t){return pe(()=>{this.cell.dropoutMask!=null&&(Ft(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}uO.className="GRU";He(uO);class hg extends dg{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,as(this.units,"units"),this.activation=Qa(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Qa(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=An(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=An(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=An(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Tn(e.kernelRegularizer),this.recurrentRegularizer=Tn(e.recurrentRegularizer),this.biasRegularizer=Tn(e.biasRegularizer),this.kernelConstraint=Zn(e.kernelConstraint),this.recurrentConstraint=Zn(e.recurrentConstraint),this.biasConstraint=Zn(e.biasConstraint),this.dropout=Nu([1,Xa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Nu([1,Xa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=tn(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(t=class extends ti{apply(u,d){const h=i.apply([o]),f=new Yb().apply([o]),m=i.apply([o*2]);return o3(o3(h,f),m)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return pe(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new oe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ja({ones:()=>kr(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ja({ones:()=>kr(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,l=this.recurrentDropoutMask;let u,d,h,f;0<this.dropout&&this.dropout<1&&(e=ne(e,o[0]));let m=Ui(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ne(r,l[0])),m=Me(m,Ui(r,this.recurrentKernel.read())),this.useBias&&(m=Si(m,this.bias.read()));const[I,y,N,w]=cr(m,4,m.rank-1);u=this.recurrentActivation.apply(I),d=this.recurrentActivation.apply(y),h=Me(ne(d,i),ne(u,this.activation.apply(N))),f=this.recurrentActivation.apply(w);const T=ne(f,this.activation.apply(h));return[T,T,h]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Za(this.activation),recurrentActivation:Za(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_n(this.kernelInitializer),recurrentInitializer:_n(this.recurrentInitializer),biasInitializer:_n(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:fn(this.kernelRegularizer),recurrentRegularizer:fn(this.recurrentRegularizer),biasRegularizer:fn(this.biasRegularizer),activityRegularizer:fn(this.activityRegularizer),kernelConstraint:Xn(this.kernelConstraint),recurrentConstraint:Xn(this.recurrentConstraint),biasConstraint:Xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}hg.className="LSTMCell";He(hg);class cO extends fo{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new hg(e),super(e)}call(e,t){return pe(()=>{this.cell.dropoutMask!=null&&(Ft(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}cO.className="LSTM";He(cO);class cx extends dg{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return pe(()=>{e=e;let s=e.slice(1);const r=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?r.push(s.splice(0,l.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];s=r[l],l===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=u.call(o,t),i.push(o.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[o[0]].concat(s)})}build(e){bI(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{Yo(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(pa(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return xI(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let o=0;o<s.weights.length;++o)t.push([s.weights[o],i[o]])}nx(t)}}cx.className="StackedRNNCells";He(cx);function Ja(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):t4(e(),t),l=()=>xh(o,e,s);return!r||r<=1?is(l().clone()):Array(r).fill(void 0).map(l).map(d=>is(d.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var mY=globalThis&&globalThis.__rest||function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class dO extends fo{constructor(e){if(e.unroll)throw new Vt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Vt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new jn({ndim:5})]}call(e,t){return pe(()=>{if(this.cell.dropoutMask!=null&&(Ft(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ft(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new oe("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return pe(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=qn(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){pe(()=>{if(!this.stateful)throw new Li("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new oe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>qn(i)):this.states_=[qn(i)];else if(e==null)Ft(this.states_),this.keptStates!=null&&(Ft(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>qn(i)):this.states_[0]=qn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new oe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ft(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],d=i;if(!Kt(u.shape,d))throw new oe(`State ${l} is incompatible with layer ${this.name}: expected shape=${d}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>is(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:l}=this.cell,u=t==="channelsFirst",d=e[u?3:2],h=e[u?4:3],f=Ii(d,r[0],i,o[0],l[0]),m=Ii(h,r[1],i,o[1],l[1]);return[...e.slice(0,2),...u?[s,f,m]:[f,m,s]]}}dO.className="ConvRNN2D";class dx extends hg{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,as(this.filters,"filters"),this.kernelSize=du(s,2,"kernelSize"),this.kernelSize.forEach(u=>as(u,"kernelSize")),this.strides=du(r||1,2,"strides"),this.strides.forEach(u=>as(u,"strides")),this.padding=i||"valid",Lr(this.padding),this.dataFormat=o||"channelsLast",Mn(this.dataFormat),this.dilationRate=du(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>as(u,"dilationRate"))}build(e){var t;e=tn(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new oe(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const d=this.biasInitializer,h=this.filters;u=new(t=class extends ti{apply(m,I){const y=d.apply([h]),N=ur([h]),w=d.apply([h*2]);return jb([y,N,w])}},t.className="CustomInit",t)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return pe(()=>{if(e.length!==3)throw new oe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],o=e[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ja({ones:()=>kr(r),rate:this.dropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,d=(Pe,Fe,Ue)=>!Fe||!Fe[Ue]?Pe:ne(Fe[Ue],Pe);let h=d(r,u,0),f=d(r,u,1),m=d(r,u,2),I=d(r,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ja({ones:()=>kr(i),rate:this.recurrentDropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const y=this.recurrentDropoutMask;let N=d(i,y,0),w=d(i,y,1),T=d(i,y,2),v=d(i,y,3);const E=3,[_,L,P,B]=cr(this.kernel.read(),l,E),[U,Z,Y,ae]=this.useBias?cr(this.bias.read(),l):[null,null,null,null];h=this.inputConv(h,_,U,this.padding),f=this.inputConv(f,L,Z,this.padding),m=this.inputConv(m,P,Y,this.padding),I=this.inputConv(I,B,ae,this.padding);const[de,ce,Ie,be]=cr(this.recurrentKernel.read(),l,E);N=this.recurrentConv(N,de),w=this.recurrentConv(w,ce),T=this.recurrentConv(T,Ie),v=this.recurrentConv(v,be);const ye=this.recurrentActivation.apply(Me(h,N)),we=this.recurrentActivation.apply(Me(f,w)),fe=Me(ne(we,o),ne(ye,this.activation.apply(Me(m,T)))),De=ne(this.recurrentActivation.apply(Me(I,v)),this.activation.apply(fe));return[De,De,fe]})}getConfig(){const e=super.getConfig(),t=mY(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),s)}inputConv(e,t,s,r){const i=Ya(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Si(i,s,this.dataFormat):i}recurrentConv(e,t){return Ya(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}dx.className="ConvLSTM2DCell";He(dx);class hO extends dO{constructor(e){const t=new dx(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}hO.className="ConvLSTM2D";He(hO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hx extends Ht{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return pe(()=>{this.invokeCallHook(e,t);const s=$t(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return xh(()=>t4(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}hx.className="Dropout";He(hx);class pO extends hx{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}pO.className="SpatialDropout1D";He(pO);class fO extends Ht{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,as(this.units,"units"),this.activation=Qa(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=An(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=An(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Zn(e.kernelConstraint),this.biasConstraint=Zn(e.biasConstraint),this.kernelRegularizer=Tn(e.kernelRegularizer),this.biasRegularizer=Tn(e.biasRegularizer),this.activityRegularizer=Tn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=tn(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=tn(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return pe(()=>{this.invokeCallHook(e,t);const s=$t(e),r=jL(this.activation.getClassName());let i;return r!=null?i=Ui(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=Ui(s,this.kernel.read()),this.bias!=null&&(i=Si(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Za(this.activation),useBias:this.useBias,kernelInitializer:_n(this.kernelInitializer),biasInitializer:_n(this.biasInitializer),kernelRegularizer:fn(this.kernelRegularizer),biasRegularizer:fn(this.biasRegularizer),activityRegularizer:fn(this.activityRegularizer),kernelConstraint:Xn(this.kernelConstraint),biasConstraint:Xn(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}fO.className="Dense";He(fO);class mO extends Ht{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=tn(e);for(const t of e.slice(1))if(t==null)throw new oe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ua(e,1)]}call(e,t){return pe(()=>{this.invokeCallHook(e,t);let s=$t(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=Xt(s,r)}return YK(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}mO.className="Flatten";He(mO);class gO extends Ht{constructor(e){super(e),this.supportsMasking=!0,this.activation=Qa(e.activation)}call(e,t){return pe(()=>{this.invokeCallHook(e,t);const s=$t(e);return this.activation.apply(s)})}getConfig(){const e={activation:Za(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}gO.className="Activation";He(gO);class IO extends Ht{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return pe(()=>(e=$t(e),KK(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}IO.className="RepeatVector";He(IO);class yO extends Ht{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,o=null;for(let u=0;u<r.length;++u){const d=r[u];if(this.isUnknown(d))if(o===null)o=u;else throw new oe("Can only specifiy one unknown dimension.");else i*=d}const l=Ua(e);if(o!==null){if(i===0||l%i!==0)throw new oe(s);r[o]=l/i}else if(l!==i)throw new oe(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return pe(()=>{this.invokeCallHook(e,t);const s=$t(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ie(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}yO.className="Reshape";He(yO);class bO extends Ht{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=bi(1,e.dims.length+1);if(!Kt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new jn({ndim:this.dims.length+1})]}computeOutputShape(e){e=tn(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return Xt($t(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}bO.className="Permute";He(bO);class xO extends Ht{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=$t(e),r=-1;return qp(bu(s,this.maskValue),r)}call(e,t){return pe(()=>{this.invokeCallHook(e,t);const s=$t(e),r=-1,i=!0,o=qp(bu(s,this.maskValue),r,i);return ne(s,rt(o,s.dtype))})}}xO.className="Masking";He(xO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class NO extends Ht{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(ln(e.inputLength))}this.inputDim=e.inputDim,as(this.inputDim,"inputDim"),this.outputDim=e.outputDim,as(this.outputDim,"outputDim"),this.embeddingsInitializer=An(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Tn(e.embeddingsRegularizer),this.activityRegularizer=Tn(e.activityRegularizer),this.embeddingsConstraint=Zn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return pe(()=>this.maskZero?(e=$t(e),bu(e,Zt(e))):null)}computeOutputShape(e){if(e=tn(e),this.inputLength==null)return[...e,this.outputDim];const t=ln(this.inputLength);if(t.length!==e.length-1)throw new oe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],o=e[r+1];if(i!=null&&o!=null&&i!==o)throw new oe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=o),s++}}return[e[0],...t,this.outputDim]}call(e,t){return pe(()=>{this.invokeCallHook(e,t);let s=$t(e);s.dtype!=="int32"&&(s=Hi(s,"int32"));const r=e4(this.embeddings.read(),ie(s,[s.size]));return ie(r,tn(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:_n(this.embeddingsInitializer),embeddingsRegularizer:fn(this.embeddingsRegularizer),activityRegularizer:fn(this.activityRegularizer),embeddingsConstraint:Xn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}NO.className="Embedding";He(NO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $l extends Ht{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Vt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],o=t[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new oe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[tn(e)]),e=e,e.length<2)throw new oe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Ha(t),t.length>1)throw new oe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&Ha(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return pe(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Xa(r);for(let o of e){const l=o.rank;for(let u=0;u<i-l;++u)o=yh(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const u of e){const d=u.rank;if(d==null){const h=u.shape,f=h[0],m=h.slice(1).concat([f]);let I=ie(u,[f].concat(Ua(h.slice(1))));I=Xt(I,[1,0]),I=ie(I,m),s.push(I),i=!0}else if(d>1){const h=bi(1,d).concat([0]);s.push(Xt(u,h)),i=!0}else s.push(u)}let o=this.mergeFunction(s);const l=o.rank;if(i){if(l==null){const u=o.shape,d=u.length,h=u[d-1],f=[h].concat(u.slice(0,u.length-1));o=ie(Xt(ie(o,[-1,h]),[1,0]),f)}else if(l>1){const u=[l-1].concat(bi(0,l-1));o=Xt(o,u)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Ha(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return pe(()=>{if(t==null)return null;if(!Array.isArray(t))throw new oe("`mask` should be an Array");if(!Array.isArray(e))throw new oe("`inputs` should be an Array");if(t.length!==e.length)throw new oe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Ps(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=Ki(s,t[r]);return s})}}class wO extends $l{constructor(e){super(e)}mergeFunction(e){return pe(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Me(t,e[s]);return t})}}wO.className="Add";He(wO);class AO extends $l{constructor(e){super(e)}mergeFunction(e){return pe(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=ne(t,e[s]);return t})}}AO.className="Multiply";He(AO);class TO extends $l{constructor(e){super(e)}mergeFunction(e){return pe(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Me(t,e[s]);return ne(1/e.length,t)})}}TO.className="Average";He(TO);class SO extends $l{constructor(e){super(e)}mergeFunction(e){return pe(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Na(t,e[s]);return t})}}SO.className="Maximum";He(SO);class vO extends $l{constructor(e){super(e)}mergeFunction(e){return pe(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=ll(t,e[s]);return t})}}vO.className="Minimum";He(vO);class $O extends $l{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new oe("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let o=!1;for(const l of s)if(Kt(l,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new oe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return pe(()=>jb(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new oe("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new oe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new oe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new oe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return pe(()=>{let s=!0;if(t.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<e.length;++o)t[o]==null?r.push(rt(kr(e[o]),"bool")):t[o].rank<e[o].rank?r.push(Ps(t[o],-1)):r.push(t[o]);const i=Un(r,this.axis);return D2(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}$O.className="Concatenate";He($O);function hc(n,e){for(;n<0;)n+=e;return n}function gY(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Vt("batchDot is not implemented for tensors of 4D or higher rank yet");if(W(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),W(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Vt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return pe(()=>{let o;if(s>r){o=s-r;const u=[];for(let d=0;d<o;++d)u.push(1);e=ie(e,e.shape.concat(u))}else if(r>s){o=r-s;const u=[];for(let d=0;d<o;++d)u.push(1);n=ie(n,n.shape.concat(u))}else o=0;let l;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?l=ft(ne(n,e),i[0]):l=ft(ne(Xt(n,[1,0]),e),i[1]);else{const u=i[0]!==n.shape.length-1,d=i[1]===e.shape.length-1;l=Gt(n,e,u,d)}if(o>0){let u;s>r?u=s+r-3:u=s-1;const d=[];for(let h=u;h<u+o;++h)d.push(h);l=Tl(l,d)}return l.shape.length===1&&(l=Ps(l,1)),l})}class _O extends $l{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){W(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new Vt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new oe(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new oe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>hc(i,e[o].shape.length)):r=[hc(this.axes,t.shape.length),hc(this.axes,s.shape.length)],this.normalize&&(t=Qp(t,r[0]),s=Qp(s,r[1])),gY(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[hc(this.axes,e.length),hc(this.axes,t.length)],s}computeOutputShape(e){W(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new Vt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}_O.className="Dot";He(_O);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class DO extends Ht{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return pe(()=>{this.invokeCallHook(e,t);const s=$t(e);return xh(()=>Me(ig(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}DO.className="GaussianNoise";He(DO);class EO extends Ht{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return pe(()=>{this.invokeCallHook(e,t);const s=$t(e);return this.rate>0&&this.rate<1?xh(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return ne(s,ig(s.shape,1,i))},()=>s,t.training||!1):s})}}EO.className="GaussianDropout";He(EO);class kO extends Ht{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||$t(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return pe(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return xh(()=>{const i=$t(e),o=1.6732632423543772,l=1.0507009873554805,u=-o*l;let d=co(Al(s),this.rate);d=Hi(d,"float32");const h=((1-this.rate)*(1+this.rate*u**2))**-.5,f=-h*u*this.rate,m=Me(ne(i,d),ne(Me(d,-1),u));return Me(ne(m,h),f)},()=>$t(e),t.training||!1)}return e})}}kO.className="AlphaDropout";He(kO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ed(n,e,t,s,r,i=.001){let o;if(n.rank===2)o=nC(n,e,t,s,r,i);else if(n.rank===3)o=sC(n,e,t,s,r,i);else if(n.rank===4)o=rC(n,e,t,s,r,i);else throw new Vt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function IY(n,e,t,s,r=.001){return pe(()=>{const i=Wm(n,s),o=i.mean,l=i.variance;return[ed(n,o,l,t,e,r),o,l]})}function yY(n,e,t,s,r=.001){return pe(()=>{const i=Wm(n,s),o=i.mean,l=i.variance,u=[];for(const y of bi(0,n.rank))s.indexOf(y)!==-1?u.push(1):u.push(n.shape[y]);const d=ie(o,u),h=ie(l,u),f=e==null?null:ie(e,u),m=t==null?null:ie(t,u);return[ed(n,d,h,m,f,r),o,l]})}function bY(n,e,t,s,r=.001){return Kt(s.slice().sort(),bi(0,n.rank-1))?IY(n,e,t,s,r):yY(n,e,t,s,r)}class CO extends Ht{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=An(e.betaInitializer||"zeros"),this.gammaInitializer=An(e.gammaInitializer||"ones"),this.movingMeanInitializer=An(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=An(e.movingVarianceInitializer||"ones"),this.betaConstraint=Zn(e.betaConstraint),this.gammaConstraint=Zn(e.gammaConstraint),this.betaRegularizer=Tn(e.betaRegularizer),this.gammaRegularizer=Tn(e.gammaRegularizer)}build(e){e=tn(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new oe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new jn({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return pe(()=>{const s=t.training==null?!1:t.training,r=$t(e),i=r.shape,o=i.length,l=bi(0,o),u=this.axis>=0?this.axis:this.axis+o;l.splice(u,1);const d=cl(1,o);d[u]=i[u];const h=l.slice();h.sort();const f=!Kt(h,bi(0,o).slice(0,o-1)),m=()=>{if(f){const v=ie(this.movingMean.read(),d),E=ie(this.movingVariance.read(),d),_=this.center?ie(this.beta.read(),d):null,L=this.scale?ie(this.gamma.read(),d):null;return ed(r,v,E,_,L,this.epsilon)}else return ed(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[I,y,N]=bY(r,this.gamma.read(),this.beta.read(),l,this.epsilon),w=(v,E,_)=>{pe(()=>{const L=1-_,P=v.read(),B=ne(ut(P,E),L);v.write(ut(P,B))})};return(()=>{w(this.movingMean,y,this.momentum),w(this.movingVariance,N,this.momentum)})(),I})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_n(this.betaInitializer),gammaInitializer:_n(this.gammaInitializer),movingMeanInitializer:_n(this.movingMeanInitializer),movingVarianceInitializer:_n(this.movingVarianceInitializer),betaRegularizer:fn(this.betaRegularizer),gammaRegularizer:fn(this.gammaRegularizer),betaConstraint:Xn(this.betaConstraint),gammaConstraint:Xn(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}CO.className="BatchNormalization";He(CO);class LO extends Ht{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=An(e.betaInitializer||"zeros"),this.gammaInitializer=An(e.gammaInitializer||"ones"),this.betaRegularizer=Tn(e.betaRegularizer),this.gammaRegularizer=Tn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=tn(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Ha(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=$t(e),r=s.shape,i=r.length;return pe(()=>{let{mean:l,variance:u}=Wm(s,this.axis,!0);const d=cl(1,i);for(const N of this.axis)d[N]=r[N];const h=N=>N!=null&&N.shape.length!==i?ie(N,d):N;let f=this.scale?h(this.gamma.read()):null,m=this.center?h(this.beta.read()):null;const I=[],y=[];for(let N=0;N<i;++N)this.axis.indexOf(N)!==-1?(I.push(r[N]),y.push(1)):(I.push(1),y.push(r[N]));return l=Ur(l,I),u=Ur(u,I),f!=null&&(f=Ur(f,y)),m!=null&&(m=Ur(m,y)),ed(s,l,u,m,f,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_n(this.betaInitializer),gammaInitializer:_n(this.gammaInitializer),betaRegularizer:fn(this.betaRegularizer),gammaRegularizer:fn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}LO.className="LayerNormalization";He(LO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xY(n,e,t){return pe(()=>{if(n.rank!==4)throw new oe(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new oe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=xi()),t!=="channelsLast"&&t!=="channelsFirst")throw new oe(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],ho(n,s)})}class OO extends Ht{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?xi():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new oe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new oe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new oe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new jn({ndim:4})]}computeOutputShape(e){e=tn(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return pe(()=>xY($t(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}OO.className="ZeroPadding2D";He(OO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pg(n,e,t,s,r,i){return pe(()=>{Mn(r),XL(i),Lr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=xi()),i==null&&(i="max"),n=ox(n,r);let o;const l=s==="same"?"same":"valid";return i==="max"?o=Mm(n,e,t,l):o=Cm(n,e,t,l),r==="channelsFirst"&&(o=Xt(o,[0,3,1,2])),o})}function RO(n,e,t,s,r,i){return pe(()=>{Mn(r),XL(i),Lr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=xi()),i==null&&(i="max"),n=Q4(n,r);let o;const l=s==="same"?"same":"valid";return i==="max"?o=_C(n,e,t,l):o=tC(n,e,t,l),r==="channelsFirst"&&(o=Xt(o,[0,4,1,2,3])),o})}class VO extends Ht{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new oe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(as(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new oe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);as(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Lr(this.padding),this.inputSpec=[new jn({ndim:3})]}computeOutputShape(e){e=tn(e);const t=Ii(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return pe(()=>{this.invokeCallHook(e,t),e=yh($t(e),2);const s=this.poolingFunction($t(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Tl(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class PO extends VO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Mn(i),Lr(r),pg(e,t,s,r,i,"max")}}PO.className="MaxPooling1D";He(PO);class FO extends VO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Mn(i),Lr(r),pg(e,t,s,r,i,"avg")}}FO.className="AveragePooling1D";He(FO);class zO extends Ht{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new oe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];as(this.poolSize,"poolSize"),as(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Mn(this.dataFormat),Lr(this.padding),this.inputSpec=[new jn({ndim:4})]}computeOutputShape(e){e=tn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Ii(t,this.poolSize[0],this.padding,this.strides[0]),s=Ii(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return pe(()=>(this.invokeCallHook(e,t),this.poolingFunction($t(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class MO extends zO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Mn(i),Lr(r),pg(e,t,s,r,i,"max")}}MO.className="MaxPooling2D";He(MO);class WO extends zO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Mn(i),Lr(r),pg(e,t,s,r,i,"avg")}}WO.className="AveragePooling2D";He(WO);class BO extends Ht{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new oe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];as(this.poolSize,"poolSize"),as(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Mn(this.dataFormat),Lr(this.padding),this.inputSpec=[new jn({ndim:5})]}computeOutputShape(e){e=tn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Ii(t,this.poolSize[0],this.padding,this.strides[0]),s=Ii(s,this.poolSize[1],this.padding,this.strides[1]),r=Ii(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return pe(()=>(this.invokeCallHook(e,t),this.poolingFunction($t(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class HO extends BO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Mn(i),Lr(r),RO(e,t,s,r,i,"max")}}HO.className="MaxPooling3D";He(HO);class UO extends BO{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return Mn(i),Lr(r),RO(e,t,s,r,i,"avg")}}UO.className="AveragePooling3D";He(UO);class GO extends Ht{constructor(e){super(e),this.inputSpec=[new jn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Vt}}class qO extends GO{constructor(e){super(e||{})}call(e,t){return pe(()=>{const s=$t(e);return On(s,1)})}}qO.className="GlobalAveragePooling1D";He(qO);class KO extends GO{constructor(e){super(e||{})}call(e,t){return pe(()=>{const s=$t(e);return Yr(s,1)})}}KO.className="GlobalMaxPooling1D";He(KO);class jO extends Ht{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Mn(this.dataFormat),this.inputSpec=[new jn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Vt}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class YO extends jO{call(e,t){return pe(()=>{const s=$t(e);return this.dataFormat==="channelsLast"?On(s,[1,2]):On(s,[2,3])})}}YO.className="GlobalAveragePooling2D";He(YO);class XO extends jO{call(e,t){return pe(()=>{const s=$t(e);return this.dataFormat==="channelsLast"?Yr(s,[1,2]):Yr(s,[2,3])})}}XO.className="GlobalMaxPooling2D";He(XO);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ZO extends Ht{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=pa(r,s);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class QO extends ZO{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=tn(e),e.length<3)throw new oe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=tn(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return pe(()=>(e=$t(e),oO((o,l)=>[$t(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}QO.className="TimeDistributed";He(QO);function NY(n){vl(BK,"BidirectionalMergeMode",n)}const wY="concat";class JO extends ZO{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=pa(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=pa(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?wY:e.mergeMode,NY(this.mergeMode),e.weights)throw new Vt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Xs(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=aO(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const o=[],l=[];if(s!=null){const d=s.length;if(d%2>0)throw new oe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,o.push(...s);const h=s.map(f=>new jn({shape:f.shape}));this.forwardLayer.stateSpec=h.slice(0,d/2),this.backwardLayer.stateSpec=h.slice(d/2),l.push(...h)}if(r!=null)throw new Vt("Support for constants in Bidirectional layers is not implemented yet.");const u=o[0]instanceof ji;for(const d of o)if(d instanceof ji!==u)throw new oe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const d=[e].concat(o),h=this.inputSpec.concat(l),f=this.inputSpec;this.inputSpec=h;const m=super.apply(d,t);return this.inputSpec=f,m}else return super.apply(e,t)}call(e,t){return pe(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const u=s.slice(0,s.length/2),d=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:d}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=Qr(i,1));let l;return this.mergeMode==="concat"?l=jb([r,i]):this.mergeMode==="sum"?l=Me(r,i):this.mergeMode==="ave"?l=ne(.5,Me(r,i)):this.mergeMode==="mul"?l=ne(r,i):this.mergeMode==null&&(l=[r,i]),this.returnState?this.mergeMode==null?l.concat(o):[l].concat(o):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Yo(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Yo(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=pa(t.layer);if(delete t.layer,t.numConstants!=null)throw new Vt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}JO.className="Bidirectional";He(JO);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eR extends Ht{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return pe(()=>(e=$t(e),e.dtype!=="float32"&&(e=Hi(e,"float32")),Me(ne(e,this.scale),this.offset)))}}eR.className="Rescaling";He(eR);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:AY,cropAndResize:TY}=Pi;class tR extends Ht{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,o,l,u){return pe(()=>{let d,h=!1;const f=t/o,m=s/l,I=(r+t)/o,y=(i+s)/l,N=[f,m,I,y],w=[];e.rank===3?(h=!0,d=fr([e])):d=e;for(let L=0;L<d.shape[0];L++)w.push(N);const T=Dr(w,[w.length,4]),v=xu(0,w.length,1,"int32"),_=TY(d,T,v,[r,i],"nearest");return Hi(h?$t(Jr(_)):_,u)})}upsize(e,t,s,r){return pe(()=>{const i=AY(e,[t,s]);return Hi(i,r)})}call(e,t){return pe(()=>{const s=$t(e),r=s.dtype,i=s.shape,o=i[i.length-3],l=i[i.length-2];let u=0;o!==this.height&&(u=Math.floor((o-this.height)/2));let d=0;return l!==this.width&&(d=Math.floor((l-this.width)/2),d===0&&(d=1)),u>=0&&d>=0?this.centerCrop(s,u,d,this.height,this.width,o,l,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=tn(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}tR.className="CenterCrop";He(tR);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function SY(n,e,t,s){let r=$t(n);if(r.dtype!=="int32"&&(r=Hi(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=Ps(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Ps(r,-1)),r.rank>2)throw new oe(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),l=r;let u;if(typeof s<"u"&&e==="count"?u=dI(l,s,t,o):u=dI(l,[],t,o),e!=="tfIdf")return u;if(s)return ne(u,s);throw new oe("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class nR extends Ht{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=tn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return pe(()=>{e=$t(e),e.dtype!=="int32"&&(e=Hi(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new oe(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=$t(t.countWeights)}const r=Yr(e),i=qc(e),o=xr(this.numTokens,r).bufferSync().get(0),l=co(i,0).bufferSync().get(0);if(!(o&&l))throw new oe(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return SY(e,this.outputMode,this.numTokens,s)})}}nR.className="CategoryEncoding";He(nR);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const vY=["bilinear","nearest"],S3=new Set(vY);class sR extends Ht{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(S3.has(e.interpolation))this.interpolation=e.interpolation;else throw new oe(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=tn(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return pe(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Pi.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Pi.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...S3]} are supported`)})}}sR.className="Resizing";He(sR);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class rR{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}rR.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class iR extends Ht{constructor(e){super(e),this.randomGenerator=new rR(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}iR.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const $Y=["bilinear","nearest"],v3=new Set($Y);class aR extends iR{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new oe(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new oe(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new oe(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(v3.has(s))this.interpolation=s;else throw new oe(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=tn(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return pe(()=>{const s=$t(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Al([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Pi.resizeBilinear(e,o);case"nearest":return Pi.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...v3]} are supported`)}})}}aR.className="RandomWidth";He(aR);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Y=xe();_Y.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ir;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(ir||(ir={}));var $3;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})($3||($3={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DY={};function oR(n){return DY[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C(n,e,t,s,r){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const l=i.inputIndexStart,u=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?l+1:i.inputIndexEnd,d=l<0?e.inputNames.length+l:l;if(i.type==="tensor")return fs(e.inputNames[d],t,s,r);if(i.type==="tensors"){const m=e.inputs.slice(l,u);return e.inputNames.slice(l,u).filter((y,N)=>{var w;return((w=m[N])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(y=>fs(y,t,s,r))}const h=fs(e.inputNames[d],t,s,r),f=h.dataSync();return i.type==="number"?f[0]:jr(h.shape,f)}const o=e.attrParams[n];return o&&o.value}function fs(n,e,t,s){const[r,i]=ar(n,t);if(s!=null){const l=s.getHashTableHandleByName(r);if(l!=null)return l}const o=t.currentContextIds.find(l=>!!e[sf(r,l)]);return o!==void 0?e[sf(r,o)][i]:void 0}function _3(n,e,t){return e[sf(n,t.currentContextId)]}function ia(n,e){const[t,s,r]=ar(n,e);return[sf(t,e&&e.currentContextId),s,r]}function sf(n,e){return e?`${n}-${e}`:n}function ar(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const i=s[0],o=s.length===3?s[1]:void 0,l=Number(s[s.length-1]);r=[i,l,o]}return t&&e.parseNodeNameCache.set(n,r),r}function Sp(n,e,t){let s=C("pad",n,e,t);if(s==="explicit"){s=C("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function aa(n){return n.kept?n:ha(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EY=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],kY=Object.freeze(Object.defineProperty({__proto__:null,json:EY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CY=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LY=Object.freeze(Object.defineProperty({__proto__:null,json:CY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OY=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],RY=Object.freeze(Object.defineProperty({__proto__:null,json:OY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VY=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],PY=Object.freeze(Object.defineProperty({__proto__:null,json:VY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FY=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],zY=Object.freeze(Object.defineProperty({__proto__:null,json:FY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MY=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],WY=Object.freeze(Object.defineProperty({__proto__:null,json:MY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BY=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],HY=Object.freeze(Object.defineProperty({__proto__:null,json:BY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UY=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],GY=Object.freeze(Object.defineProperty({__proto__:null,json:UY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qY=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],KY=Object.freeze(Object.defineProperty({__proto__:null,json:qY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jY=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],YY=Object.freeze(Object.defineProperty({__proto__:null,json:jY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XY=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],ZY=Object.freeze(Object.defineProperty({__proto__:null,json:XY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QY=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],JY=Object.freeze(Object.defineProperty({__proto__:null,json:QY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eX=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],tX=Object.freeze(Object.defineProperty({__proto__:null,json:eX},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nX=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],sX=Object.freeze(Object.defineProperty({__proto__:null,json:nX},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rX=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],iX=Object.freeze(Object.defineProperty({__proto__:null,json:rX},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aX=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],oX=Object.freeze(Object.defineProperty({__proto__:null,json:aX},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lX=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],uX=Object.freeze(Object.defineProperty({__proto__:null,json:lX},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cX=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],dX=Object.freeze(Object.defineProperty({__proto__:null,json:cX},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hX=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],pX=Object.freeze(Object.defineProperty({__proto__:null,json:hX},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D3{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[kY,LY,RY,PY,zY,WY,HY,GY,KY,YY,ZY,JY,tX,sX,iX,oX,uX,dX,pX],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],i=[],o=[],l=s.reduce((N,w)=>(N[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?r.push(N[w.name]):w.op==="Const"?i.push(N[w.name]):(w.input==null||w.input.length===0)&&o.push(N[w.name]),N),{});let u=[];const d=[];let h={},f={};t!=null&&(h=this.mapSignatureEntries(t.inputs),f=this.mapSignatureEntries(t.outputs));const m=Object.keys(l);m.forEach(N=>{const w=l[N];w.inputNames.forEach((T,v)=>{const[E,,_]=ia(T),L=l[E];if(L.outputs!=null){const P=L.outputs.indexOf(_);if(P!==-1){const B=`${E}:${P}`;w.inputNames[v]=B}}w.inputs.push(L),L.children.push(w)})}),Object.keys(f).length===0?m.forEach(N=>{const w=l[N];w.children.length===0&&d.push(w)}):Object.keys(f).forEach(N=>{const[w]=ia(N),T=l[w];T!=null&&(T.signatureKey=f[N],d.push(T))}),Object.keys(h).length>0?Object.keys(h).forEach(N=>{const[w]=ia(N),T=l[w];T&&(T.signatureKey=h[N],u.push(T))}):u=r;let I={};e.library!=null&&e.library.function!=null&&(I=e.library.function.reduce((N,w)=>(N[w.signature.name]=this.mapFunction(w),N),{}));const y={nodes:l,inputs:u,outputs:d,weights:i,placeholders:r,signature:t,functions:I};return o.length>0&&(y.initNodes=o),y}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=oR(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,i)=>{const o=i.type;let l;switch(i.type){case"string":l=vI(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=vI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":l=LI(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=LI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":l=_I(e.attr,i.tfName,i.defaultValue||0),l===void 0&&i.tfDeprecatedName&&(l=_I(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":l=CI(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=CI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":l=$I(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=$I(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":l=RI(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=RI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":l=kI(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=kI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":l=OI(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=OI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":l=DI(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=DI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":l=EI(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=EI(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":l=E3(e.attr,i.tfName,i.defaultValue),l===void 0&&i.tfDeprecatedName&&(l=E3(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return r[i.name]={value:l,type:o},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let i={};t!=null&&(i=t.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op==="Const"&&r.push(f[m.name]),f),{}));const o=[],l=[];e.signature.inputArg.forEach(f=>{const[m]=ia(f.name),I={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:px(f.type),type:"dtype"}},children:[]};I.signatureKey=f.name,o.push(I),i[m]=I}),Object.keys(i).forEach(f=>{const m=i[f];m.inputNames.forEach((I,y)=>{const[N,,w]=ia(I),T=i[N];if(T.outputs!=null){const v=T.outputs.indexOf(w);if(v!==-1){const E=`${N}:${v}`;m.inputNames[y]=E}}m.inputs.push(T),T.children.push(m)})});const d=e.ret;e.signature.outputArg.forEach(f=>{const[m,I]=ia(d[f.name]),y=i[m];y!=null&&(y.defaultOutput=I,l.push(y))});const h=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:l,weights:r,placeholders:s,signature:h}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function fX(n){const e=xe().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function lR(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):fX(n);return e?t:t.toLowerCase()}function vI(n,e,t,s=!1){const r=n[e];return r!=null?lR(r.s,s):t}function $I(n,e,t){const s=n[e];return s?s.b:t}function _I(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function px(n){switch(typeof n=="string"&&(n=ir[n]),n){case ir.DT_FLOAT:case ir.DT_HALF:return"float32";case ir.DT_INT32:case ir.DT_INT64:case ir.DT_INT8:case ir.DT_UINT8:return"int32";case ir.DT_BOOL:return"bool";case ir.DT_DOUBLE:return"float32";case ir.DT_STRING:return"string";case ir.DT_COMPLEX64:case ir.DT_COMPLEX128:return"complex64";default:return null}}function E3(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function DI(n,e,t){const s=n[e];return s&&s.type?px(s.type):t}function EI(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>px(r)):t}function uR(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function kI(n,e,t){const s=n[e];return s&&s.shape?uR(s.shape):t}function CI(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function LI(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(i=>lR(i,s)):t}function OI(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>uR(r)):t}function RI(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mX{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(e){return fs(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return fs(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return _I(this.node.rawAttrs,e,t);if(s.s!=null)return vI(this.node.rawAttrs,e,t);if(s.b!=null)return $I(this.node.rawAttrs,e,t);if(s.shape!=null)return kI(this.node.rawAttrs,e,t);if(s.type!=null)return DI(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return CI(this.node.rawAttrs,e,t);if(s.list.s!=null)return LI(this.node.rawAttrs,e,t);if(s.list.shape!=null)return OI(this.node.rawAttrs,e,t);if(s.list.b!=null)return RI(this.node.rawAttrs,e,t);if(s.list.type!=null)return EI(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ns=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Dk,abs:Gn,acos:Kk,acosh:jk,add:Me,addN:RW,all:D2,any:qp,argMax:Iu,argMin:Yk,asin:Xk,asinh:Zk,atan:Qk,atan2:Jk,atanh:eC,avgPool:Cm,avgPool3d:tC,basicLSTMCell:rB,batchNorm:lh,batchNorm2d:nC,batchNorm3d:sC,batchNorm4d:rC,batchToSpaceND:Lm,bincount:iC,bitwiseAnd:pB,booleanMaskAsync:XU,broadcastArgs:mB,broadcastTo:uu,buffer:zt,cast:rt,ceil:aC,clipByValue:hr,clone:ha,complex:qa,concat:Un,concat1d:oC,concat2d:lC,concat3d:uC,concat4d:cC,conv1d:k2,conv2d:Ya,conv2dTranspose:L2,conv3d:dC,conv3dTranspose:pC,cos:Om,cosh:O2,cosineWindow:db,cumprod:Kp,cumsum:R2,denseBincount:dI,depthToSpace:fC,depthwiseConv2d:uh,diag:FB,dilation2d:mC,div:bt,divNoNan:gC,dot:IC,dropout:HC,einsum:jl,elu:ch,enclosingPowerOfTwo:UC,ensureShape:jB,equal:yi,erf:V2,euclideanNorm:xC,exp:pr,expandDims:Ps,expm1:NC,eye:F2,fft:jm,fill:Ou,floor:hh,floorDiv:_2,fused:y7,gather:ph,gatherND:a7,greater:xr,greaterEqual:co,ifft:Xc,imag:Rm,image:Pi,inTopKAsync:c7,irfft:ib,isFinite:wC,isInf:AC,isNaN:TC,leakyRelu:Vm,less:Kc,lessEqual:Nl,linalg:QC,linspace:xH,localResponseNormalization:SC,log:Er,log1p:Pm,logSigmoid:vC,logSoftmax:z2,logSumExp:Fm,logicalAnd:Ki,logicalNot:zm,logicalOr:M2,logicalXor:$C,losses:Y9,lowerBound:VH,matMul:Gt,max:Yr,maxPool:Mm,maxPool3d:_C,maxPoolWithArgmax:MH,maximum:Na,mean:On,meshgrid:HH,min:qc,minimum:ll,mirrorPad:DC,mod:EC,moments:Wm,movingAverage:JU,mul:ne,multiRNNCell:YH,multinomial:ZH,neg:wn,norm:dh,notEqual:bu,oneHot:B2,ones:ur,onesLike:kr,op:J,outerProduct:n8,pad:ho,pad1d:i8,pad2d:o8,pad3d:u8,pad4d:d8,pool:kC,pow:fa,prelu:Hm,print:qk,prod:CC,raggedGather:b8,raggedRange:N8,raggedTensorToTensor:A8,rand:S8,randomGamma:G8,randomNormal:X2,randomStandardNormal:j8,randomUniform:Al,randomUniformInt:Z8,range:xu,real:jc,reciprocal:OC,relu:Xi,relu6:Z2,reshape:ie,reverse:Qr,reverse1d:rU,reverse2d:aU,reverse3d:lU,reverse4d:cU,rfft:Ym,round:Q2,rsqrt:J2,scalar:At,scatterND:t7,searchSorted:W2,selu:eb,separableConv2d:tb,setdiff1dAsync:gU,sigmoid:Wi,sign:RC,signal:j9,sin:nb,sinh:sb,slice:Yt,slice1d:Gm,slice2d:rb,slice3d:qm,slice4d:Yc,softmax:Km,softplus:Ru,spaceToBatchND:Bm,sparse:X9,sparseToDense:r7,spectral:K9,split:cr,sqrt:ys,square:pn,squaredDifference:ab,squeeze:Tl,stack:fr,step:Vu,stridedSlice:VC,string:Z9,sub:ut,sum:ft,tan:PC,tanh:ol,tensor:Dr,tensor1d:Ms,tensor2d:Lc,tensor3d:VU,tensor4d:PU,tensor5d:FU,tensor6d:zU,tensorScatterUpdate:WU,tile:Ur,topk:zC,transpose:Xt,truncatedNormal:lb,unique:MC,unsortedSegmentSum:ub,unstack:Jr,upperBound:KU,variable:WC,where:vs,whereAsync:BC,zeros:qn,zerosLike:Zt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gX=(n,e,t,s=Ns)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(C("a",n,e,t),C("b",n,e,t))];case"AddN":return[s.addN(C("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(C("a",n,e,t),C("b",n,e,t))];case"Mul":return[s.mul(C("a",n,e,t),C("b",n,e,t))];case"RealDiv":case"Div":return[s.div(C("a",n,e,t),C("b",n,e,t))];case"DivNoNan":return[s.divNoNan(C("a",n,e,t),C("b",n,e,t))];case"FloorDiv":return[s.floorDiv(C("a",n,e,t),C("b",n,e,t))];case"Sub":return[s.sub(C("a",n,e,t),C("b",n,e,t))];case"Minimum":return[s.minimum(C("a",n,e,t),C("b",n,e,t))];case"Maximum":return[s.maximum(C("a",n,e,t),C("b",n,e,t))];case"Pow":return[s.pow(C("a",n,e,t),C("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(C("a",n,e,t),C("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IX=(n,e,t,s=Ns)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(C("x",n,e,t))];case"Acos":return[s.acos(C("x",n,e,t))];case"Acosh":return[s.acosh(C("x",n,e,t))];case"Asin":return[s.asin(C("x",n,e,t))];case"Asinh":return[s.asinh(C("x",n,e,t))];case"Atan":return[s.atan(C("x",n,e,t))];case"Atan2":return[s.atan2(C("x",n,e,t),C("y",n,e,t))];case"Atanh":return[s.atanh(C("x",n,e,t))];case"Ceil":return[s.ceil(C("x",n,e,t))];case"Complex":return[s.complex(C("real",n,e,t),C("imag",n,e,t))];case"Cos":return[s.cos(C("x",n,e,t))];case"Cosh":return[s.cosh(C("x",n,e,t))];case"Elu":return[s.elu(C("x",n,e,t))];case"Erf":return[s.erf(C("x",n,e,t))];case"Exp":return[s.exp(C("x",n,e,t))];case"Expm1":return[s.expm1(C("x",n,e,t))];case"Floor":return[s.floor(C("x",n,e,t))];case"Log":return[s.log(C("x",n,e,t))];case"Log1p":return[s.log1p(C("x",n,e,t))];case"Imag":return[s.imag(C("x",n,e,t))];case"Neg":return[s.neg(C("x",n,e,t))];case"Reciprocal":return[s.reciprocal(C("x",n,e,t))];case"Real":return[s.real(C("x",n,e,t))];case"Relu":return[s.relu(C("x",n,e,t))];case"Round":return[s.round(C("x",n,e,t))];case"Selu":return[s.selu(C("x",n,e,t))];case"Sigmoid":return[s.sigmoid(C("x",n,e,t))];case"Sin":return[s.sin(C("x",n,e,t))];case"Sign":return[s.sign(C("x",n,e,t))];case"Sinh":return[s.sinh(C("x",n,e,t))];case"Softplus":return[s.softplus(C("x",n,e,t))];case"Sqrt":return[s.sqrt(C("x",n,e,t))];case"Square":return[s.square(C("x",n,e,t))];case"Tanh":return[s.tanh(C("x",n,e,t))];case"Tan":return[s.tan(C("x",n,e,t))];case"ClipByValue":return[s.clipByValue(C("x",n,e,t),C("clipValueMin",n,e,t),C("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(C("x",n,e,t))];case"Rsqrt":return[s.rsqrt(fs(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(C("x",n,e,t),C("alpha",n,e,t))];case"Prelu":return[s.prelu(C("x",n,e,t),C("alpha",n,e,t))];case"IsNan":return[s.isNaN(fs(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(fs(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(fs(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zr(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){W(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=e[s];W(r<0||i<0||r===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function k3(n){return!(typeof n=="number"||n.some(e=>e<0))}function pc(n,e,t){let s=VI(n,t);const r=!k3(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(i=>{s=VI(i.shape,s)}),!k3(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function VI(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],i=e[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yX{constructor(e,t,s,r,i,o,l){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=l,this.tensors=[],this.closed_=!1,this.idTensor=At(0),is(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),zr(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,is(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Dr([],[0].concat(this.elementShape));const s=this.readMany(e);return zr(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),fr(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Dr([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return zr(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Un(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Jr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(u=>(s+=u,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,o=[];pe(()=>{t=ie(t,[1,s,i]);for(let u=0;u<e.length;++u){const h=[0,u===0?0:r[u-1],0],f=[1,e[u],i];o[u]=ie(Yt(t,h,f),this.elementShape)}return o});const l=[];for(let u=0;u<e.length;u++)l[u]=u;this.writeMany(l,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dl{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);zr(t,i.shape,"TensorList shape mismatch: "),is(i)}),this.idTensor=At(0),this.maxNumElements=r,is(this.idTensor)}copy(){return new dl([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);zr(e,this.elementShape,"TensorList shape mismatch: ");const r=pc(this.elementShape,this.tensors,e);return pe(()=>{const i=this.tensors.map(o=>ie(o,r));return fr(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=pc(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,zr(r.shape,e,"TensorList shape mismatch: "),ie(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(zr(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");is(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new dl([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);zr(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=pc(this.elementShape,this.tensors,t);return ie(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);zr(this.elementShape,t.shape,"TensorList shape mismatch: "),is(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);zr(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=pc(this.elementShape,this.tensors,s);return e.length===0?Dr([],[0].concat(r)):pe(()=>{const i=e.map(o=>ie(this.tensors[o],r));return fr(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);zr(this.elementShape,t,"TensorList shape mismatch: ");const s=pc(this.elementShape,this.tensors,t);return this.size()===0?Dr([],[0].concat(s)):pe(()=>{const r=this.tensors.map(i=>ie(i,s));return Un(r,0)})}}function bX(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);zr(r,e,"TensorList shape mismatch: ");const i=Jr(n);return new dl(i,e,s)}function xX(n,e,t,s){return new dl([],n,e,s)}function NX(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new dl([],t,n.dtype,s),o=Jr(n,0);return e.forEach((l,u)=>{i.setItem(l,o[u])}),i}function wX(n,e,t){let s=0;const r=e.map(h=>(s+=h,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),o=VI(i,t),l=s===0?0:n.size/s,u=pe(()=>{const h=[];n=ie(n,[1,s,l]);for(let f=0;f<e.length;++f){const I=[0,f===0?0:r[f-1],0],y=[1,e[f],l];h[f]=ie(Yt(n,I,y),o)}return n.dispose(),h}),d=new dl([],t,n.dtype,e.length);for(let h=0;h<u.length;h++)d.setItem(h,u[h]);return d}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AX=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=C("thenBranch",n,e,t),r=C("elseBranch",n,e,t),i=C("cond",n,e,t),o=C("args",n,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=C("body",n,e,t),r=C("cond",n,e,t),i=C("args",n,e,t),o=await t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),l=i.map(h=>h.id);let u=await o[0].data();o.forEach(h=>{!h.kept&&l.indexOf(h.id)===-1&&h.dispose()});let d=i;for(;u[0];){const h=d;d=await t.functionMap[s].executeFunctionAsync(d,t.tensorArrayMap,t.tensorListMap);const f=d.map(I=>I.id);h.forEach(I=>{!I.kept&&l.indexOf(I.id)===-1&&f.indexOf(I.id)===-1&&I.dispose()});const m=await t.functionMap[r].executeFunctionAsync(d,t.tensorArrayMap,t.tensorListMap);u=await m[0].data(),m.forEach(I=>{!I.kept&&l.indexOf(I.id)===-1&&f.indexOf(I.id)===-1&&I.dispose()})}return d}case"LoopCond":{const s=C("pred",n,e,t);return[aa(s)]}case"Switch":{const s=C("pred",n,e,t);let r=C("data",n,e,t);return r.kept||(r=aa(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>fs(r,e,t)!==void 0);if(s){const r=fs(s,e,t);return[aa(r)]}return}case"Enter":{const s=C("frameName",n,e,t),r=C("tensor",n,e,t);return t.enterFrame(s),[aa(r)]}case"Exit":{const s=C("tensor",n,e,t);return t.exitFrame(),[aa(s)]}case"NextIteration":{const s=C("tensor",n,e,t);return t.nextIteration(),[aa(s)]}case"TensorArrayV3":{const s=C("size",n,e,t),r=C("dtype",n,e,t),i=C("elementShape",n,e,t),o=C("dynamicSize",n,e,t),l=C("clearAfterRead",n,e,t),u=C("identicalElementShapes",n,e,t),d=C("name",n,e,t),h=new yX(d,r,s,i,u,o,l);return t.addTensorArray(h),[h.idTensor,At(1)]}case"TensorArrayWriteV3":{const s=C("tensorArrayId",n,e,t),r=C("index",n,e,t),i=C("tensor",n,e,t),o=t.getTensorArray(s.id);return o.write(r,i),[o.idTensor]}case"TensorArrayReadV3":{const s=C("tensorArrayId",n,e,t),r=C("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=C("tensorArrayId",n,e,t),r=C("indices",n,e,t),i=C("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=C("tensorArrayId",n,e,t),r=C("indices",n,e,t),i=C("tensor",n,e,t),o=t.getTensorArray(s.id);return o.scatter(r,i),[o.idTensor]}case"TensorArrayConcatV3":{const s=C("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),i=C("dtype",n,e,t);return[r.concat(i)]}case"TensorArraySplitV3":{const s=C("tensorArrayId",n,e,t),r=C("tensor",n,e,t),i=C("lengths",n,e,t),o=t.getTensorArray(s.id);return o.split(i,r),[o.idTensor]}case"TensorArraySizeV3":{const s=C("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[At(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=C("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=C("tensorListId",n,e,t),r=C("index",n,e,t),i=C("tensor",n,e,t),o=t.getTensorList(s.id);return o.setItem(r,i),[o.idTensor]}case"TensorListGetItem":{const s=C("tensorListId",n,e,t),r=C("index",n,e,t),i=C("elementShape",n,e,t),o=C("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=C("indices",n,e,t),r=C("tensor",n,e,t),i=C("elementShape",n,e,t),o=C("numElements",n,e,t),l=NX(r,s,i,o);return t.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=C("elementShape",n,e,t),r=C("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=C(i,n,e,t),l=n.op==="TensorListReserve"?-1:o,u=xX(s,r,o,l);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=C("tensorListId",n,e,t),r=C("indices",n,e,t),i=C("elementShape",n,e,t),o=C("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,o,i)]}case"TensorListStack":{const s=C("tensorListId",n,e,t),r=C("elementShape",n,e,t),i=C("elementDType",n,e,t),o=C("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,i,o)]}case"TensorListFromTensor":{const s=C("tensor",n,e,t),r=C("elementShape",n,e,t),i=C("elementDType",n,e,t),o=bX(s,r,i);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=C("tensorListId",n,e,t),r=t.getTensorList(s.id),i=C("dtype",n,e,t),o=C("elementShape",n,e,t);return[r.concat(i,o)]}case"TensorListPushBack":{const s=C("tensorListId",n,e,t),r=C("tensor",n,e,t),i=t.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=C("tensorListId",n,e,t),r=C("elementShape",n,e,t),i=C("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=C("tensor",n,e,t),r=C("elementShape",n,e,t),i=C("lengths",n,e,t),o=wX(s,i,r);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const s=C("tensorListId",n,e,t),r=t.getTensorList(s.id);return[At(r.size(),"int32")]}case"TensorListResize":{const s=C("tensorListId",n,e,t),r=C("size",n,e,t),o=t.getTensorList(s.id).resize(r);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3(n,e,t){const[s,r]=C("fusedOps",n,e,t),i=s==="biasadd",o=!i,l=r==="prelu",u=s==="fusedbatchnorm",d=C("numArgs",n,e,t);if(i){if(l&&d!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&i&&d!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=C("strides",n,e,t),f=Sp(n,e,t),m=C("dataFormat",n,e,t).toUpperCase(),I=C("dilations",n,e,t);let[y,N]=C("args",n,e,t);o&&(N=y,y=void 0);const w=C("leakyreluAlpha",n,e,t);return{stride:h,pad:f,dataFormat:m,dilations:I,biasArg:y,preluArg:N,activationFunc:r,leakyreluAlpha:w}}const TX=(n,e,t,s=Ns)=>{switch(n.op){case"Conv1D":{const r=C("stride",n,e,t),i=C("pad",n,e,t),o=C("dataFormat",n,e,t).toUpperCase(),l=C("dilation",n,e,t);return[s.conv1d(C("x",n,e,t),C("filter",n,e,t),r,i,o,l)]}case"Conv2D":{const r=C("strides",n,e,t),i=Sp(n,e,t),o=C("dataFormat",n,e,t).toUpperCase(),l=C("dilations",n,e,t);return[s.conv2d(C("x",n,e,t),C("filter",n,e,t),[r[1],r[2]],i,o,[l[1],l[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:o,dilations:l,biasArg:u,preluArg:d,activationFunc:h,leakyreluAlpha:f}=C3(n,e,t);return[s.fused.conv2d({x:C("x",n,e,t),filter:C("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[l[1],l[2]],bias:u,activation:h,preluActivationWeights:d,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:o,dilations:l,biasArg:u,preluArg:d,activationFunc:h,leakyreluAlpha:f}=C3(n,e,t);return[s.fused.depthwiseConv2d({x:C("x",n,e,t),filter:C("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[l[1],l[2]],bias:u,activation:h,preluActivationWeights:d,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=C("outputShape",n,e,t),i=C("strides",n,e,t),o=Sp(n,e,t);return[s.conv2dTranspose(C("x",n,e,t),C("filter",n,e,t),r,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=C("strides",n,e,t),i=Sp(n,e,t),o=C("dilations",n,e,t),l=C("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(C("input",n,e,t),C("filter",n,e,t),[r[1],r[2]],i,l,[o[1],o[2]])]}case"Conv3D":{const r=C("strides",n,e,t),i=C("pad",n,e,t),o=C("dataFormat",n,e,t).toUpperCase(),l=C("dilations",n,e,t);return[s.conv3d(C("x",n,e,t),C("filter",n,e,t),[r[1],r[2],r[3]],i,o,[l[1],l[2],l[3]])]}case"AvgPool":{const r=C("strides",n,e,t),i=C("pad",n,e,t),o=C("kernelSize",n,e,t);return[s.avgPool(C("x",n,e,t),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=C("strides",n,e,t),i=C("pad",n,e,t),o=C("kernelSize",n,e,t);return[s.maxPool(C("x",n,e,t),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=C("strides",n,e,t),i=C("pad",n,e,t),o=C("kernelSize",n,e,t),l=C("includeBatchInIndex",n,e,t),{result:u,indexes:d}=s.maxPoolWithArgmax(C("x",n,e,t),[o[1],o[2]],[r[1],r[2]],i,l);return[u,d]}case"AvgPool3D":{const r=C("strides",n,e,t),i=C("pad",n,e,t),o=C("kernelSize",n,e,t);return[s.avgPool3d(C("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=C("strides",n,e,t),i=C("pad",n,e,t),o=C("kernelSize",n,e,t);return[s.maxPool3d(C("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=C("strides",n,e,t),i=C("pad",n,e,t),o=C("dilations",n,e,t),l=r[1],u=r[2],d=o[1],h=o[2];return[s.dilation2d(C("x",n,e,t),C("filter",n,e,t),[l,u],i,[d,h],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SX=(n,e,t,s=Ns)=>{switch(n.op){case"Fill":{const r=C("shape",n,e,t),i=C("dtype",n,e,t),o=C("value",n,e,t);return[s.fill(r,o,i)]}case"LinSpace":{const r=C("start",n,e,t),i=C("stop",n,e,t),o=C("num",n,e,t);return[s.linspace(r,i,o)]}case"Multinomial":{const r=C("logits",n,e,t),i=C("numSamples",n,e,t),o=C("seed",n,e,t);return[s.multinomial(r,i,o)]}case"OneHot":{const r=C("indices",n,e,t),i=C("depth",n,e,t),o=C("onValue",n,e,t),l=C("offValue",n,e,t),u=C("dtype",n,e,t);return[s.oneHot(r,i,o,l,u)]}case"Ones":return[s.ones(C("shape",n,e,t),C("dtype",n,e,t))];case"OnesLike":return[s.onesLike(C("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(C("shape",n,e,t),C("dtype",n,e,t),C("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(C("shape",n,e,t),C("minval",n,e,t),C("maxval",n,e,t),C("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(C("shape",n,e,t),C("minval",n,e,t),C("maxval",n,e,t),C("seed",n,e,t))];case"Range":{const r=C("start",n,e,t),i=C("stop",n,e,t),o=C("step",n,e,t);return[s.range(r,i,o,C("dtype",n,e,t))]}case"TruncatedNormal":{const r=C("shape",n,e,t),i=C("mean",n,e,t),o=C("stdDev",n,e,t),l=C("seed",n,e,t);return[s.truncatedNormal(r,i,o,C("dtype",n,e,t),l)]}case"Zeros":return[s.zeros(C("shape",n,e,t),C("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(C("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1(n,e,t){const s=C("boxes",n,e,t),r=C("scores",n,e,t),i=C("maxOutputSize",n,e,t),o=C("iouThreshold",n,e,t),l=C("scoreThreshold",n,e,t),u=C("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}}const vX=async(n,e,t,s,r=Ns)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:l,iouThreshold:u,scoreThreshold:d,softNmsSigma:h}=N1(n,e,t),f=await r.image.nonMaxSuppressionWithScoreAsync(i,o,l,u,d,h);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:l,iouThreshold:u,scoreThreshold:d}=N1(n,e,t),h=C("padToMaxOutputSize",n,e,t),f=await r.image.nonMaxSuppressionPaddedAsync(i,o,l,u,d,h);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:l,iouThreshold:u,scoreThreshold:d}=N1(n,e,t);return[await r.image.nonMaxSuppressionAsync(i,o,l,u,d)]}case"Where":{const i=r.cast(C("condition",n,e,t),"bool"),o=[await r.whereAsync(i)];return i.dispose(),o}case"ListDiff":return r.setdiff1dAsync(C("x",n,e,t),C("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $X=(n,e,t,s=Ns)=>{switch(n.op){case"LowerBound":{const r=C("sortedSequence",n,e,t),i=C("values",n,e,t);return[s.lowerBound(r,i)]}case"TopKV2":{const r=C("x",n,e,t),i=C("k",n,e,t),o=C("sorted",n,e,t),l=s.topk(r,i,o);return[l.values,l.indices]}case"UpperBound":{const r=C("sortedSequence",n,e,t),i=C("values",n,e,t);return[s.upperBound(r,i)]}case"Unique":{const r=C("x",n,e,t),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=C("x",n,e,t),i=C("axis",n,e,t),o=s.unique(r,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _X=(n,e,t,s=Ns)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=C("default",n,e,t);return[fs(n.name,e,t)||r];case"Placeholder":return[fs(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=C("x",n,e,t);return[aa(h)]}case"IdentityN":return C("x",n,e,t).map(h=>aa(h));case"Snapshot":const i=C("x",n,e,t);return[aa(i)];case"Shape":return[s.tensor1d(C("x",n,e,t).shape,"int32")];case"ShapeN":return C("x",n,e,t).map(h=>s.tensor1d(h.shape));case"Size":return[s.scalar(C("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(C("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=C("x",n,e,t),l=C("data",n,e,t),u=C("message",n,e,t),d=C("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let h=0;h<l.length;h++)console.log(Array.prototype.slice.call(l[h].dataSync()).slice(0,d));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DX{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=At(0),this.tensorMap=new Map,is(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return At(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),pe(()=>{const r=Jr(t),i=s.length,o=r.length;W(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let l=0;l<i;l++){const u=s[l],d=r[l];is(d),this.tensorMap.set(u,d)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return pe(()=>{const r=[];for(let i=0;i<s.length;i++){const o=s[i],l=this.findWithDefault(o,t);r.push(l)}return fr(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EX=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const i=C("keyDType",n,e,t),o=C("valueDType",n,e,t),l=new DX(i,o);return s.addHashTable(n.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=C("tableHandle",n,e,t,s),i=C("keys",n,e,t),o=C("values",n,e,t);return[await s.getHashTableById(r.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=C("tableHandle",n,e,t,s),i=C("keys",n,e,t),o=C("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=C("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kX=(n,e,t,s=Ns)=>{switch(n.op){case"ResizeBilinear":{const r=C("images",n,e,t),i=C("size",n,e,t),o=C("alignCorners",n,e,t),l=C("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[i[0],i[1]],o,l)]}case"ResizeNearestNeighbor":{const r=C("images",n,e,t),i=C("size",n,e,t),o=C("alignCorners",n,e,t),l=C("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],o,l)]}case"CropAndResize":{const r=C("image",n,e,t),i=C("boxes",n,e,t),o=C("boxInd",n,e,t),l=C("cropSize",n,e,t),u=C("method",n,e,t),d=C("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,i,o,l,u,d)]}case"ImageProjectiveTransformV3":{const r=C("images",n,e,t),i=C("transforms",n,e,t),o=C("outputShape",n,e,t),l=C("fillValue",n,e,t),u=C("interpolation",n,e,t),d=C("fillMode",n,e,t);return[s.image.transform(r,i,u.toLowerCase(),d.toLowerCase(),l,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CX=(n,e,t,s=Ns)=>{switch(n.op){case"Equal":return[s.equal(C("a",n,e,t),C("b",n,e,t))];case"NotEqual":return[s.notEqual(C("a",n,e,t),C("b",n,e,t))];case"Greater":return[s.greater(C("a",n,e,t),C("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(C("a",n,e,t),C("b",n,e,t))];case"Less":return[s.less(C("a",n,e,t),C("b",n,e,t))];case"LessEqual":return[s.lessEqual(C("a",n,e,t),C("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(C("a",n,e,t),C("b",n,e,t))];case"LogicalNot":return[s.logicalNot(C("a",n,e,t))];case"LogicalOr":return[s.logicalOr(C("a",n,e,t),C("b",n,e,t))];case"Select":case"SelectV2":return[s.where(C("condition",n,e,t),C("a",n,e,t),C("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(C("a",n,e,t),C("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LX=(n,e,t,s=Ns)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(C("a",n,e,t),C("b",n,e,t),C("transposeA",n,e,t),C("transposeB",n,e,t))];case"Einsum":return[s.einsum(C("equation",n,e,t),...C("tensors",n,e,t))];case"Transpose":return[s.transpose(C("x",n,e,t),C("perm",n,e,t))];case"_FusedMatMul":const[r,i]=C("fusedOps",n,e,t),o=r==="biasadd",l=i==="prelu",u=C("numArgs",n,e,t),d=C("leakyreluAlpha",n,e,t);if(o){if(l&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,f]=C("args",n,e,t);return[s.fused.matMul({a:C("a",n,e,t),b:C("b",n,e,t),transposeA:C("transposeA",n,e,t),transposeB:C("transposeB",n,e,t),bias:h,activation:i,preluActivationWeights:f,leakyreluAlpha:d})];case"MatrixBandPart":return[s.linalg.bandPart(C("a",n,e,t),C("numLower",n,e,t),C("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OX=(n,e,t,s=Ns)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(C("x",n,e,t),C("axis",n,e,t),C("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(C("x",n,e,t),C("mean",n,e,t),C("variance",n,e,t),C("offset",n,e,t),C("scale",n,e,t),C("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(C("x",n,e,t),C("mean",n,e,t),C("variance",n,e,t),C("offset",n,e,t),C("scale",n,e,t),C("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(C("x",n,e,t),C("radius",n,e,t),C("bias",n,e,t),C("alpha",n,e,t),C("beta",n,e,t))];case"Softmax":return[s.softmax(C("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(C("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RX=(n,e,t,s=Ns)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=s.raggedGather(C("paramsNestedSplits",n,e,t),C("paramsDenseValues",n,e,t),C("indices",n,e,t),C("outputRaggedRank",n,e,t));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=s.raggedRange(C("starts",n,e,t),C("limits",n,e,t),C("splits",n,e,t));return[r,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(C("shape",n,e,t),C("values",n,e,t),C("defaultValue",n,e,t),C("rowPartitionTensors",n,e,t),C("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VX=(n,e,t,s=Ns)=>{switch(n.op){case"Max":{const l=C("axis",n,e,t),u=C("keepDims",n,e,t);return[s.max(C("x",n,e,t),l,u)]}case"Mean":{const l=C("axis",n,e,t),u=C("keepDims",n,e,t);return[s.mean(C("x",n,e,t),l,u)]}case"Min":{const l=C("axis",n,e,t),u=C("keepDims",n,e,t);return[s.min(C("x",n,e,t),l,u)]}case"Sum":{const l=C("axis",n,e,t),u=C("keepDims",n,e,t);return[s.sum(C("x",n,e,t),l,u)]}case"All":{const l=C("axis",n,e,t),u=C("keepDims",n,e,t);return[s.all(C("x",n,e,t),l,u)]}case"Any":{const l=C("axis",n,e,t),u=C("keepDims",n,e,t);return[s.any(C("x",n,e,t),l,u)]}case"ArgMax":{const l=C("axis",n,e,t);return[s.argMax(C("x",n,e,t),l)]}case"ArgMin":{const l=C("axis",n,e,t);return[s.argMin(C("x",n,e,t),l)]}case"Prod":{const l=C("axis",n,e,t),u=C("keepDims",n,e,t);return[s.prod(C("x",n,e,t),l,u)]}case"Cumprod":{const l=C("axis",n,e,t),u=C("exclusive",n,e,t),d=C("reverse",n,e,t);return[s.cumprod(C("x",n,e,t),l,u,d)]}case"Cumsum":{const l=C("axis",n,e,t),u=C("exclusive",n,e,t),d=C("reverse",n,e,t);return[s.cumsum(C("x",n,e,t),l,u,d)]}case"Bincount":const r=C("x",n,e,t),i=C("weights",n,e,t),o=C("size",n,e,t);return[s.bincount(r,i,o)];case"DenseBincount":{const l=C("x",n,e,t),u=C("weights",n,e,t),d=C("size",n,e,t),h=C("binaryOutput",n,e,t);return[s.denseBincount(l,u,d,h)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PX=(n,e,t,s=Ns)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=C("n",n,e,t),i=C("axis",n,e,t);let o=C("tensors",n,e,t);return o=o.slice(0,r),[s.concat(o,i)]}case"Gather":{const r=C("x",n,e,t),i=C("indices",n,e,t);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=C("axis",n,e,t),i=C("batchDims",n,e,t),o=C("x",n,e,t),l=C("indices",n,e,t);return[s.gather(o,s.cast(l,"int32"),r,i)]}case"Reverse":{const r=C("dims",n,e,t),i=[];for(let l=0;l<r.length;l++)r[l]&&i.push(l);const o=C("x",n,e,t);return[s.reverse(o,i)]}case"ReverseV2":{const r=C("axis",n,e,t),i=C("x",n,e,t);return[s.reverse(i,r)]}case"Slice":{const r=C("begin",n,e,t),i=C("size",n,e,t);return[s.slice(C("x",n,e,t),r,i)]}case"StridedSlice":{const r=C("begin",n,e,t),i=C("end",n,e,t),o=C("strides",n,e,t),l=C("beginMask",n,e,t),u=C("endMask",n,e,t),d=C("ellipsisMask",n,e,t),h=C("newAxisMask",n,e,t),f=C("shrinkAxisMask",n,e,t),m=C("x",n,e,t);return[s.stridedSlice(m,r,i,o,l,u,d,h,f)]}case"Pack":return pe(()=>{const r=C("axis",n,e,t),i=C("tensors",n,e,t),o=i[0].shape,l=s.squeeze(i[0]).shape,u=i.map(d=>{const h=Kt(d.shape,o);if(!h&&!Kt(s.squeeze(d).shape,l))throw new Error("the input tensors shape does not match");return h?d:s.reshape(d,o)});return[s.stack(u,r)]});case"Unpack":{const r=C("axis",n,e,t),i=C("tensor",n,e,t);return s.unstack(i,r)}case"Tile":{const r=C("reps",n,e,t);return[s.tile(C("x",n,e,t),r)]}case"Split":case"SplitV":{const r=C("axis",n,e,t),i=C("numOrSizeSplits",n,e,t),o=C("x",n,e,t);return s.split(o,i,r)}case"ScatterNd":{const r=C("indices",n,e,t),i=C("values",n,e,t),o=C("shape",n,e,t);return[s.scatterND(r,i,o)]}case"GatherNd":{const r=C("x",n,e,t),i=C("indices",n,e,t);return[s.gatherND(r,i)]}case"SparseToDense":{const r=C("sparseIndices",n,e,t),i=C("outputShape",n,e,t),o=C("sparseValues",n,e,t),l=C("defaultValue",n,e,t);return[s.sparseToDense(r,o,i,o.dtype===l.dtype?l:s.cast(l,o.dtype))]}case"TensorScatterUpdate":{const r=C("indices",n,e,t),i=C("values",n,e,t),o=C("tensor",n,e,t);return[s.tensorScatterUpdate(o,r,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FX=(n,e,t,s=Ns)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:o,reverseIndexMap:l}=s.sparse.sparseFillEmptyRows(C("indices",n,e,t),C("values",n,e,t),C("denseShape",n,e,t),C("defaultValue",n,e,t));return[r,i,o,l]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape(C("inputIndices",n,e,t),C("inputShape",n,e,t),C("newShape",n,e,t));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(C("data",n,e,t),C("indices",n,e,t),C("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(C("data",n,e,t),C("indices",n,e,t),C("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zX=(n,e,t,s=Ns)=>{switch(n.op){case"FFT":return[s.fft(C("x",n,e,t))];case"IFFT":return[s.ifft(C("x",n,e,t))];case"RFFT":return[s.rfft(C("x",n,e,t))];case"IRFFT":return[s.irfft(C("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MX=(n,e,t,s=Ns)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(C("input",n,e,t),C("pattern",n,e,t),C("rewrite",n,e,t),C("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams(C("data",n,e,t),C("dataSplits",n,e,t),C("separator",n,e,t),C("nGramWidths",n,e,t),C("leftPad",n,e,t),C("rightPad",n,e,t),C("padWidth",n,e,t),C("preserveShortSequences",n,e,t));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:o}=s.string.stringSplit(C("input",n,e,t),C("delimiter",n,e,t),C("skipEmpty",n,e,t));return[r,i,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(C("input",n,e,t),C("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WX=(n,e,t,s=Ns)=>{switch(n.op){case"Cast":return[s.cast(C("x",n,e,t),C("dtype",n,e,t))];case"ExpandDims":{const r=C("axis",n,e,t);return[s.expandDims(C("x",n,e,t),r)]}case"Squeeze":{const r=C("axis",n,e,t);return[s.squeeze(C("x",n,e,t),r)]}case"Reshape":return[s.reshape(C("x",n,e,t),C("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(C("x",n,e,t),C("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(C("x",n,e,t),C("padding",n,e,t),C("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(C("x",n,e,t),C("padding",n,e,t),C("constantValue",n,e,t))];case"SpaceToBatchND":{const r=C("blockShape",n,e,t),i=C("paddings",n,e,t);return[s.spaceToBatchND(C("x",n,e,t),r,i)]}case"BatchToSpaceND":{const r=C("blockShape",n,e,t),i=C("crops",n,e,t);return[s.batchToSpaceND(C("x",n,e,t),r,i)]}case"DepthToSpace":{const r=C("blockSize",n,e,t),i=C("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(C("x",n,e,t),r,i)]}case"BroadcastTo":return[s.broadcastTo(C("x",n,e,t),C("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(C("s0",n,e,t),C("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3(n,e,t,s,r=pe){const i=((o,l,u)=>{switch(o.category){case"arithmetic":return r(()=>gX(o,l,u));case"basic_math":return r(()=>IX(o,l,u));case"control":return AX(o,l,u);case"convolution":return r(()=>TX(o,l,u));case"creation":return r(()=>SX(o,l,u));case"dynamic":return vX(o,l,u);case"evaluation":return r(()=>$X(o,l,u));case"image":return r(()=>kX(o,l,u));case"graph":return r(()=>_X(o,l,u));case"logical":return r(()=>CX(o,l,u));case"matrices":return r(()=>LX(o,l,u));case"normalization":return r(()=>OX(o,l,u));case"ragged":return r(()=>RX(o,l,u));case"reduction":return r(()=>VX(o,l,u));case"slice_join":return r(()=>PX(o,l,u));case"sparse":return r(()=>FX(o,l,u));case"spectral":return r(()=>zX(o,l,u));case"string":return r(()=>MX(o,l,u));case"transformation":return r(()=>WX(o,l,u));case"hash_table":return EX(o,l,u,s);case"custom":const d=oR(o.op);if(d&&d.customExecutor)return d.customExecutor(new mX(o,l,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return tl(i)?i.then(o=>[].concat(o)):[].concat(i)}class O3{constructor(e={},t={},s={},r={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3(n,e,t,s){const r=new Set,i=[];let o=null,l=null;const u=new Set,d=new Set(Object.keys(n).map(m=>ar(m)[0]));s=s||[];const h=new Set(s.map(m=>ar(m.name)[0])),f=[...e];for(;f.length>0;){const m=f.pop();if((Wo(m)||YX(m)||XX(m))&&o==null&&(o=m,l=o.children.map(I=>I.name).filter(I=>r.has(I))),r.add(m.name),t[m.name]==null&&!d.has(m.name)&&!h.has(m.name)){if(m.inputs.length===0){i.push(m.name);continue}m.inputs.forEach(I=>{u.has(I.name)||(u.add(I.name),f.push(I))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:i,dynamicNode:o,syncInputs:l}}function BX(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(w=>ar(w)[0]).map(w=>n.nodes[w]),i=n.initNodes||[],o=w=>t.has(typeof w=="string"?w:w.name);function l(w){return[...new Map(w.map(T=>[T.name,T])).values()]}const u=l([...r,...n.weights,...i]).filter(o),d=l([...u,...Object.values(n.nodes)]).filter(o),h=new Map(d.map(w=>[w.name,w])),f={};for(const w of d){f[w.name]=f[w.name]||0;for(const T of w.children)o(T)||(f[T.name]=Number.POSITIVE_INFINITY),f[T.name]=(f[T.name]||0)+1}const m=Object.entries(f).filter(([,w])=>w===0).map(([w])=>w),I=[...m];for(;m.length>0;){const w=m.pop(),T=h.get(w);for(const v of T.children.filter(o))--f[v.name]===0&&(I.push(v.name),m.push(v.name))}const y=I.map(w=>h.get(w)),N=HX(y,u);return UX(N,u),N}function HX(n,e){const t=new Map(n.map(o=>[o.name,o])),s=e.map(o=>o.name),r=new Set(s);for(;s.length>0;){const o=s.pop(),l=t.get(o);for(const u of l.children)!t.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return n.filter(o=>r.has(o.name))}class op extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function UX(n,e){const t=new Map(n.map((l,u)=>[l.name,u])),s=new Set(e.map(l=>l.name)),r=l=>s.has(typeof l=="string"?l:l.name),i=new Set(n.map(l=>l.name)),o=l=>i.has(typeof l=="string"?l:l.name);for(const l of n){for(const u of l.children.filter(o)){if(!t.has(u.name))throw new op(`Child ${u.name} of node ${l.name} is unreachable.`);if(t.get(l.name)>t.get(u.name))throw new op(`Node ${l.name} is scheduled to run after its child ${u.name}.`)}if(!r(l))for(const u of l.inputs){if(!t.has(u.name))throw new op(`Input ${u.name} of node ${l.name} is unreachable.`);if(t.get(u.name)>t.get(l.name))throw new op(`Node ${l.name} is scheduled to run before its input ${u.name}.`)}}}function GX(n){const e=new Map(n.map((l,u)=>[l.name,u])),t=Number.MAX_SAFE_INTEGER,s=n.map((l,u)=>Wo(l)?t:u),r=l=>{const u=s[e.get(l.name)];return u??-1},i=n.map((l,u)=>l.children.map(r).reduce((d,h)=>Math.max(d,h),s[u])),o=new Map;for(let l=0;l<n.length;++l){const u=i[l];if(u===t)continue;const d=n[l],h=n[u];o.has(h.name)||o.set(h.name,[]),o.get(h.name).push(d)}return o}const qX=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),KX=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),jX=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Wo(n){return qX.has(n.op)}function YX(n){return KX.has(n.op)}function XX(n){return jX.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rf{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new rf(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),r=t.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=R3(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:o}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const d=t.map(f=>f.name),h=Object.keys(e);throw new Error(`Cannot compute the outputs [${d}] from the provided inputs [${h}]. Missing the following inputs: [${r}]`)}const l=BX(this.graph,s),u=GX(l);return{orderedNodes:l,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return is(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(m=>this.graph.nodes[ar(m)[0]]),i=t.map(m=>ar(m)[0]),o=new Set(i);let l=i.map(m=>this.graph.nodes[m]);l.length===0&&(l=this._outputs);const u=this.getCompilationKey(r,l);let d=this.compiledMap.get(u);d==null&&(d=this.compile(e,l),this.compiledMap.set(u,d));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const h={},f={};return pe(()=>{const m=new O3(this.weightMap,h,f,this.functionExecutorMap,this.parseNodeNameCache),I=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(T=>{const[v,E]=ar(T,m),_=[];_[E]=e[T],I[v]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(_))});const y=this.getFrozenTensorIds(I),{orderedNodes:N,nodeLiveUntilMap:w}=d;for(const T of N){if(I[T.name])continue;const v=L3(T,I,m,this._resourceManager);if(tl(v))throw new Error(`The execution of the op '${T.op}' returned a promise. Please use model.executeAsync() instead.`);I[T.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[T.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(T,I,m,y,o,w.get(T.name))}return this.parent==null&&m.dispose(y),t.map(T=>fs(T,I,m))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,i,o,l){if(!(Wo(t)||o.has(e))){for(const u of s[e])u!=null&&(l[u.id]=(l[u.id]||0)+t.children.length);for(const u of t.inputs){if(Wo(u))continue;const d=_3(u.name,s,r);if(d!=null)for(const h of d){if(!h||h.kept||i.has(h.id))continue;const f=l[h.id];f===1?(h.dispose(),delete l[h.id]):f!=null&&l[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,i,o){function l(u){return Wo(u)||i.has(u.name)}if(!(Wo(e)||o==null))for(const u of o){if(l(u))continue;const d=_3(u.name,t,s);for(const h of d)!h||h.kept||r.has(h.id)||h.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},i={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const o=new O3(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const l=await this.executeWithControlFlow(e,o,t,s),u=t.map(m=>fs(m,l,o)),d=u.map(m=>m.id),h=Object.keys(e).map(m=>e[m].id),f=new Set([...d,...h,...this.weightIds]);return Object.values(l).forEach(m=>{m.forEach(I=>{I&&!I.isDisposed&&!f.has(I.id)&&I.dispose()})}),this.parent==null&&o.dispose(f),u}async executeFunctionAsync(e,t,s){const r=e.reduce((i,o,l)=>(i[this.inputs[l].name]=o,i),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const i=Object.keys(e),o=i.map(_=>this.graph.nodes[ar(_)[0]]),l=s.map(_=>ar(_)[0]),u=new Set(l);let d=l.map(_=>this.graph.nodes[_]);d.length===0&&(d=this._outputs);const{usedNodes:h,missingInputs:f,dynamicNode:m,syncInputs:I}=R3(e,d,this.weightMap,this._initNodes),y=[...o,...this.graph.weights,...this._initNodes||[]].map(_=>({node:_,contexts:t.currentContext})),N=Object.assign({},this.weightMap);Object.keys(e).forEach(_=>{const[L,P]=ar(_),B=[];B[P]=e[_],N[L]=B});const w={},T=this.getFrozenTensorIds(N),v={};for(;y.length>0;){const _=this.processStack(o,y,t,N,v,T,u,w,h);await Promise.all(_)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const E=d.filter(_=>!Wo(_)&&!fs(_.name,N,t)).map(_=>_.name);if(E.length>0){let _="";throw m!=null&&(_=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${I}]`),new Error(`Cannot compute the outputs [${E}] from the provided inputs [${i}]. Consider providing the following inputs: [${f}]. ${_}`)}return N}processStack(e,t,s,r,i,o,l,u,d){const h=[];for(;t.length>0;){const f=t.pop();s.currentContext=f.contexts;let m="";if(f.node.op==="Enter"&&C("isConstant",f.node,r,s)&&([m]=ia(f.node.name,s)),r[f.node.name]==null){const I=L3(f.node,r,s,this._resourceManager);m||([m]=ia(f.node.name,s));const y=s.currentContext;tl(I)?h.push(I.then(N=>(r[m]=N,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(N)),s.currentContext=y,this.checkTensorForDisposal(m,f.node,r,s,o,l,u),this.processChildNodes(f.node,t,s,r,i,d),N))):(r[m]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(I)),this.checkTensorForDisposal(m,f.node,r,s,o,l,u),this.processChildNodes(f.node,t,s,r,i,d))}else this.processChildNodes(f.node,t,s,r,i,d)}return h}processChildNodes(e,t,s,r,i,o){e.children.forEach(l=>{const[u]=ia(l.name,s);i[u]||!o.has(l.name)||(l.op==="Merge"?l.inputNames.some(d=>!!fs(d,r,s))&&(i[u]=!0,t.push({contexts:s.currentContext,node:l})):l.inputNames.every(d=>!!fs(d,r,s))&&(i[u]=!0,t.push({contexts:s.currentContext,node:l})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=ar(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,l=o.length===s.shape.length&&s.shape.every((u,d)=>o[d]===-1||o[d]===u);W(l,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&W(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const i in e){const o=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[i];o!=null?r[o.name]=e[i]:r[i]=e[i]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=ar(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const i=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=ar(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class ZX{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QX="?tfjs-format=file",JX="model.json";class eZ{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=cL){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new ZX}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return tl(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await Ok(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new rf(D3.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=D3.Instance.transformGraph(e.modelInitializer);this.initializer=new rf(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof $n?[e]:e,s={};return t.forEach((r,i)=>s[this.structuredOutputKeys[i]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof $n)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const o in i){const l=i[o];l.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[l.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,o)=>{var l,u,d;const h=(d=(u=(l=this.signature)===null||l===void 0?void 0:l.inputs)===null||u===void 0?void 0:u[o])===null||d===void 0?void 0:d.resourceId;return h!=null?i[o]=this.resourceIdToCapturedInput[h]:i[o]=e[r++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const i=s[r],o=t[i];this.resourceIdToCapturedInput[o.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ft(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function tZ(n,e={},t=cL){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=nZ(n));const s=new eZ(n,e,t);return await s.load(),s}function nZ(n){return n.endsWith("/")||(n=n+"/"),`${n}${JX}${QX}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var V3;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(V3||(V3={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&W(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sZ=cb;class fg extends gy{nextDataId(){return fg.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new nk(this,Fr())}write(e,t,s){this.firstUse&&(this.firstUse=!1,xe().get("IS_NODE")&&vr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&cd(s[0])){const i=s.map(o=>Ba(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return ga(r,i)}return uM(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ga(r));return zt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(e.shape,e.dtype,t)}makeOutput(e,t,s){return Fr().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=js();return e(),{kernelMs:js()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){mt([e],"where");const t=this.readSync(e.dataId);return sZ(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}fg.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const rZ=n=>{const{x:e}=n.inputs,t=n.backend;mt(e,"abs");let s=new Float32Array(Te(e.shape));const r=t.data.get(e.dataId).values;return s=cR(r),t.makeOutput(s,e.shape,e.dtype)},iZ={kernelName:_f,backendName:"cpu",kernelFunc:rZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(n){return(e,t,s,r,i)=>{const o=Lt(e,t),l=o.length,u=wt(o),d=Te(o),h=Is(i,d),f=e.length,m=t.length,I=wt(e),y=wt(t),N=yu(e,o),w=yu(t,o);if(N.length+w.length===0)for(let T=0;T<h.length;++T)h[T]=n(s[T%s.length],r[T%r.length]);else for(let T=0;T<h.length;++T){const v=Cu(T,l,u),E=v.slice(-f);N.forEach(B=>E[B]=0);const _=Mi(E,f,I),L=v.slice(-m);w.forEach(B=>L[B]=0);const P=Mi(L,m,y);h[T]=n(s[_],r[P])}return[h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function or(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.makeTensorInfo(s.shape,"complex64"),u=t.data.get(l.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",o)},l}const aZ={kernelName:vy,backendName:"cpu",kernelFunc:or};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function af(n,e,t="float32"){if(t==="complex64"){const r=af(n,e,"float32"),i=af(n,e,"float32");return or({inputs:{real:r,imag:i},backend:n})}const s=$s(Te(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yi(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const oZ={kernelName:kd,backendName:"cpu",kernelFunc:Yi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hl(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const lZ={kernelName:r2,backendName:"cpu",kernelFunc:hl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dR(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=xl([0],t),[i,o]=Wn((l,u)=>l!==u?1:0)(e,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function eo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Yi({inputs:{x:r},backend:t});const h=af(t,r.shape,r.dtype),f=eo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),m=or({inputs:{real:f,imag:h},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),m}if(r.dtype==="complex64"){const h=hl({inputs:{input:r},backend:t}),f=eo({inputs:{x:h},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(h),f}if(!rk(r.dtype,i)){const h=Yi({inputs:{x:r},backend:t});return{dataId:h.dataId,shape:h.shape,dtype:i}}const o=t.data.get(r.dataId).values,[l,u,d]=dR(o,r.shape,r.dtype,i);return t.makeTensorInfo(l,u,d)}const uZ={kernelName:yd,backendName:"cpu",kernelFunc:eo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function es(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a:o,b:l}=r,u=i;mt([o,l],n);const d=u.data.get(o.dataId).values,h=u.data.get(l.dataId).values,f=o.dtype==="string"?Ia(d):d,m=o.dtype==="string"?Ia(h):h,I=s||o.dtype,[y,N]=e(o.shape,l.shape,f,m,I);return u.makeTensorInfo(N,I,y)}:({inputs:r,backend:i})=>{const{a:o,b:l}=r,u=i;if(o.dtype==="complex64"||l.dtype==="complex64"){const d=eo({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),h=u.data.get(d.dataId),f=h.complexTensorInfos.real,m=h.complexTensorInfos.imag,I=u.data.get(f.dataId).values,y=u.data.get(m.dataId).values,N=eo({inputs:{x:l},backend:u,attrs:{dtype:"complex64"}}),w=u.data.get(N.dataId),T=w.complexTensorInfos.real,v=w.complexTensorInfos.imag,E=u.data.get(T.dataId).values,_=u.data.get(v.dataId).values,[L,P,B]=t(o.shape,l.shape,I,y,E,_),U=u.makeTensorInfo(B,"float32",L),Z=u.makeTensorInfo(B,"float32",P),Y=or({inputs:{real:U,imag:Z},backend:u});return u.disposeIntermediateTensorInfo(d),u.disposeIntermediateTensorInfo(N),u.disposeIntermediateTensorInfo(U),u.disposeIntermediateTensorInfo(Z),Y}else{const d=u.data.get(o.dataId).values,h=u.data.get(l.dataId).values,f=s||o.dtype,[m,I]=e(o.shape,l.shape,d,h,f);return u.makeTensorInfo(I,f,m)}}}function fx(n){return(e,t,s,r,i,o)=>{const l=Lt(e,t),u=Te(l),d=l.length,h=wt(l),f=Is("float32",u),m=Is("float32",u),I=yu(e,l),y=yu(t,l),N=ga(s,r),w=ga(i,o),T=e.length,v=wt(e),E=t.length,_=wt(t);if(I.length+y.length===0)for(let L=0;L<f.length;L++){const P=L%N.length,B=L%w.length,U=n(N[P*2],N[P*2+1],w[B*2],w[B*2+1]);f[L]=U.real,m[L]=U.imag}else for(let L=0;L<f.length;L++){const P=Cu(L,d,h),B=P.slice(-T);I.forEach(de=>B[de]=0);const U=Mi(B,T,v),Z=P.slice(-E);y.forEach(de=>Z[de]=0);const Y=Mi(Z,E,_),ae=n(N[U*2],N[U*2+1],w[Y*2],w[Y*2+1]);f[L]=ae.real,m[L]=ae.imag}return[f,m,l]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hR=Wn((n,e)=>n+e),cZ=fx((n,e,t,s)=>({real:n+t,imag:e+s})),wu=es(Lu,hR,cZ),dZ={kernelName:Lu,backendName:"cpu",kernelFunc:wu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mx(n,e,t,s,r){const i=Te(s),o=$s(r,t);for(let l=0;l<n.length;l++){const u=n[l];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(i>0?o[u]+=e[l]:o[u]+=1)}return o}function pR(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],o=zt([r,t],e.dtype);for(let l=0;l<r;l++)for(let u=0;u<i;u++){const d=n.get(l,u);if(d<0)throw new Error("Input x must be non-negative!");d>=t||(s?o.set(1,l,d):e.size>0?o.set(o.get(l,d)+e.get(l,u),l,d):o.set(o.get(l,d)+1,l,d))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fR=Wn((n,e)=>n&e),hZ=es(Vf,fR),pZ={kernelName:Vf,backendName:"cpu",kernelFunc:hZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zi(n){return(e,t,s)=>{const r=Pn(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cn(n,e,t){const s=Zi(e);return mo(n,s,t)}function mo(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;mt(o,n);const l=i,u=l.data.get(o.dataId).values;let d;if(o.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");d=Ia(u)}else d=u;const h=t||o.dtype,f=e(d,h,r);return l.makeTensorInfo(o.shape,h,f)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mR=Zi(n=>Math.ceil(n)),fZ=mo(bd,mR),mZ={kernelName:bd,backendName:"cpu",kernelFunc:fZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gR(n,e,t,s){const r=Pn(t,Te(e));if(s&&t!=="string"){let i=0;n.forEach(o=>{const l=Te(o.shape);r.set(o.vals,i),i+=l})}else{let i=0;n.forEach(o=>{const l=t==="string"?Ia(o.vals):o.vals;let u=0;for(let d=0;d<o.shape[0];++d){const h=d*e[1]+i;for(let f=0;f<o.shape[1];++f)r[h+f]=l[u++]}i+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IR=Wn((n,e)=>n===e?1:0),yR=es(Gf,IR,null,"bool"),gZ={kernelName:Gf,backendName:"cpu",kernelFunc:yR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bR=Zi(n=>Math.exp(n)),xR=mo(vd,bR,"float32"),IZ={kernelName:vd,backendName:"cpu",kernelFunc:xR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NR=Zi(n=>Math.expm1(n)),yZ=mo($d,NR),bZ={kernelName:$d,backendName:"cpu",kernelFunc:yZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wR=Zi(n=>Math.floor(n)),xZ=mo(_d,wR),NZ={kernelName:_d,backendName:"cpu",kernelFunc:xZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AR=Wn((n,e)=>Math.floor(n/e)),wZ=es(Dd,AR,null,"int32"),AZ={kernelName:Dd,backendName:"cpu",kernelFunc:wZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TR(n,e,t,s,r,i,o,l,u){const d=zt([s,i],t);for(let h=0;h<s;h++){const f=[];let m=0;for(let I=0;I<r;I++){const y=n[h*r+I];m+=y*o[I],f.push(y)}if(m<0||m>=u/i)throw new Error(`Invalid indices: ${f} does not index into ${l}`);for(let I=0;I<i;I++)d.values[h*i+I]=e.get(...e.indexToLoc(m*i+I))}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SR(n,e,t){const s=zt(t,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),l=o[0],u=o[2],d=e.locToIndex([l,u]);o[2]=e.values[d];const h=n.locToIndex(o);0<=h&&h<n.values.length&&(s.values[r]=n.values[h])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vR=Wn((n,e)=>n>e?1:0),TZ=es(Yf,vR,null,"bool"),SZ={kernelName:Yf,backendName:"cpu",kernelFunc:TZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $R=Wn((n,e)=>n>=e?1:0),vZ=es(Ed,$R,null,"bool"),$Z={kernelName:Ed,backendName:"cpu",kernelFunc:vZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _R=Wn((n,e)=>n<e?1:0),_Z=es(Zf,_R,null,"bool"),DZ={kernelName:Zf,backendName:"cpu",kernelFunc:_Z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DR=Wn((n,e)=>n<=e?1:0),EZ=es(Qf,DR,null,"bool"),kZ={kernelName:Qf,backendName:"cpu",kernelFunc:EZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(n,e,t){const s=(e-n)/(t-1),r=$s(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR=Zi(n=>Math.log(n)),CZ=mo(Rd,kR),LZ={kernelName:Rd,backendName:"cpu",kernelFunc:CZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CR(n,e,t,s){const r=Is(s,Te(t));for(let i=0;i<r.length;++i){const o=i*e;let l=n[o];for(let u=0;u<e;++u){const d=n[o+u];(Number.isNaN(d)||d>l)&&(l=d)}r[i]=l}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LR=Wn((n,e)=>Math.max(n,e)),OZ=es(Pd,LR),RZ={kernelName:Pd,backendName:"cpu",kernelFunc:OZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OR=Wn((n,e)=>Math.min(n,e)),VZ=es(Fd,OR),PZ={kernelName:Fd,backendName:"cpu",kernelFunc:VZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gx=Wn((n,e)=>n*e),FZ=fx((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),mg=es(Md,gx,FZ),zZ={kernelName:Md,backendName:"cpu",kernelFunc:mg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(n,e,t){const s=io(-1,t);return gx([],e,s,n,t)}function MZ(n){const{inputs:e,backend:t}=n,{x:s}=e;mt(s,"neg");const r=t.data.get(s.dataId).values,[i,o]=RR(r,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,i)}const WZ={kernelName:um,backendName:"cpu",kernelFunc:MZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VR=Wn((n,e)=>n!==e?1:0),BZ=es(cm,VR,null,"bool"),HZ={kernelName:cm,backendName:"cpu",kernelFunc:BZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ix(n,e,t,s,r){const i=e.length,o=Te(e),l=wt(e),u=wt(r),d=Is(t,Te(r));for(let h=0;h<o;++h){const f=Cu(h,i,l),m=new Array(f.length);for(let y=0;y<m.length;y++)m[y]=f[s[y]];const I=Mi(m,i,u);d[I]=n[h]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tr(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;mt(r,"transpose");const o=r.shape.length,l=new Array(o);for(let f=0;f<l.length;f++)l[f]=r.shape[i[f]];const u=s.data.get(r.dataId).values,d=Ix(u,r.shape,r.dtype,i,l);return{dataId:s.write(d,l,r.dtype),shape:l,dtype:r.dtype}}const UZ={kernelName:au,backendName:"cpu",kernelFunc:tr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PR(n,e,t,s){const[r,i]=us(n,s),o=dr(e,"int32"),l=$s(Te(r),o),u=Te(i);for(let d=0;d<l.length;++d){const h=d*u;let f=1;for(let m=0;m<u;++m)f*=t[h+m];l[d]=f}return{outVals:l,outShape:r,outDtype:o}}function GZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;mt(r,"prod");const l=r.shape.length,u=Bt(i,r.shape),d=En(u,l);let h=u,f=r;const m=[];d!=null&&(f=tr({inputs:{x:r},backend:t,attrs:{perm:d}}),m.push(f),h=zn(h.length,l));const I=t.data.get(f.dataId).values,{outVals:y,outShape:N,outDtype:w}=PR(f.shape,f.dtype,I,h);let T=N;return o&&(T=Fn(N,u)),m.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(T,w,y)}const qZ={kernelName:gm,backendName:"cpu",kernelFunc:GZ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KZ(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=Cu(r,e.length,wt(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function jZ(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function YZ(n,e,t,s){const r=[];let i=0;const o=e.length-1+t.length,l=new Array(o).fill(null).map(()=>[0]);jZ(t,s);let u=1;for(let d=0;d<e.length-1;++d){u*=e[d];const h=e[d+1];for(let f=1;f<u+1;++f)l[d].push(f*h)}for(let d=0;d<n.length;++d){let h=n[d],f=n[d]+1;for(let m=0;m<t.length;++m){const I=t[m],y=m+e.length-1;if(y>=0){const N=l[y],w=N[N.length-1]-I[h];for(let T=h;T<f;++T)l[y].push(I[T+1]+w)}h=I[h],f=I[f]}f!==h&&(r.push([h,f]),i+=f-h)}return{outSplits:l,valueSlices:r,numValues:i}}function XZ(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=Pn("int32",s);e.push(r),n[t].forEach((i,o)=>r[o]=i)}return e}function P3(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function ZZ(n,e,t,s,r,i){const o=P3(e,2)[1],l=P3(i,2)[1];let u=0;for(const d of t)for(let h=d[0];h<d[1];++h){for(let f=0;f<s;++f)r[u*l+f]=n[h*o+f];++u}}function QZ(n,e,t,s,r){const i=e.slice();i[0]=r;const o=Pn(t,Te(i)),l=n.length,u=l===0?0:l/e[0];return ZZ(n,e,s,u,o,i),[o,i]}function FR(n,e,t,s,r,i,o,l){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(KZ(i,o,u),s.length===0)throw new Error("params.rank must be nonzero");const d=s[0],{outSplits:h,valueSlices:f,numValues:m}=YZ(i,o,n,d),I=XZ(h),y=QZ(t,s,r,f,m);return[I,y[0],y[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F3=2147483647;function zR(n,e,t,s,r,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const l=e.length===0,u=r.length===0,d=o.length===0,h=[];l||h.push(e[0]),u||h.push(r[0]),d||h.push(o[0]);for(let w=1;w<h.length;++w)if(h[w]!==h[w-1])throw new Error("starts, limits, and deltas must have the same shape");const f=h.length===0?1:h[0],m=Pn("int32",f+1);m[0]=0;for(let w=0;w<f;++w){const T=l?n[0]:n[w],v=u?s[0]:s[w],E=d?i[0]:i[w];if(E===0)throw new Error("Requires delta != 0");let _;if(E>0&&v<T||E<0&&v>T)_=0;else if(_=Math.ceil(Math.abs((v-T)/E)),_>F3)throw new Error(`Requires ((limit - start) / delta) <= ${F3}`);m[w+1]=m[w]+_}const I=m[f],y=Pn(t,I);let N=0;for(let w=0;w<f;++w){const T=m[w+1]-m[w];let v=l?n[0]:n[w];const E=d?i[0]:i[w];for(let _=0;_<T;++_)y[N++]=v,v+=E}return[m,y]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Vr=hi;class of{constructor(e,t,s,r,i,o,l,u,d,h){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=l,this.rowPartitionValues=u,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=NL(h),this.raggedRank=wL(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Vr.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Vr.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Vr.VALUE_ROWIDS:return of.getMaxWidthValueRowID(t);case Vr.ROW_SPLITS:return of.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Vr[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let o=1;o<t;++o){const l=e[o];l!==r&&(r=l,i=Math.max(o-s,i),s=o)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return M3(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;AL(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=xL(this.raggedRank,r,t);o[0]<0&&(o[0]=e);for(let l=1;l<=this.raggedRank;++l)o[l]<0&&(o[l]=this.getMaxWidth(l));return o}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let o=0;for(let l=0;l<r;++l,o+=t)i.push(o);for(let l=r;l<e;++l)i.push(-1);return W(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,o=[];for(let l=0;l<i-1;++l){const u=e[l+1]-e[l];let d=Math.min(r,u),h=t[l];h===-1&&(d=0);for(let f=0;f<d;++f)o.push(h),h+=s;for(let f=0;f<u-d;++f)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,o=[];if(i===0)return[];let l=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let d=t[u];o.push(d);for(let h=1;h<i;++h){const f=e[h];if(f===u)d>=0&&(++l,l<r?d+=s:d=-1);else{if(l=0,u=f,f>=t.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${t.length}`);d=t[f]}o.push(d)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Vr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case Vr.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${Vr[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Vr.FIRST_DIM_SIZE:return e[0];case Vr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Vr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Vr[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const i=M3(s,!1),o=Pn(this.valuesDType,Te(i));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let d=1;d<=this.raggedRank;++d)u=this.calculateOutputIndex(d-1,u,r[d],s[d]);this.setOutput(this.raggedRank,u,o,i)}return[i,o]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,o=s;let l=r.slice();l=l.slice(e+1);const u=Te(l),d=t.length;let h=this.defaultValue;if(h.length!==u&&h.length!==1){const y=this.defaultValueShape;pe(()=>{const N=ie(h,y);h=uu(N,l).dataSync()})}let f=0,m=0,I=0;for(let y=0;y<=d;++y){let N=y<d?t[y]:-1;if(N===I){++I;continue}if(m<I){const w=i.subarray(f*u),T=o.subarray(m*u),v=(I-m)*u;z3(T,w,v)}if(y>=d){const w=s.length;N=Math.floor(w/u)}if(N>I)if(this.defaultValue.length===1)o.subarray(I*u,N*u).fill(this.defaultValue[0]),I=N;else for(;N>I;){const w=o.slice(I*u);z3(w,h,u),++I}N<0?(f=y+1,m=I):(f=y,m=I,I=m+1)}}}function z3(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function M3(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function MR(n,e,t,s,r,i,o,l,u,d){return new of(n,e,t,s,r,i,o,l,u,d).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WR(n,e,t,s){const r=n===e,i=n<e&&t<0,o=e<n&&t>1;if(r||i||o)return $s(0,s);const l=Math.abs(Math.ceil((e-n)/t)),u=$s(l,s);e<n&&t===1&&(t=-1),u[0]=n;for(let d=1;d<u.length;d++)u[d]=u[d-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BR=Zi(n=>1/Math.sqrt(n)),JZ=mo(qd,BR),eQ={kernelName:qd,backendName:"cpu",kernelFunc:JZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qo(n,e,t,s,r,i,o,l,u,d){const h=[s/r,r],f=n.values,m=e.values;if(s===0)return zt(t,e.dtype);const I=u instanceof Yn?u:zt(h,e.dtype);typeof u=="string"||typeof u=="number"?I.values.fill(u):typeof u=="boolean"&&I.values.fill(+u);for(let y=0;y<i;y++){const N=[];let w=0;for(let T=0;T<o;T++){const v=f[y*o+T];N.push(v),w+=v*l[T]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${N} does not index into ${t}`);for(let T=0;T<r;T++)d?I.values[w*r+T]+=m[y*r+T]:I.values[w*r+T]=e.rank===0?m[0]:m[y*r+T]}return I}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tQ=Zi(n=>1/(1+Math.exp(-n))),HR=cn(Zd,n=>1/(1+Math.exp(-n))),nQ={kernelName:Zd,backendName:"cpu",kernelFunc:HR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(n,e,t,s,r){const i=Ab(s,e,t),o=Te(t),l=wt(s);if(i){const f=Tb(e,l);return r==="string"?n.slice(f,f+o):n.subarray(f,f+o)}const u=r==="string"?Ia(n):n,d=zt(s,r,u),h=zt(t,r);for(let f=0;f<h.size;++f){const m=h.indexToLoc(f),I=m.map((y,N)=>y+e[N]);h.set(d.get(...I),...m)}return r==="string"?HL(h.values):h.values}function pl(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s;mt(r,"slice");const[l,u]=eg(r,i,o);Nb(r,l,u);const d=t.data.get(r.dataId).values,h=UR(d,l,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,h)}const sQ={kernelName:wm,backendName:"cpu",kernelFunc:pl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GR(n,e,t,s,r,i,o){const l=e[0],u=i[0],d=new Array(u),h=new Array(l),f=e[1];if(u===0){if(l!==0)throw new Error(EL(l));const w=Pn(t,0),T=Pn(r,0);return[w,[0,f],T,d,h]}let m=!0,I=0;const y=new Array(u).fill(0);for(let w=0;w<l;++w){const T=n[w*f];if(T<0)throw new Error(kL(w,T));if(T>=u)throw new Error(CL(w,T,u));++y[T],m=m&&T>=I,I=T}let N=!0;for(let w=0;w<u;++w){const T=y[w]===0;d[w]=T,N=N&&!T,y[w]=Math.max(y[w],1),w>0&&(y[w]+=y[w-1])}if(N&&m){const w=n,T=s;for(let v=0;v<l;++v)h[v]=v;return[w,[l,f],T,d,h]}else{const w=y[u-1],T=Pn(t,w*f),v=Pn(r,w),E=new Array(u).fill(0);for(let _=0;_<l;++_){const L=n[_*f],P=E[L],B=(L===0?0:y[L-1])+P;E[L]++;for(let U=0;U<f;++U)T[B*f+U]=n[_*f+U];v[B]=s[_],h[_]=B}for(let _=0;_<u;++_)if(E[_]===0){const P=_===0?0:y[_-1];T[P*f+0]=_;for(let B=1;B<f;++B)T[P*f+B]=0;v[P]=o}return[T,[w,f],v,d,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qR(n,e,t,s,r){const i=Te(s),o=e[0],l=r.length,u=[];let d=1,h=-1;for(let w=0;w<l;++w){const T=r[w];if(T===-1){if(h!==-1)throw new Error(LL(h,w));h=w,u.push(1)}else{if(T<0)throw new Error(OL(w,T));d*=T,u.push(T)}}if(h!==-1){if(d<=0)throw new Error(RL());const w=Math.trunc(i/d);if(d*w!==i)throw new Error(VL(s,u));u[h]=w}if(Te(u)!==i)throw new Error(PL(s,u));const m=s.length,I=[];if(m>0){I[m-1]=1;for(let w=m-2;w>=0;--w)I[w]=I[w+1]*s[w+1]}const y=[];if(l>0){y[l-1]=1;for(let w=l-2;w>=0;--w)y[w]=y[w+1]*u[w+1]}const N=Pn(t,o*l);for(let w=0;w<o;++w){let T=0;for(let v=0;v<m;++v)T+=n[w*m+v]*I[v];for(let v=0;v<l;++v)N[w*l+v]=Math.trunc(T/y[v]),T%=y[v]}return[N,[o,l],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yx(n,e,t,s,r,i=!1,o=0){const l=s.length,u=[e[0],n.length/e[0]],d=u[1],f=l>0?r[l-1]+1:0;if(f<0)throw new Error(mI());const m=e.slice();m[0]=f;const I=m.reduce((E,_)=>E*_,1),y=Pn(t,I);if(l===0)return f>0&&y.fill(o),[y,m];if(f<=0)throw new Error(mI());let N=0,w=1,T=0,v=r[N];for(;;){let E=0;if(w<l){if(E=r[w],v===E){++w;continue}if(v>=E)throw new Error(FL())}if(v<0||v>=f)throw new Error(zL(v,f));v>T&&y.fill(o,T*d,v*d);for(let _=N;_<w;++_){const L=s[_];if(L<0||L>=u[0])throw new Error(ML(_,s[_],u[0]));for(let P=0;P<d;P++)y[v*d+P]+=n[L*d+P]}if(i)for(let _=0;_<d;_++)y[v*d+_]/=w-N;if(N=w,++w,T=v+1,v=E,w>l)break}return T<f&&y.fill(o,T*d,f*d),[y,m]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rQ=Zi(n=>Math.sqrt(n)),iQ=cn(Jd,n=>Math.sqrt(n)),aQ={kernelName:Jd,backendName:"cpu",kernelFunc:iQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KR=Wn((n,e)=>{const t=n-e;return t*t}),oQ=es(eh,KR),lQ={kernelName:eh,backendName:"cpu",kernelFunc:oQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jR=Zi((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),uQ=mo($m,jR),cQ={kernelName:$m,backendName:"cpu",kernelFunc:uQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(n,e,t,s){const r=zt(n,e.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),l=new Array(o.length);for(let u=0;u<l.length;u++)l[u]=o[u]*t[u]+s[u];r.set(e.get(...l),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dQ{constructor(e,t,s,r,i,o){this.separator=Ba(e),this.nGramWidths=t,this.leftPad=Ba(s),this.rightPad=Ba(r),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,o){for(let l=0;l<i;++l){const u=this.getPadWidth(o),d=Math.max(0,u-l),h=Math.max(0,u-(i-(l+1))),f=o-(d+h),m=t+(d>0?0:l-u);let I=0;I+=d*this.leftPad.length;for(let v=0;v<f;++v)I+=e[m+v].length;I+=h*this.rightPad.length;const y=d+h+f-1;I+=y*this.separator.length,s[r+l]=new Uint8Array(I);const N=s[r+l];let w=0;const T=v=>v.forEach(E=>N[w++]=E);for(let v=0;v<d;++v)T(this.leftPad),T(this.separator);for(let v=0;v<f-1;++v)T(e[m+v]),T(this.separator);if(f>0){T(e[m+f-1]);for(let v=0;v<h;++v)T(this.separator),T(this.rightPad)}else{for(let v=0;v<h-1;++v)T(this.rightPad),T(this.separator);T(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let d=1;d<r;++d){let h=t[d]>=u;if(h=h&&t[d]<=s,!h)throw new Error(`Invalid split value ${t[d]}, must be in [${u}, ${s}]`);u=t[d]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const i=r-1,o=Pn("int32",r);if(s===0||r===0){const u=new Array(s);for(let d=0;d<=i;++d)o[d]=0;return[u,o]}o[0]=0;for(let u=1;u<=i;++u){const d=t[u]-t[u-1];let h=0;this.nGramWidths.forEach(f=>{h+=this.getNumNGrams(d,f)}),this.preserveShort&&d>0&&h===0&&(h=1),o[u]=o[u-1]+h}const l=new Array(o[i]);for(let u=0;u<i;++u){const d=t[u];let h=o[u];if(this.nGramWidths.forEach(f=>{const m=t[u+1]-t[u],I=this.getNumNGrams(m,f);this.createNGrams(e,d,l,h,I,f),h+=I}),this.preserveShort&&h===o[u]){const f=t[u+1]-t[u];if(f===0)continue;const m=f+2*this.padWidth,I=1;this.createNGrams(e,d,l,h,I,m)}}return[l,o]}}function XR(n,e,t,s,r,i,o,l){return new dQ(t,s,r,i,o,l).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hQ(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const l=n.subarray(0,o);(!t||l.length!==0)&&s.push(l),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!t||o.length!==0)&&s.push(o),r=i+1}}function ZR(n,e,t){const s=n.length,r=[];let i=0,o=0;const l=new Array(s);for(let m=0;m<s;++m){const I=r.length;hQ(n[m],e,t,r);const y=r.length-I;l[m]=y,i+=y,o=Math.max(o,y)}const u=Pn("int32",i*2),d=new Array(i),h=[s,o];let f=0;for(let m=0;m<s;++m)for(let I=0;I<l[m];++I)u[f*2]=m,u[f*2+1]=I,d[f]=r[f],++f;return[u,d,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QR(n,e){const t=Pn("int32",n.length);for(let s=0;s<n.length;++s)t[s]=_M(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JR=Wn((n,e)=>n-e),pQ=fx((n,e,t,s)=>({real:n-t,imag:e-s})),bx=es(th,JR,pQ),fQ={kernelName:th,backendName:"cpu",kernelFunc:bx};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eV(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=zt(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let u=0;u<o.length;u++)o[u]=i[u]%n.shape[u];const l=n.locToIndex(o);s.values[r]=n.values[l]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wc=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function tV(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const l=s-t+1,u=e-t+1,d=Math.log(l),h=.5*Math.exp(2*d/3),f=.5*Math.sqrt(d*h*(l-h)/l)*Math.sign(u-l/2),m=Math.max(t,Math.floor(e-u*h/l+f)),I=Math.min(s,Math.floor(e+(l-u)*h/l+f));tV(n,e,m,I)}const r=n[e];let i=t,o=s;for(Gl(n,t,e),wc(n[s],r)>0&&Gl(n,t,s);i<o;){for(Gl(n,i,o),i++,o--;wc(n[i],r)<0;)i=i+1;for(;wc(n[o],r)>0;)o=o-1}wc(n[t],r)===0?Gl(n,t,o):(o=o+1,Gl(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function nV(n,e,t,s,r){const i=e[e.length-1],[o,l]=[n.length/i,i],u=Is(t,o*s),d=Is("int32",o*s);for(let f=0;f<o;f++){const m=f*l,I=n.subarray(m,m+l);let y=new Array(I.length);I.forEach((v,E)=>y[E]={value:v,index:E}),s<y.length&&(tV(y,s),y=y.slice(0,s)),r&&y.sort(wc);const N=f*s,w=u.subarray(N,N+s),T=d.subarray(N,N+s);for(let v=0;v<s;v++)w[v]=y[v].value,T[v]=y[v].index}const h=e.slice();return h[h.length-1]=s,[zt(h,t,u),zt(h,"int32",d)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sV(n,e,t,s){const r=Bt(e,t)[0],i=[1,t[0],1];for(let y=0;y<r;y++)i[0]*=t[y];i[1]=t[r];for(let y=r+1;y<t.length;y++)i[2]*=t[y];const o=new Map,l=new Int32Array(t[r]),u=new Yn(i,s,n),d=[],h=i[0]===1&&i[2]===1;for(let y=0;y<t[r];y++){let N;if(h)N=n[y].toString();else{const T=[];for(let v=0;v<i[0];v++)for(let E=0;E<i[2];E++)T.push(u.get(v,y,E));N=T.join(",")}const w=o.get(N);if(w!=null)l[y]=w;else{const T=o.size;o.set(N,T),l[y]=T,d.push(y)}}const f=i.slice();f[1]=o.size;const m=new Yn(f,s);d.forEach((y,N)=>{for(let w=0;w<i[0];w++)for(let T=0;T<i[2];T++)m.set(u.get(w,y,T),w,N,T)});const I=t.slice();return I[r]=f[1],{outputValues:m.values,outputShape:I,indices:l}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mQ=Object.freeze(Object.defineProperty({__proto__:null,addImpl:hR,bincountImpl:mx,bincountReduceImpl:pR,bitwiseAndImpl:fR,castImpl:dR,ceilImpl:mR,concatImpl:gR,equalImpl:IR,expImpl:bR,expm1Impl:NR,floorDivImpl:AR,floorImpl:wR,gatherNdImpl:TR,gatherV2Impl:SR,greaterEqualImpl:$R,greaterImpl:vR,lessEqualImpl:DR,lessImpl:_R,linSpaceImpl:ER,logImpl:kR,maxImpl:CR,maximumImpl:LR,minimumImpl:OR,multiplyImpl:gx,negImpl:RR,notEqualImpl:VR,prodImpl:PR,raggedGatherImpl:FR,raggedRangeImpl:zR,raggedTensorToTensorImpl:MR,rangeImpl:WR,rsqrtImpl:BR,scatterImpl:qo,sigmoidImpl:tQ,simpleAbsImpl:cR,sliceImpl:UR,sparseFillEmptyRowsImpl:GR,sparseReshapeImpl:qR,sparseSegmentReductionImpl:yx,sqrtImpl:rQ,squaredDifferenceImpl:KR,staticRegexReplaceImpl:jR,stridedSliceImpl:YR,stringNGramsImpl:XR,stringSplitImpl:ZR,stringToHashBucketFastImpl:QR,subImpl:JR,tileImpl:eV,topKImpl:nV,transposeImpl:Ix,uniqueImpl:sV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ek("cpu",()=>new fg,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rV=cn(Td,n=>n>=0?n:Math.exp(n)-1),gQ={kernelName:Td,backendName:"cpu",kernelFunc:rV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;mt([r],"leakyRelu");const o=Te(r.shape),l=t.data.get(r.dataId).values,u=Is("float32",o);for(let d=0;d<l.length;d++)u[d]=l[d]<0?i*l[d]:l[d];return t.makeTensorInfo(r.shape,"float32",u)}const IQ={kernelName:Xf,backendName:"cpu",kernelFunc:iV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yQ=Wn((n,e)=>n<0?e*n:n);function aV(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;mt([s,r],"prelu");const i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,[l,u]=yQ(s.shape,r.shape,i,o,"float32");return t.makeTensorInfo(u,"float32",l)}const bQ={kernelName:mm,backendName:"cpu",kernelFunc:aV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oV=cn(Hd,n=>Math.max(0,n)),xQ={kernelName:Hd,backendName:"cpu",kernelFunc:oV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lV=cn(Ud,n=>Math.min(Math.max(0,n),6)),NQ={kernelName:Ud,backendName:"cpu",kernelFunc:lV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lf(n,e,t,s,r){if(t==="linear")return Yi({inputs:{x:e},backend:n});if(t==="relu")return oV({inputs:{x:e},backend:n});if(t==="elu")return rV({inputs:{x:e},backend:n});if(t==="relu6")return lV({inputs:{x:e},backend:n});if(t==="prelu")return aV({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return iV({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return HR({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gn(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=Te(r.shape),l=sk(i,o),u=Te(l);W(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const d=t.data.get(r.dataId);if(d.complexTensorInfos!=null){const h=d.complexTensorInfos.real,f=d.complexTensorInfos.imag;h.shape=l,f.shape=l}return{dataId:r.dataId,shape:l,dtype:r.dtype}}const wQ={kernelName:Im,backendName:"cpu",kernelFunc:gn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uV(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:l}=s;mt([r,i],"matMul");const u=r.shape.length,d=i.shape.length,h=o?r.shape[u-2]:r.shape[u-1],f=l?i.shape[d-1]:i.shape[d-2],m=o?r.shape[u-1]:r.shape[u-2],I=l?i.shape[d-2]:i.shape[d-1],y=r.shape.slice(0,-2),N=i.shape.slice(0,-2),w=Te(y),T=Te(N),E=Lt(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,I]);W(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${l} must match.`);const _=o?[w,h,m]:[w,m,h],L=l?[T,I,f]:[T,f,I],P=gn({inputs:{x:r},backend:t,attrs:{shape:_}}),B=gn({inputs:{x:i},backend:t,attrs:{shape:L}}),U=o?P.shape[1]:P.shape[2],Z=o?P.shape[2]:P.shape[1],Y=l?B.shape[1]:B.shape[2],ae=Math.max(w,T),de=t.data.get(P.dataId).values,ce=t.data.get(B.dataId).values,Ie=wt(P.shape),be=wt(B.shape),[ye,we,fe]=o?[Ie[0],1,Ie[1]]:[Ie[0],Ie[1],1],[De,Pe,Fe]=l?[1,be[1],be[0]]:[be[1],1,be[0]],Ue=Z*Y,Ge=zt([ae,Z,Y],P.dtype),Ze=Ge.values,je=t.blockSize;for(let Qe=0;Qe<ae;Qe++){const he=Qe%w,_e=Qe%T;for(let ke=0;ke<Z;ke+=je){const ze=Math.min(ke+je,Z);for(let at=0;at<Y;at+=je){const xt=Math.min(at+je,Y);for(let j=0;j<U;j+=je){const Q=Math.min(j+je,U);for(let ue=ke;ue<ze;ue++)for(let Ee=at;Ee<xt;Ee++){let Se=0;for(let Oe=j;Oe<Q;Oe++){const Xe=de[he*ye+ue*we+Oe*fe],qe=ce[Oe*De+Ee*Pe+_e*Fe];Se+=Xe*qe}Ze[Qe*Ue+(ue*Y+Ee)]+=Se}}}}}return t.disposeIntermediateTensorInfo(P),t.disposeIntermediateTensorInfo(B),t.makeTensorInfo(E,Ge.dtype,Ge.values)}const AQ={kernelName:Of,backendName:"cpu",kernelFunc:uV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TQ(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:l}=e,{transposeA:u,transposeB:d,activation:h,leakyreluAlpha:f}=s;let m,I,y;const N=[];m=uV({inputs:{a:r,b:i},attrs:{transposeA:u,transposeB:d},backend:t}),o&&(I=wu({inputs:{a:m,b:o},backend:t}),N.push(m),m=I),h&&(y=lf(t,m,h,l,f),N.push(m),m=y);for(const T of N)t.disposeIntermediateTensorInfo(T);return m}const SQ={kernelName:zp,backendName:"cpu",kernelFunc:TQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vQ=cn(dd,n=>Math.acos(n)),$Q={kernelName:dd,backendName:"cpu",kernelFunc:vQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Q=cn(hd,n=>Math.acosh(n)),DQ={kernelName:hd,backendName:"cpu",kernelFunc:_Q};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EQ(n){const{inputs:e,backend:t}=n,s=e;mt(e,"addN");const r=s.map(l=>t.data.get(l.dataId).values),i=zt(s[0].shape,s[0].dtype),o=i.values;for(let l=0;l<s.length;l++){const u=r[l];for(let d=0;d<o.length;d++)o[d]+=u[d]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const kQ={kernelName:Df,backendName:"cpu",kernelFunc:EQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;mt(r,"all");const l=Bt(i,r.shape);let u=l;const d=En(u,r.shape.length);let h=r;d!=null&&(h=tr({inputs:{x:r},backend:t,attrs:{perm:d}}),u=zn(u.length,r.shape.length)),xs("all",u,h.shape.length);const[f,m]=us(h.shape,u),I=Te(m),y=$s(Te(f),h.dtype),N=t.data.get(h.dataId).values;for(let T=0;T<y.length;++T){const v=T*I;let E=N[v];for(let _=0;_<I;++_){const L=N[v+_];E=E&&L}y[T]=E}d!=null&&t.disposeIntermediateTensorInfo(h);const w=t.makeTensorInfo(f,h.dtype,y);if(o){const T=Fn(f,l),v=gn({inputs:{x:w},backend:t,attrs:{shape:T}});return t.disposeIntermediateTensorInfo(w),v}return w}const LQ={kernelName:xy,backendName:"cpu",kernelFunc:CQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;mt(r,"any");const l=Bt(i,r.shape);let u=l;const d=En(u,r.shape.length);let h=r;d!=null&&(h=tr({inputs:{x:r},backend:t,attrs:{perm:d}}),u=zn(u.length,r.shape.length)),xs("any",u,h.shape.length);const[f,m]=us(h.shape,u),I=Te(m),y=$s(Te(f),h.dtype),N=t.data.get(h.dataId).values;for(let T=0;T<y.length;++T){const v=T*I;let E=N[v];for(let _=0;_<I;++_){const L=N[v+_];E=E||L}y[T]=E}d!=null&&t.disposeIntermediateTensorInfo(h);const w=t.makeTensorInfo(f,h.dtype,y);if(o){const T=Fn(f,l),v=gn({inputs:{x:w},backend:t,attrs:{shape:T}});return t.disposeIntermediateTensorInfo(w),v}return w}const RQ={kernelName:Ny,backendName:"cpu",kernelFunc:OQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;mt(r,"argMax");let o=Bt(i,r.shape);const l=En(o,r.shape.length);let u=r;const d=[];l!=null&&(u=tr({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(u),o=zn(o.length,u.shape.length)),o=[o[0]],xs("argMax",o,u.shape.length);const[h,f]=us(u.shape,o),m=Te(h),I=$s(m,"int32"),y=Te(f),N=t.data.get(u.dataId).values;for(let w=0;w<I.length;++w){const T=w*y;let v=N[T],E=0;for(let _=0;_<y;++_){const L=N[T+_];L>v&&(v=L,E=_)}I[w]=E}return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(h,"int32",I)}const PQ={kernelName:Ef,backendName:"cpu",kernelFunc:VQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;mt(r,"argMin");let o=Bt(i,r.shape);const l=En(o,r.shape.length);let u=r;const d=[];l!=null&&(u=tr({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(u),o=zn(o.length,u.shape.length)),o=[o[0]],xs("argMin",o,u.shape.length);const[h,f]=us(u.shape,o),m=Te(h),I=$s(m,"int32"),y=Te(f),N=t.data.get(u.dataId).values;for(let w=0;w<I.length;++w){const T=w*y;let v=N[T],E=0;for(let _=0;_<y;++_){const L=N[T+_];L<v&&(v=L,E=_)}I[w]=E}return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(h,"int32",I)}const zQ={kernelName:kf,backendName:"cpu",kernelFunc:FQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MQ=cn(pd,n=>Math.asin(n)),WQ={kernelName:pd,backendName:"cpu",kernelFunc:MQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BQ=cn(fd,n=>Math.asinh(n)),HQ={kernelName:fd,backendName:"cpu",kernelFunc:BQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UQ=cn(md,n=>Math.atan(n)),GQ={kernelName:md,backendName:"cpu",kernelFunc:UQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qQ=Wn((n,e)=>Math.atan2(n,e)),KQ=es(Id,qQ),jQ={kernelName:Id,backendName:"cpu",kernelFunc:KQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YQ=cn(gd,n=>Math.atanh(n)),XQ={kernelName:gd,backendName:"cpu",kernelFunc:YQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xx(n,e,t,s,r,i){const o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.top,I=r.padInfo.left,y=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=zt(r.outShape,t),w=N.values,T=r.outShape[1]*r.outShape[2]*r.outShape[3],v=r.outShape[2]*r.outShape[3],E=r.outShape[3];for(let _=0;_<r.batchSize;++_){const L=_*T,P=_*s[0];for(let B=0;B<r.inChannels;++B)for(let U=0;U<r.outHeight;++U){const Z=U*o-m,Y=Math.max(0,Z),ae=Math.min(r.inHeight,h+Z),de=L+U*v;for(let ce=0;ce<r.outWidth;++ce){const Ie=ce*l-I,be=Math.max(0,Ie),ye=Math.min(r.inWidth,f+Ie);let we=y,fe=0,De=0;for(let Fe=Y;Fe<ae;Fe+=u){const Ue=P+Fe*s[1];for(let Ge=be;Ge<ye;Ge+=d){const Ze=Ue+Ge*s[2],je=n[Ze+B];i==="max"&&je>we?we=je:i==="avg"&&(fe+=je,De++)}if(isNaN(we))break}const Pe=de+ce*E+B;w[Pe]=i==="avg"?fe/De:we}}}return N}function cV(n,e,t,s,r=!1,i=!1){const o=zt(s.outShape,"int32"),l=s.strideHeight,u=s.strideWidth,d=s.dilationHeight,h=s.dilationWidth,f=s.effectiveFilterHeight,m=s.effectiveFilterWidth,I=s.padInfo.top,y=s.padInfo.left,N=zt(e,t,n);for(let w=0;w<s.batchSize;++w)for(let T=0;T<s.inChannels;++T)for(let v=0;v<s.outHeight;++v){const E=v*l-I;let _=E;for(;_<0;)_+=d;const L=Math.min(s.inHeight,f+E);for(let P=0;P<s.outWidth;++P){const B=P*u-y;let U=B;for(;U<0;)U+=h;const Z=Math.min(s.inWidth,m+B);let Y=Number.NEGATIVE_INFINITY,ae=-1;for(let de=_;de<L;de+=d){const ce=de-E;for(let Ie=U;Ie<Z;Ie+=h){const be=Ie-B,ye=N.get(w,de,Ie,T);ye>Y&&(Y=ye,r?ae=i?((w*s.inHeight+de)*s.inWidth+Ie)*s.inChannels+T:(de*s.inWidth+Ie)*s.inChannels+T:ae=ce*m+be)}}o.set(ae,w,v,P,T)}}return o}function dV(n,e,t,s,r,i){const o=r.strideDepth,l=r.strideHeight,u=r.strideWidth,d=r.dilationDepth,h=r.dilationHeight,f=r.dilationWidth,m=r.effectiveFilterDepth,I=r.effectiveFilterHeight,y=r.effectiveFilterWidth,N=r.padInfo.front,w=r.padInfo.top,T=r.padInfo.left,v=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,E=zt(r.outShape,t),_=E.values,L=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],P=r.outShape[2]*r.outShape[3]*r.outShape[4],B=r.outShape[3]*r.outShape[4],U=r.outShape[4];for(let Z=0;Z<r.batchSize;++Z){const Y=Z*L,ae=Z*s[0];for(let de=0;de<r.inChannels;++de)for(let ce=0;ce<r.outDepth;++ce){const Ie=ce*o-N;let be=Ie;for(;be<0;)be+=d;const ye=Math.min(r.inDepth,m+Ie),we=Y+ce*P;for(let fe=0;fe<r.outHeight;++fe){const De=fe*l-w;let Pe=De;for(;Pe<0;)Pe+=h;const Fe=Math.min(r.inHeight,I+De),Ue=we+fe*B;for(let Ge=0;Ge<r.outWidth;++Ge){const Ze=Ge*u-T;let je=Ze;for(;je<0;)je+=f;const Qe=Math.min(r.inWidth,y+Ze),he=Ue+Ge*U;let _e=v,ke=0,ze=0;for(let xt=be;xt<ye;xt+=d){const j=ae+xt*s[1];for(let Q=Pe;Q<Fe;Q+=h){const ue=j+Q*s[2];for(let Ee=je;Ee<Qe;Ee+=f){const Se=ue+Ee*s[3],Oe=n[Se+de];if(i==="max"&&Oe>_e?_e=Oe:i==="avg"&&(ke+=Oe,ze++),isNaN(_e))break}if(isNaN(_e))break}if(isNaN(_e))break}const at=he+de;_[at]=i==="avg"?ke/Math.max(ze,1):_e}}}}return E}function ZQ(n,e){const t=zt(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,I=e.padInfo.top,y=e.padInfo.left;for(let N=0;N<e.batchSize;++N)for(let w=0;w<e.inChannels;++w)for(let T=0;T<e.outDepth;++T){const v=T*s-m;let E=v;for(;E<0;)E+=o;const _=Math.min(e.inDepth,d+v);for(let L=0;L<e.outHeight;++L){const P=L*r-I;let B=P;for(;B<0;)B+=l;const U=Math.min(e.inHeight,h+P);for(let Z=0;Z<e.outWidth;++Z){const Y=Z*i-y;let ae=Y;for(;ae<0;)ae+=u;const de=Math.min(e.inWidth,f+Y);let ce=Number.NEGATIVE_INFINITY,Ie=-1;for(let be=E;be<_;be+=o){const ye=be-v;for(let we=B;we<U;we+=l){const fe=we-P;for(let De=ae;De<de;De+=u){const Pe=De-Y,Fe=n.get(N,be,we,De,w);Fe>=ce&&(ce=Fe,Ie=ye*h*f+fe*h+Pe)}}}t.set(Ie,N,T,L,Z,w)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;mt(r,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=s,d=1;W(bs(o,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const h=ei(r.shape,i,o,d,l,u);let f;if(h.filterWidth===1&&h.filterHeight===1&&Kt(h.inShape,h.outShape))f=Yi({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,I=wt(r.shape),y=xx(m,r.shape,r.dtype,I,h,"avg");f=t.makeTensorInfo(h.outShape,r.dtype,y.values)}return f}const JQ={kernelName:Cf,backendName:"cpu",kernelFunc:QQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:u,dataFormat:d}=s;mt(r,"avgPool3d");const h=ba(r.shape,i,o,1,l,u,d),f=t.data.get(r.dataId).values,m=dV(f,r.shape,r.dtype,wt(r.shape),h,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}const tJ={kernelName:Lf,backendName:"cpu",kernelFunc:eJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:l,pad:u,dimRoundingMode:d}=s;mt([r,i],"avgPool3DGrad");const h=ba(i.shape,o,l,1,u,d),f=h.strideDepth,m=h.strideHeight,I=h.strideWidth,y=h.filterDepth,N=h.filterHeight,w=h.filterWidth,T=h.dilationDepth,v=h.dilationHeight,E=h.dilationWidth,_=h.effectiveFilterDepth,L=h.effectiveFilterHeight,P=h.effectiveFilterWidth,B=_-1-h.padInfo.front,U=P-1-h.padInfo.left,Z=L-1-h.padInfo.top,Y=zt(i.shape,"float32"),ae=1/(y*N*w),de=t.bufferSync(r);for(let ce=0;ce<h.batchSize;++ce)for(let Ie=0;Ie<h.inChannels;++Ie)for(let be=0;be<h.inDepth;++be)for(let ye=0;ye<h.inHeight;++ye)for(let we=0;we<h.inWidth;++we){const fe=be-B,De=ye-Z,Pe=we-U;let Fe=0;for(let Ue=0;Ue<_;Ue+=T){const Ge=(fe+Ue)/f;if(!(Ge<0||Ge>=h.outDepth||Math.floor(Ge)!==Ge))for(let Ze=0;Ze<L;Ze+=v){const je=(De+Ze)/m;if(!(je<0||je>=h.outHeight||Math.floor(je)!==je))for(let Qe=0;Qe<P;Qe+=E){const he=(Pe+Qe)/I;if(he<0||he>=h.outWidth||Math.floor(he)!==he)continue;const _e=de.get(ce,Ge,je,he,Ie);Fe+=_e}}}Y.set(Fe*ae,ce,be,ye,we,Ie)}return t.makeTensorInfo(Y.shape,Y.dtype,Y.values)}const sJ={kernelName:Ay,backendName:"cpu",kernelFunc:nJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;mt([r,i],"avgPoolGrad");const{filterSize:l,strides:u,pad:d}=s,h=ei(o.shape,l,u,1,d),f=h.strideHeight,m=h.strideWidth,I=h.filterHeight,y=h.filterWidth,N=h.dilationHeight,w=h.dilationWidth,T=h.effectiveFilterHeight,v=h.effectiveFilterWidth,E=v-1-h.padInfo.left,_=T-1-h.padInfo.top,L=zt(o.shape,"float32"),P=1/(I*y),B=t.data.get(r.dataId).values,U=zt(r.shape,"float32",B);for(let Z=0;Z<h.batchSize;++Z)for(let Y=0;Y<h.inChannels;++Y)for(let ae=0;ae<h.inHeight;++ae)for(let de=0;de<h.inWidth;++de){const ce=ae-_,Ie=de-E;let be=0;for(let ye=0;ye<T;ye+=N){const we=(ce+ye)/f;if(!(we<0||we>=h.outHeight||Math.floor(we)!==we))for(let fe=0;fe<v;fe+=w){const De=(Ie+fe)/m;if(De<0||De>=h.outWidth||Math.floor(De)!==De)continue;const Pe=U.get(Z,we,De,Y);be+=Pe}}L.set(be*P,Z,ae,de,Y)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}const iJ={kernelName:wy,backendName:"cpu",kernelFunc:rJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:o,mean:l,variance:u}=e;W(l.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(o==null||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(i==null||l.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),mt([r,l,u,i,o],"batchNorm");let{varianceEpsilon:d}=s;d==null&&(d=.001);const h=t.data.get(r.dataId).values,f=t.data.get(l.dataId).values,m=t.data.get(u.dataId).values,I=i?t.data.get(i.dataId).values:new Float32Array([1]),y=o?t.data.get(o.dataId).values:new Float32Array([0]),N=new Float32Array(h.length),w=y.length,T=I.length,v=m.length,E=f.length;let _=0,L=0,P=0,B=0;for(let U=0;U<h.length;++U)N[U]=y[_++]+(h[U]-f[L++])*I[P++]/Math.sqrt(m[B++]+d),_>=w&&(_=0),L>=E&&(L=0),P>=T&&(P=0),B>=v&&(B=0);return t.makeTensorInfo(r.shape,r.dtype,N)}const oJ={kernelName:Kf,backendName:"cpu",kernelFunc:aJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;mt([r],"batchToSpaceND");const l=i.reduce((T,v)=>T*v),u=fh(r.shape,i,l),d=mh(u.length,i.length),h=gh(r.shape,i,l),f=Db(o,i.length),m=Eb(h,o,i.length),I=gn({inputs:{x:r},backend:t,attrs:{shape:u}}),y=tr({inputs:{x:I},backend:t,attrs:{perm:d}}),N=gn({inputs:{x:y},backend:t,attrs:{shape:h}}),w=pl({inputs:{x:N},backend:t,attrs:{begin:f,size:m}});return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(N),w}const uJ={kernelName:Rf,backendName:"cpu",kernelFunc:lJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,l=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,d=mx(l,u,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,d)}const dJ={kernelName:Ty,backendName:"cpu",kernelFunc:cJ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=Lt(Array.from(i),Array.from(o));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const pJ={kernelName:Sy,backendName:"cpu",kernelFunc:hJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fJ=cn(xd,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),mJ={kernelName:xd,backendName:"cpu",kernelFunc:fJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gJ=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(Te(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,l=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values;for(let d=0;d<l.length;d++){const h=l[d],f=u[d];s[d]=Math.hypot(h,f)}return t.makeOutput(s,e.shape,"float32")},IJ={kernelName:Pf,backendName:"cpu",kernelFunc:gJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Au(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const yJ={kernelName:Uy,backendName:"cpu",kernelFunc:Au};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tu(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=Bt(r,e[0].shape)[0],o=e.map(N=>N.shape);vb(o,i);let l=Bi(e.map(N=>N.shape),i);if(Te(l)===0)return t.makeTensorInfo(l,e[0].dtype,[]);const u=e.filter(N=>Te(N.shape)>0);if(u.length===1)return Yi({inputs:{x:u[0]},backend:t});if(u[0].dtype==="complex64"){const N=u.map(_=>hl({inputs:{input:_},backend:t})),w=u.map(_=>Au({inputs:{input:_},backend:t})),T=Tu({inputs:N,backend:t,attrs:{axis:i}}),v=Tu({inputs:w,backend:t,attrs:{axis:i}}),E=or({inputs:{real:T,imag:v},backend:t});return N.forEach(_=>t.disposeIntermediateTensorInfo(_)),w.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(v),E}const d=u.map(N=>{const T=[-1,Te(N.shape.slice(i))];return gn({inputs:{x:N},backend:t,attrs:{shape:T}})}),h=d.map(N=>({vals:t.data.get(N.dataId).values,shape:N.shape}));l=Bi(d.map(N=>N.shape),1);const f=d[0].shape[0]===1,m=gR(h,l,e[0].dtype,f),I=Bi(u.map(N=>N.shape),i),y=t.makeTensorInfo(I,e[0].dtype,m);return d.forEach(N=>t.disposeIntermediateTensorInfo(N)),y}const bJ={kernelName:Ff,backendName:"cpu",kernelFunc:Tu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}=s;mt([r,i],"conv2d");const f=xa(u),m=ls(r.shape,i.shape,o,d,l,h,!1,f),I=m.filterHeight,y=m.filterWidth,N=m.dilationHeight,w=m.dilationWidth,T=m.padInfo.left,v=m.padInfo.top,E=m.dataFormat==="channelsLast",_=new Yn(m.outShape,r.dtype),L=wt(r.shape),P=wt(i.shape),B=L[0],U=E?L[1]:L[2],Z=E?L[2]:1,Y=E?1:L[1],ae=_.strides[0],de=E?_.strides[1]:_.strides[2],ce=E?_.strides[2]:1,Ie=E?1:_.strides[1],be=t.data.get(r.dataId).values,ye=t.data.get(i.dataId).values,we=_.values;for(let fe=0;fe<m.batchSize;++fe){const De=fe*B,Pe=fe*ae;for(let Fe=0;Fe<m.outHeight;++Fe){const Ue=Pe+Fe*de,Ge=Fe*m.strideHeight-v;for(let Ze=0;Ze<I;++Ze){const je=Ge+Ze*N;if(je<0||je>=m.inHeight)continue;const Qe=Ze*P[0],he=De+je*U;for(let _e=0;_e<m.outWidth;++_e){const ke=Ue+_e*ce,ze=_e*m.strideWidth-T;for(let at=0;at<y;++at){const xt=ze+at*w;if(xt<0||xt>=m.inWidth)continue;const j=Qe+at*P[1],Q=he+xt*Z;let ue=j;for(let Ee=0;Ee<m.inChannels;++Ee){const Se=be[Q+Ee*Y];for(let Oe=0;Oe<m.outChannels;++Oe)we[ke+Oe*Ie]+=Se*ye[ue+Oe];ue+=m.outChannels}}}}}}return t.makeTensorInfo(_.shape,_.dtype,we)}const xJ={kernelName:zf,backendName:"cpu",kernelFunc:hV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:l,dataFormat:u,dimRoundingMode:d,filterShape:h}=s;mt([r,i],"conv2dBackpropFilter");const f=xa(u),m=ls(r.shape,h,o,1,l,d,!1,f),{strideHeight:I,strideWidth:y,filterHeight:N,filterWidth:w}=m,T=m.dataFormat==="channelsLast",v=new Yn(m.filterShape,"float32"),E=m.padInfo.left,_=m.padInfo.top,L=t.data.get(r.dataId).values,P=t.data.get(i.dataId).values,B=new Yn(r.shape,r.dtype,L),U=new Yn(i.shape,i.dtype,P);for(let Z=0;Z<N;++Z){const Y=Math.max(0,Math.ceil((_-Z)/I)),ae=Math.min(m.outHeight,(m.inHeight+_-Z)/I);for(let de=0;de<w;++de){const ce=Math.max(0,Math.ceil((E-de)/y)),Ie=Math.min(m.outWidth,(m.inWidth+E-de)/y);for(let be=0;be<m.inChannels;++be)for(let ye=0;ye<m.outChannels;++ye){let we=0;for(let fe=0;fe<m.batchSize;++fe)for(let De=Y;De<ae;++De){const Pe=Z+De*I-_;for(let Fe=ce;Fe<Ie;++Fe){const Ue=de+Fe*y-E;T?we+=B.get(fe,Pe,Ue,be)*U.get(fe,De,Fe,ye):we+=B.get(fe,be,Pe,Ue)*U.get(fe,ye,De,Fe)}}v.set(we,Z,de,be,ye)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const wJ={kernelName:$y,backendName:"cpu",kernelFunc:NJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:l,pad:u,dataFormat:d,dimRoundingMode:h}=s;mt([r,i],"conv2dBackpropInput");const f=wt(i.shape),m=wt(r.shape);let I=xa(d);const y=ls(o,i.shape,l,1,u,h,!1,I),N=new Yn(y.inShape,"float32"),w=N.values,T=t.data.get(r.dataId).values,v=t.data.get(i.dataId).values,[E,_,L]=f,{batchSize:P,filterHeight:B,filterWidth:U,inChannels:Z,inHeight:Y,inWidth:ae,outChannels:de,outHeight:ce,outWidth:Ie,strideHeight:be,strideWidth:ye}=y;I=y.dataFormat;const we=B-1-y.padInfo.top,fe=U-1-y.padInfo.left,De=I==="channelsLast",Pe=N.strides[0],Fe=De?N.strides[1]:N.strides[2],Ue=De?N.strides[2]:1,Ge=De?1:N.strides[1],Ze=m[0],je=De?m[1]:m[2],Qe=De?m[2]:1,he=De?1:m[1];for(let _e=0;_e<P;++_e)for(let ke=0;ke<Z;++ke)for(let ze=0;ze<Y;++ze){const at=ze-we,xt=Math.max(0,Math.ceil(at/be)),j=Math.min(ce,(B+at)/be);for(let Q=0;Q<ae;++Q){const ue=Q-fe,Ee=Math.max(0,Math.ceil(ue/ye)),Se=Math.min(Ie,(U+ue)/ye);let Oe=0;for(let qe=xt;qe<j;++qe){const Ye=qe*be-at;for(let We=Ee;We<Se;++We){const Nt=We*ye-ue,Je=Ze*_e+je*qe+Qe*We,ct=E*(B-1-Ye)+_*(U-1-Nt)+L*ke;for(let dt=0;dt<de;++dt){const Dt=T[Je+he*dt],qt=v[ct+dt];Oe+=Dt*qt}}}const Xe=Pe*_e+Fe*ze+Ue*Q+Ge*ke;w[Xe]=Oe}}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const TJ={kernelName:Mf,backendName:"cpu",kernelFunc:AJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:u}=s;mt([r,i],"conv3d");const d=lo(r.shape,i.shape,o,u,l),{filterDepth:h,filterHeight:f,filterWidth:m,dilationDepth:I,dilationHeight:y,dilationWidth:N,padInfo:w}=d,T=w.front,v=w.left,E=w.top,_=new Yn(d.outShape,r.dtype),L=t.data.get(r.dataId).values,P=t.data.get(i.dataId).values,B=_.values,U=wt(r.shape),Z=wt(i.shape);for(let Y=0;Y<d.batchSize;++Y){const ae=Y*U[0],de=Y*_.strides[0];for(let ce=0;ce<d.outDepth;++ce){const Ie=de+ce*_.strides[1],be=ce*d.strideDepth-T;for(let ye=0;ye<h;++ye){const we=be+ye*I;if(we<0||we>=d.inDepth)continue;const fe=ye*Z[0],De=ae+we*U[1];for(let Pe=0;Pe<d.outHeight;++Pe){const Fe=Ie+Pe*_.strides[2],Ue=Pe*d.strideHeight-E;for(let Ge=0;Ge<f;++Ge){const Ze=Ue+Ge*y;if(Ze<0||Ze>=d.inHeight)continue;const je=fe+Ge*Z[1],Qe=De+Ze*U[2];for(let he=0;he<d.outWidth;++he){const _e=Fe+he*d.outChannels,ke=he*d.strideWidth-v;for(let ze=0;ze<m;++ze){const at=ke+ze*N;if(at<0||at>=d.inWidth)continue;const xt=je+ze*Z[2],j=Qe+at*d.inChannels;let Q=xt;for(let ue=0;ue<d.inChannels;++ue){const Ee=L[j+ue];for(let Se=0;Se<d.outChannels;++Se)B[_e+Se]+=Ee*P[Q+Se];Q+=d.outChannels}}}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const vJ={kernelName:Wf,backendName:"cpu",kernelFunc:SJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $J(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:l,filterShape:u}=s;mt([r,i],"conv3dBackpropFilterV2");const d=wt(r.shape),h=wt(i.shape),f=lo(r.shape,u,o,1,l),m=f.strideDepth,I=f.strideHeight,y=f.strideWidth,N=f.filterDepth,w=f.filterHeight,T=f.filterWidth,v=new Yn(f.filterShape,"float32"),E=v.values,[_,L,P,B]=v.strides,U=t.data.get(i.dataId).values,[Z,Y,ae,de]=h,ce=t.data.get(r.dataId).values,[Ie,be,ye,we]=d,fe=f.padInfo.front,De=f.padInfo.left,Pe=f.padInfo.top;for(let Fe=0;Fe<N;++Fe){const Ue=Math.max(0,Math.ceil((fe-Fe)/m)),Ge=Math.min(f.outDepth,(f.inDepth+fe-Fe)/m),Ze=Fe*_;for(let je=0;je<w;++je){const Qe=Math.max(0,Math.ceil((Pe-je)/I)),he=Math.min(f.outHeight,(f.inHeight+Pe-je)/I),_e=je*L+Ze;for(let ke=0;ke<T;++ke){const ze=Math.max(0,Math.ceil((De-ke)/y)),at=Math.min(f.outWidth,(f.inWidth+De-ke)/y),xt=ke*P+_e;for(let j=0;j<f.inChannels;++j){const Q=j*B+xt;for(let ue=0;ue<f.outChannels;++ue){let Ee=0;for(let Se=0;Se<f.batchSize;++Se){const Oe=Se*Ie,Xe=Se*Z;for(let qe=Ue;qe<Ge;++qe){const We=(Fe+qe*m-fe)*be+Oe,Nt=qe*Y+Xe;for(let Je=Qe;Je<he;++Je){const dt=(je+Je*I-Pe)*ye+We,Dt=Je*ae+Nt;for(let qt=ze;qt<at;++qt){const Bn=(ke+qt*y-De)*we+dt,kn=qt*de+Dt;Ee+=ce[Bn+j]*U[kn+ue]}}}}E[Q+ue]=Ee}}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const _J={kernelName:_y,backendName:"cpu",kernelFunc:$J};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:l,inputShape:u}=s;mt([r],"conv3dBackpropInputV2");const d=wt(r.shape),h=wt(i.shape),f=lo(u,i.shape,l,1,o),m=new Yn(f.inShape,"float32"),I=m.values,[y,N,w,T]=m.strides,v=t.data.get(r.dataId).values,[E,_,L,P]=d,B=t.data.get(i.dataId).values,[U,Z,Y,ae]=h,{batchSize:de,filterDepth:ce,filterHeight:Ie,filterWidth:be,inChannels:ye,inDepth:we,inHeight:fe,inWidth:De,outChannels:Pe,outDepth:Fe,outHeight:Ue,outWidth:Ge,strideDepth:Ze,strideHeight:je,strideWidth:Qe}=f,he=ce-1-f.padInfo.front,_e=Ie-1-f.padInfo.top,ke=be-1-f.padInfo.left;for(let ze=0;ze<de;++ze)for(let at=0;at<ye;++at)for(let xt=0;xt<we;++xt){const j=xt-he,Q=Math.max(0,Math.ceil(j/Ze)),ue=Math.min(Fe,(ce+j)/Ze);for(let Ee=0;Ee<fe;++Ee){const Se=Ee-_e,Oe=Math.max(0,Math.ceil(Se/je)),Xe=Math.min(Ue,(Ie+Se)/je);for(let qe=0;qe<De;++qe){const Ye=qe-ke,We=Math.max(0,Math.ceil(Ye/Qe)),Nt=Math.min(Ge,(be+Ye)/Qe);let Je=0;for(let ct=Q;ct<ue;++ct){const dt=ct*Ze-j;for(let Dt=Oe;Dt<Xe;++Dt){const qt=Dt*je-Se;for(let Ut=We;Ut<Nt;++Ut){const Bn=Ut*Qe-Ye,kn=E*ze+_*ct+L*Dt+P*Ut,Us=U*(ce-1-dt)+Z*(Ie-1-qt)+Y*(be-1-Bn)+ae*at;for(let Hn=0;Hn<Pe;++Hn){const vi=v[kn+Hn],cs=B[Us+Hn];Je+=vi*cs}}}}I[y*ze+N*xt+w*Ee+T*qe+at]=Je}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const EJ={kernelName:Dy,backendName:"cpu",kernelFunc:DJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kJ=cn(Nd,n=>Math.cos(n)),CJ={kernelName:Nd,backendName:"cpu",kernelFunc:kJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LJ=cn(wd,n=>Math.cosh(n)),OJ={kernelName:wd,backendName:"cpu",kernelFunc:LJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RJ(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:l,method:u,extrapolationValue:d}=s,[h,f,m,I]=r.shape,y=i.shape[0],[N,w]=l,T=zt([y,N,w,I],"float32"),v=t.data.get(i.dataId).values,E=t.data.get(o.dataId).values,_=t.data.get(r.dataId).values,L=wt(r.shape),P=wt(T.shape);for(let B=0;B<y;B++){const U=B*4,Z=v[U],Y=v[U+1],ae=v[U+2],de=v[U+3],ce=E[B];if(ce>=h)continue;const Ie=N>1?(ae-Z)*(f-1)/(N-1):0,be=w>1?(de-Y)*(m-1)/(w-1):0;for(let ye=0;ye<N;ye++){const we=N>1?Z*(f-1)+ye*Ie:.5*(Z+ae)*(f-1);if(we<0||we>f-1){for(let fe=0;fe<w;fe++)for(let De=0;De<I;De++){const Pe=De+fe*P[2]+ye*P[1]+B*P[0];T.values[Pe]=d}continue}if(u==="bilinear"){const fe=Math.floor(we),De=Math.ceil(we),Pe=we-fe;for(let Fe=0;Fe<w;Fe++){const Ue=w>1?Y*(m-1)+Fe*be:.5*(Y+de)*(m-1);if(Ue<0||Ue>m-1){for(let Qe=0;Qe<I;Qe++){const he=Qe+Fe*P[2]+ye*P[1]+B*P[0];T.values[he]=d}continue}const Ge=Math.floor(Ue),Ze=Math.ceil(Ue),je=Ue-Ge;for(let Qe=0;Qe<I;Qe++){let he=Qe+Ge*L[2]+fe*L[1]+ce*L[0];const _e=_[he];he=Qe+Ze*L[2]+fe*L[1]+ce*L[0];const ke=_[he];he=Qe+Ge*L[2]+De*L[1]+ce*L[0];const ze=_[he];he=Qe+Ze*L[2]+De*L[1]+ce*L[0];const at=_[he],xt=_e+(ke-_e)*je,j=ze+(at-ze)*je;he=Qe+Fe*P[2]+ye*P[1]+B*P[0],T.values[he]=xt+(j-xt)*Pe}}}else for(let fe=0;fe<w;++fe){const De=w>1?Y*(m-1)+fe*be:.5*(Y+de)*(m-1);if(De<0||De>m-1){for(let Ue=0;Ue<I;Ue++){const Ge=Ue+fe*P[2]+ye*P[1]+B*P[0];T.values[Ge]=d}continue}const Pe=Math.round(De),Fe=Math.round(we);for(let Ue=0;Ue<I;Ue++){const Ge=Ue+Pe*L[2]+Fe*L[1]+ce*L[0],Ze=Ue+fe*P[2]+ye*P[1]+B*P[0];T.values[Ze]=_[Ge]}}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const VJ={kernelName:ky,backendName:"cpu",kernelFunc:RJ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:l}=s;mt(r,"cumprod");const u=En([i],r.shape.length);let d=r;u!=null&&(d=tr({inputs:{x:r},backend:t,attrs:{perm:u}}));const h=zn(1,r.shape.length)[0];if(h!==d.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${h}`);const f=dr(d.dtype,"int32"),m=yy(Te(d.shape),f),I=t.data.get(d.dataId).values,y=d.shape[d.shape.length-1],N=l?(T,v)=>T+y-v-1:(T,v)=>T+v;for(let T=0;T<I.length;T+=y)for(let v=0;v<y;v++){const E=N(T,v);if(v===0)m[E]=o?1:I[E];else{const _=N(T,v-1);m[E]=o?I[_]*m[_]:I[E]*m[_]}}const w=t.makeTensorInfo(d.shape,f,m);if(u!=null){const T=uo(u),v=tr({inputs:{x:w},backend:t,attrs:{perm:T}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(d),v}return w}const FJ={kernelName:Ey,backendName:"cpu",kernelFunc:PJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:l}=s;mt(r,"cumsum");const u=En([i],r.shape.length);let d=r;u!=null&&(d=tr({inputs:{x:r},backend:t,attrs:{perm:u}}));const h=zn(1,r.shape.length)[0];if(h!==d.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${h}`);const f=dr(d.dtype,"int32"),m=$s(Te(d.shape),f),I=t.data.get(d.dataId).values,y=d.shape[d.shape.length-1],N=l?(T,v)=>T+y-v-1:(T,v)=>T+v;for(let T=0;T<I.length;T+=y)for(let v=0;v<y;v++){const E=N(T,v);if(v===0)m[E]=o?0:I[E];else{const _=N(T,v-1);m[E]=o?I[_]+m[_]:I[E]+m[_]}}const w=t.makeTensorInfo(d.shape,f,m);if(u!=null){const T=uo(u),v=tr({inputs:{x:w},backend:t,attrs:{perm:T}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(d),v}return w}const MJ={kernelName:Bf,backendName:"cpu",kernelFunc:zJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:l}=s;if(r.shape.length===1){const u=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,h=mx(u,d,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,h)}else if(r.shape.length===2){const u=t.bufferSync(r),d=t.bufferSync(i),h=pR(u,d,o,l);return t.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const BJ={kernelName:Cy,backendName:"cpu",kernelFunc:WJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s;W(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const l=r.shape[0],u=r.shape[1],d=r.shape[2],h=r.shape[3],f=u*i,m=d*i,I=h/(i*i),y=t.data.get(r.dataId).values,N=new Float32Array(l*f*m*I);let w=0;for(let T=0;T<l;++T)for(let v=0;v<f;++v){const E=Math.floor(v/i),_=v%i;for(let L=0;L<m;++L){const P=Math.floor(L/i),B=L%i,U=(_*i+B)*I;for(let Z=0;Z<I;++Z){const ae=Z+U+h*(P+d*(E+u*T));N[w++]=y[ae]}}}return t.makeTensorInfo([l,f,m,I],r.dtype,N)}const UJ={kernelName:Ly,backendName:"cpu",kernelFunc:HJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:u,dimRoundingMode:d}=s;mt([r,i],"depthwiseConv2DNative");const h=wt(r.shape),f=wt(i.shape);let m=u;m==null&&(m=[1,1]),W(bs(o,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${m}'`);const I=ls(r.shape,i.shape,o,m,l,d,!0),{filterHeight:y,filterWidth:N,dilationHeight:w,dilationWidth:T,padInfo:v}=I,E=v.left,_=v.top,L=I.outChannels/I.inChannels,P=new Yn(I.outShape,r.dtype),B=t.data.get(r.dataId).values,U=t.data.get(i.dataId).values,Z=P.values;for(let Y=0;Y<I.batchSize;++Y){const ae=Y*h[0],de=Y*P.strides[0];for(let ce=0;ce<I.outHeight;++ce){const Ie=de+ce*P.strides[1],be=ce*I.strideHeight-_;for(let ye=0;ye<y;++ye){const we=be+ye*w;if(we<0||we>=I.inHeight)continue;const fe=ye*f[0],De=ae+we*h[1];for(let Pe=0;Pe<I.outWidth;++Pe){const Fe=Ie+Pe*P.strides[2],Ue=Pe*I.strideWidth-E;for(let Ge=0;Ge<N;++Ge){const Ze=Ue+Ge*T;if(Ze<0||Ze>=I.inWidth)continue;const je=fe+Ge*f[1],Qe=De+Ze*I.inChannels;let he=Fe,_e=je;for(let ke=0;ke<I.inChannels;++ke){const ze=B[Qe+ke];for(let at=0;at<L;++at)Z[he+at]+=ze*U[_e+at];he+=L,_e+=L}}}}}}return t.makeTensorInfo(P.shape,P.dtype,P.values)}const GJ={kernelName:Hf,backendName:"cpu",kernelFunc:pV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:l,pad:u,dimRoundingMode:d,filterShape:h}=s;mt([r,i],"depthwiseConv2dNativeBackpropFilter");const f=ls(r.shape,h,o,l,u,d,!0),{strideHeight:m,strideWidth:I,filterHeight:y,filterWidth:N}=f,w=new Yn(f.filterShape,"float32"),T=f.padInfo.left,v=f.padInfo.top,E=f.outChannels/f.inChannels,_=t.data.get(r.dataId).values,L=new Yn(r.shape,r.dtype,_),P=t.data.get(i.dataId).values,B=new Yn(i.shape,i.dtype,P);for(let U=0;U<y;++U){const Z=Math.max(0,Math.ceil((v-U)/m)),Y=Math.min(f.outHeight,(f.inHeight+v-U)/m);for(let ae=0;ae<N;++ae){const de=Math.max(0,Math.ceil((T-ae)/I)),ce=Math.min(f.outWidth,(f.inWidth+T-ae)/I);for(let Ie=0;Ie<f.outChannels;++Ie){const be=Math.trunc(Ie/E),ye=Ie%E;let we=0;for(let fe=0;fe<f.batchSize;++fe)for(let De=Z;De<Y;++De){const Pe=U+De*m-v;for(let Fe=de;Fe<ce;++Fe){const Ue=ae+Fe*I-T;we+=L.get(fe,Pe,Ue,be)*B.get(fe,De,Fe,Ie)}}w.set(we,U,ae,be,ye)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const KJ={kernelName:Oy,backendName:"cpu",kernelFunc:qJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:l,pad:u,dimRoundingMode:d,inputShape:h}=s;mt([r,i],"depthwiseConv2DNativeBackpropInput");const f=wt(r.shape),m=wt(i.shape),I=ls(h,i.shape,o,l,u,d,!0),y=new Yn(I.inShape,"float32"),N=y.values,[w,T,v]=y.strides,E=t.data.get(r.dataId).values,[_,L,P]=f,B=t.data.get(i.dataId).values,[U,Z,Y]=m,{batchSize:ae,filterHeight:de,filterWidth:ce,inChannels:Ie,inHeight:be,inWidth:ye,outChannels:we,outHeight:fe,outWidth:De,strideHeight:Pe,strideWidth:Fe}=I,Ue=de-1-I.padInfo.top,Ge=ce-1-I.padInfo.left,Ze=we/Ie;for(let je=0;je<ae;++je)for(let Qe=0;Qe<Ie;++Qe)for(let he=0;he<be;++he){const _e=he-Ue,ke=Math.max(0,Math.ceil(_e/Pe)),ze=Math.min(fe,(de+_e)/Pe);for(let at=0;at<ye;++at){const xt=at-Ge,j=Math.max(0,Math.ceil(xt/Fe)),Q=Math.min(De,(ce+xt)/Fe);let ue=0;for(let Ee=ke;Ee<ze;++Ee){const Se=Ee*Pe-_e;for(let Oe=j;Oe<Q;++Oe){const Xe=Oe*Fe-xt,qe=_*je+L*Ee+P*Oe,Ye=U*(de-1-Se)+Z*(ce-1-Xe)+Y*Qe;for(let We=0;We<Ze;++We){const Nt=Qe*Ze+We,Je=E[qe+Nt],ct=B[Ye+We];ue+=Je*ct}}}N[w*je+T*he+v*at+Qe]=ue}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const YJ={kernelName:Ry,backendName:"cpu",kernelFunc:jJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(n){const{inputs:e,backend:t}=n,{x:s}=e,r=Te(s.shape),i=t.data.get(s.dataId).values,o=zt([r,r],s.dtype),l=o.values;for(let d=0;d<i.length;d++)l[d*r+d]=i[d];const u=[...s.shape,...s.shape];return t.makeTensorInfo(u,o.dtype,o.values)}const ZJ={kernelName:Vy,backendName:"cpu",kernelFunc:XJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QJ={kernelName:Uf,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:l}=t,u=e,d=u.data.get(s.dataId).values,h=s.shape.length,f=u.data.get(r.dataId).values,m=r.shape.length,{batchSize:I,inHeight:y,inWidth:N,inChannels:w,outHeight:T,outWidth:v,padInfo:E,strideHeight:_,strideWidth:L,filterHeight:P,filterWidth:B,dilationHeight:U,dilationWidth:Z,outShape:Y}=oh(s.shape,r.shape,i,o,"NHWC",l),ae=Te(Y),de=Y.length,ce=Pn(s.dtype,ae);for(let be=0;be<I;++be)for(let ye=0;ye<T;++ye){const we=ye*_-E.top;for(let fe=0;fe<v;++fe){const De=fe*L-E.left;for(let Pe=0;Pe<w;++Pe){let Fe=Number.MIN_SAFE_INTEGER;for(let Ge=0;Ge<P;++Ge){const Ze=we+Ge*U;if(Ze>=0&&Ze<y)for(let je=0;je<B;++je){const Qe=De+je*Z;if(Qe>=0&&Qe<N){const he=Mi([be,Ze,Qe,Pe],h,wt(s.shape)),_e=Mi([Ge,je,Pe],m,wt(r.shape)),ke=d[he]+f[_e];ke>Fe&&(Fe=ke)}}}const Ue=Mi([be,ye,fe,Pe],de,wt(Y));ce[Ue]=Fe}}}return{dataId:u.write(xl(ce,s.dtype),Y,s.dtype),shape:Y,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JJ={kernelName:X1,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:l,dilations:u}=t,d=e,h=jr(s.shape,d.data.get(s.dataId).values),f=jr(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:I,inWidth:y,inChannels:N,outHeight:w,outWidth:T,padInfo:v,strideHeight:E,strideWidth:_,filterHeight:L,filterWidth:P,dilationHeight:B,dilationWidth:U,outShape:Z}=oh(s.shape,r.shape,o,l,"NHWC",u);W(i.rank===Z.length,()=>`Error in ${X1}, dy must have the same rank as output ${Z.length}, but got ${i.rank}`);const Y=jr(Z,d.data.get(i.dataId).values),ae=ak(r.shape,r.dtype);for(let ce=0;ce<m;++ce)for(let Ie=0;Ie<w;++Ie){const be=Ie*E-v.top;for(let ye=0;ye<T;++ye){const we=ye*_-v.left;for(let fe=0;fe<N;++fe){let De=Number.MIN_SAFE_INTEGER,Pe=0,Fe=0;for(let Ue=0;Ue<L;++Ue){const Ge=be+Ue*B;if(Ge>=0&&Ge<I)for(let Ze=0;Ze<P;++Ze){const je=we+Ze*U;if(je>=0&&je<y){const Qe=h[ce][Ge][je][fe]+f[Ue][Ze][fe];Qe>De&&(De=Qe,Pe=Ue,Fe=Ze)}}}ae[Pe][Fe][fe]+=Y[ce][Ie][ye][fe]}}}return{dataId:d.write(xl(ae,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eee={kernelName:Y1,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:l,dilations:u}=t,d=e,h=jr(s.shape,d.data.get(s.dataId).values),f=jr(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:I,inWidth:y,inChannels:N,outHeight:w,outWidth:T,padInfo:v,strideHeight:E,strideWidth:_,filterHeight:L,filterWidth:P,dilationHeight:B,dilationWidth:U,outShape:Z}=oh(s.shape,r.shape,o,l,"NHWC",u);W(i.rank===Z.length,()=>`Error in ${Y1}, dy must have the same rank as output ${Z.length}, but got ${i.rank}`);const Y=jr(Z,d.data.get(i.dataId).values),ae=ak(s.shape,s.dtype);for(let ce=0;ce<m;++ce)for(let Ie=0;Ie<w;++Ie){const be=Ie*E-v.top;for(let ye=0;ye<T;++ye){const we=ye*_-v.left;for(let fe=0;fe<N;++fe){let De=Number.MIN_SAFE_INTEGER,Pe=be<0?0:be,Fe=we<0?0:we;for(let Ue=0;Ue<L;++Ue){const Ge=be+Ue*B;if(Ge>=0&&Ge<I)for(let Ze=0;Ze<P;++Ze){const je=we+Ze*U;if(je>=0&&je<y){const Qe=h[ce][Ge][je][fe]+f[Ue][Ze][fe];Qe>De&&(De=Qe,Pe=Ge,Fe=je)}}}ae[ce][Pe][Fe][fe]+=Y[ce][Ie][ye][fe]}}}return{dataId:d.write(xl(ae,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tee(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:o}=s,{contextOptions:l,imageOptions:u}=o||{},d=(u==null?void 0:u.alpha)||1,h=(l==null?void 0:l.contextType)||"2d";if(h!=="2d")throw new Error(`Context type ${l.contextType} is not supported by the CPU backend.`);const f=i.getContext(h,(l==null?void 0:l.contextAttributes)||{});if(f==null)throw new Error(`Could not get the context with ${h} type.`);const[m,I]=r.shape.slice(0,2),y=r.shape.length===2?1:r.shape[2],N=t.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,T=new Uint8ClampedArray(I*m*4);for(let E=0;E<m*I;++E){const _=[0,0,0,255*d];for(let P=0;P<y;P++){const B=N[E*y+P];if(r.dtype==="float32"){if(B<0||B>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${B}.`)}else if(r.dtype==="int32"&&(B<0||B>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${B}.`);y===1?(_[0]=B*w,_[1]=B*w,_[2]=B*w):_[P]=B*w}const L=E*4;T[L+0]=Math.round(_[0]),T[L+1]=Math.round(_[1]),T[L+2]=Math.round(_[2]),T[L+3]=Math.round(_[3])}i.width=I,i.height=m;const v=new ImageData(T,I,m);return f.putImageData(v,0,0),r}const nee={kernelName:IM,backendName:"cpu",kernelFunc:tee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sh(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;mt(r,"sum");let l;r.dtype==="bool"?l=eo({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):l=Yi({inputs:{x:r},backend:t});const u=l.shape.length,d=Bt(i,l.shape),h=En(d,u);let f=d,m=l;h!=null&&(m=tr({inputs:{x:l},backend:t,attrs:{perm:h}}),f=zn(f.length,u)),xs("sum",f,m.shape.length);const[I,y]=us(m.shape,f),N=dr(m.dtype,"int32");let w=af(t,I,N);const T=Te(y),v=t.data.get(w.dataId).values,E=t.data.get(m.dataId).values;for(let _=0;_<v.length;++_){const L=_*T;let P=0;for(let B=0;B<T;++B)P+=E[L+B];v[_]=P}if(o){const _=Fn(w.shape,d),L=w;w=gn({inputs:{x:w},backend:t,attrs:{shape:_}}),t.disposeIntermediateTensorInfo(L)}return t.disposeIntermediateTensorInfo(l),h!=null&&t.disposeIntermediateTensorInfo(m),w}const see={kernelName:Am,backendName:"cpu",kernelFunc:Sh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ree(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:l,idDims:u}=Fb(r,i.length);Mb(o.length,u,i);const{path:d,steps:h}=Wb(l,u),f=h.length;let m=null,I=o.length;const y=[];for(let N=0;N<f;++N){for(const w of h[N]){const{permutationIndices:T,expandDims:v}=zb(I,u[w]);let E;Bb(T)?E=i[w]:(E=tr({inputs:{x:i[w]},backend:t,attrs:{perm:T}}),y.push(E));const _=E.shape.slice();for(let L=0;L<v.length;++L)_.splice(v[L],0,1);Kt(E.shape,_)||(E=gn({inputs:{x:E},backend:t,attrs:{shape:_}}),y.push(E)),m===null?m=E:(m=mg({inputs:{a:E,b:m},backend:t}),y.push(m))}N<f-1&&(d[N]>=0&&(m=Sh({inputs:{x:m},backend:t,attrs:{axis:d[N]-(o.length-I),keepDims:!1}}),y.push(m)),I--)}for(const N of y)N!==m&&t.disposeIntermediateTensorInfo(N);return m}const iee={kernelName:Py,backendName:"cpu",kernelFunc:ree};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aee(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;mt([s,r],"eluGrad");const i=new Float32Array(Te(r.shape)),o=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values;for(let u=0;u<o.length;++u){const d=o[u];d>=0?i[u]=l[u]:i[u]=l[u]*(d+1)}return t.makeTensorInfo(r.shape,"float32",i)}const oee={kernelName:Fy,backendName:"cpu",kernelFunc:aee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lee=kb,uee=Cb,cee=Lb,dee=Ob,hee=Rb,pee=Vb,fee=cn(Sd,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+lee*t);return e*(1-((((pee*s+hee)*s+dee)*s+cee)*s+uee)*s*Math.exp(-t*t))}),mee={kernelName:Sd,backendName:"cpu",kernelFunc:fee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uf(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,o=r.shape.length,l=r.shape.slice();let u=i;return i<0&&(W(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+i+1),l.splice(u,0,1),gn({inputs:{x:r},backend:t,attrs:{shape:l}})}const gee={kernelName:qf,backendName:"cpu",kernelFunc:uf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iee=Wn((n,e)=>n/e),Nx=es(Ad,Iee),PI={kernelName:Ad,backendName:"cpu",kernelFunc:Nx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fV(n,e,t){const s=n.shape,r=s[0],i=s[1],o=t.data.get(n.dataId),l=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,d=[r,i],h=Te(d),f=Is("float32",h),m=Is("float32",h);for(let w=0;w<r;w++){const T=pl({inputs:{x:l},backend:t,attrs:{begin:[w,0],size:[1,i]}}),v=pl({inputs:{x:u},backend:t,attrs:{begin:[w,0],size:[1,i]}}),E=or({inputs:{real:T,imag:v},backend:t}),{real:_,imag:L}=yee(E,e,t),P=ga(_,L);for(let B=0;B<i;B++){const U=Pb(P,B);f[w*i+B]=U.real,m[w*i+B]=U.imag}t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(E)}const I=t.makeTensorInfo(d,"float32",f),y=t.makeTensorInfo(d,"float32",m),N=or({inputs:{real:I,imag:y},backend:t});return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(y),N}function yee(n,e,t){const s=Te(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,o=t.data.get(r.complexTensorInfos.imag.dataId).values;if(bee(s)){const l=FI(i,o,s,e,t),u=[n.shape[0],n.shape[1]];if(e){const d=t.makeTensorInfo(u,"float32",l.real),h=t.makeTensorInfo(u,"float32",l.imag),f=t.makeTensorInfo([],"float32",io(s,"float32")),m=Yi({inputs:{x:f},backend:t}),I=PI.kernelFunc({inputs:{a:d,b:f},backend:t}),y=PI.kernelFunc({inputs:{a:h,b:m},backend:t}),N=t.data.get(I.dataId).values,w=t.data.get(y.dataId).values;return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(y),{real:N,imag:w}}return l}else{const l=ga(i,o),u=xee(l,s,e);return TL(u)}}function bee(n){return(n&n-1)===0}function FI(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=ga(n,e),o=t/2,l=SL(i),u=l.real,d=l.imag,h=[u.length],f=r.makeTensorInfo(h,"float32",u),m=r.makeTensorInfo(h,"float32",d),I=or({inputs:{real:f,imag:m},backend:r}),y=vL(i),N=y.real,w=y.imag,T=[N.length],v=r.makeTensorInfo(T,"float32",N),E=r.makeTensorInfo(T,"float32",w),_=or({inputs:{real:v,imag:E},backend:r}),L=FI(u,d,o,s,r),P=L.real,B=L.imag,U=[P.length],Z=r.makeTensorInfo(U,"float32",P),Y=r.makeTensorInfo(U,"float32",B),ae=or({inputs:{real:Z,imag:Y},backend:r}),de=FI(N,w,o,s,r),ce=de.real,Ie=de.imag,be=[ce.length],ye=r.makeTensorInfo(be,"float32",ce),we=r.makeTensorInfo(be,"float32",Ie),fe=or({inputs:{real:ye,imag:we},backend:r}),De=_L(t,s),Pe=[De.real.length],Fe=r.makeTensorInfo(Pe,"float32",De.real),Ue=r.makeTensorInfo(Pe,"float32",De.imag),Ge=or({inputs:{real:Fe,imag:Ue},backend:r}),Ze=mg({inputs:{a:Ge,b:fe},backend:r}),je=wu({inputs:{a:ae,b:Ze},backend:r}),Qe=bx({inputs:{a:ae,b:Ze},backend:r}),he=hl({inputs:{input:je},backend:r}),_e=hl({inputs:{input:Qe},backend:r}),ke=Au({inputs:{input:je},backend:r}),ze=Au({inputs:{input:Qe},backend:r}),at=Tu({inputs:[he,_e],backend:r,attrs:{axis:0}}),xt=Tu({inputs:[ke,ze],backend:r,attrs:{axis:0}}),j=r.data.get(at.dataId).values,Q=r.data.get(xt.dataId).values;return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(Y),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(ye),r.disposeIntermediateTensorInfo(we),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(Fe),r.disposeIntermediateTensorInfo(Ue),r.disposeIntermediateTensorInfo(Ge),r.disposeIntermediateTensorInfo(Ze),r.disposeIntermediateTensorInfo(je),r.disposeIntermediateTensorInfo(Qe),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(_e),r.disposeIntermediateTensorInfo(ze),r.disposeIntermediateTensorInfo(at),r.disposeIntermediateTensorInfo(xt),{real:j,imag:Q}}function xee(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,o=0;for(let l=0;l<e;l++){const u=DL(r*l,e,t),d=Pb(n,l);i+=d.real*u.real-d.imag*u.imag,o+=d.real*u.imag+d.imag*u.real}t&&(i/=e,o/=e),$L(s,i,o,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nee(n){const{inputs:e,backend:t}=n,{input:s}=e,r=Te(s.shape),i=s.shape[s.shape.length-1],o=r/i,l=gn({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),u=fV(l,!1,t),d=gn({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),d}const wee={kernelName:zy,backendName:"cpu",kernelFunc:Nee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,o=i||ku(r),l=Pn(o,Te(s));return Tee(l,r,o),e.makeTensorInfo(s,o,l)}const Aee={kernelName:My,backendName:"cpu",kernelFunc:wx};function Tee(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const See={kernelName:Wy,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=Is(s.dtype,Te(s.shape)),[o,l,u,d]=s.shape,h=r.data.get(s.dataId).values;for(let m=0;m<o;m++){const I=m*u*l*d;for(let y=0;y<l;y++){const N=y*(u*d);for(let w=0;w<u;w++){const T=w*d;for(let v=0;v<d;v++){const E=Math.round(u-w-1),_=I+N+T+v;let L=h[_];if(E>=0&&E<u){const P=E*d,B=I+N+P+v;L=h[B]}i[_]=L}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=e,{strides:u,pad:d,dataFormat:h,dilations:f,dimRoundingMode:m,activation:I,leakyreluAlpha:y}=s;let N=hV({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:d,dataFormat:h,dilations:f,dimRoundingMode:m}});if(o){const w=N;if(h==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const T=gn({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});N=wu({inputs:{a:N,b:T},backend:t}),t.disposeIntermediateTensorInfo(T)}else N=wu({inputs:{a:N,b:o},backend:t});t.disposeIntermediateTensorInfo(w)}if(I){const w=N;if(h==="NCHW"&&I==="prelu"&&l.shape.length===1&&l.shape[0]!==1){const T=gn({inputs:{x:l},backend:t,attrs:{shape:[l.shape[0],1,1]}});N=lf(t,N,I,T,y),t.disposeIntermediateTensorInfo(T)}else N=lf(t,N,I,l,y);t.disposeIntermediateTensorInfo(w)}return N}const $ee={kernelName:Mp,backendName:"cpu",kernelFunc:vee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=e,{strides:u,pad:d,dataFormat:h,dilations:f,dimRoundingMode:m,activation:I,leakyreluAlpha:y}=s;let N=pV({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:d,dataFormat:h,dilations:f,dimRoundingMode:m}});if(o){const w=N;N=wu({inputs:{a:N,b:o},backend:t}),t.disposeIntermediateTensorInfo(w)}if(I){const w=N;N=lf(t,N,I,l,y),t.disposeIntermediateTensorInfo(w)}return N}const Dee={kernelName:Wp,backendName:"cpu",kernelFunc:_ee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eee(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=Te(s.shape),o=r.shape,l=o[o.length-1],[u,d,h,f]=xb(s,r);if(d===0)return t.makeTensorInfo(u,s.dtype,[]);const m=t.data.get(r.dataId).values,I=t.bufferSync(s),y=TR(m,I,s.dtype,d,l,h,f,s.shape,i);return t.makeTensorInfo(u,s.dtype,y.values)}const kee={kernelName:By,backendName:"cpu",kernelFunc:Eee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:l}=s;mt([r,i],"gatherV2");const u=Bt(o,r.shape)[0],d=t.data.get(i.dataId).values,h=r.shape[u];for(let _=0;_<d.length;++_){const L=d[_];W(L<=h-1&&L>=0,()=>`GatherV2: the index value ${L} is not in [0, ${h-1}]`)}let f=l;l==null&&(f=0);const m=Te(i.shape),I=Ub(r,i,u,f),y=gn({inputs:{x:r},backend:t,attrs:{shape:[I.batchSize,I.outerSize,I.dimSize,I.sliceSize]}}),N=gn({inputs:{x:i},backend:t,attrs:{shape:[I.batchSize,m/I.batchSize]}}),w=[I.batchSize,I.outerSize,m/I.batchSize,I.sliceSize],T=t.bufferSync(N),v=t.bufferSync(y),E=SR(v,T,w);return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(N),t.makeTensorInfo(I.outputShape,E.dtype,E.values)}const Lee={kernelName:jf,backendName:"cpu",kernelFunc:Cee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oee(n){const{inputs:e,backend:t}=n,{input:s}=e,r=Te(s.shape),i=s.shape[s.shape.length-1],o=r/i,l=gn({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),u=fV(l,!0,t),d=gn({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),d}const Ree={kernelName:Hy,backendName:"cpu",kernelFunc:Oee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vee=cn(Cd,n=>Number.isFinite(n)?1:0,"bool"),Pee={kernelName:Cd,backendName:"cpu",kernelFunc:Vee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fee=cn(Ld,n=>Math.abs(n)===1/0?1:0,"bool"),zee={kernelName:Ld,backendName:"cpu",kernelFunc:Fee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mee=cn(Od,n=>Number.isNaN(n)?1:0,"bool"),Wee={kernelName:Od,backendName:"cpu",kernelFunc:Mee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bee(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=ER(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const Hee={kernelName:Gy,backendName:"cpu",kernelFunc:Bee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uee=cn(Vd,n=>Math.log1p(n)),Gee={kernelName:Vd,backendName:"cpu",kernelFunc:Uee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qee=Wn((n,e)=>n&&e),Kee=es(Jf,qee,null,"bool"),jee={kernelName:Jf,backendName:"cpu",kernelFunc:Kee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yee=cn(em,n=>n?0:1,"bool"),Xee={kernelName:em,backendName:"cpu",kernelFunc:Yee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zee=Wn((n,e)=>n||e),Qee=es(tm,Zee,null,"bool"),Jee={kernelName:tm,backendName:"cpu",kernelFunc:Qee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ete(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:l,beta:u}=s;mt(r,"LRN");const d=r.shape[3],h=d-1,f=t.data.get(r.dataId).values,m=Te(r.shape),I=new Float32Array(m);function y(N){const w=N%d;let T=N-w+Math.max(0,w-i);const v=N-w+Math.min(w+i,h);let E=0;for(;T<=v;T++){const _=f[T];E+=_*_}return E}for(let N=0;N<m;N++){const w=y(N),T=f[N]*Math.pow(o+l*w,-u);I[N]=T}return t.makeTensorInfo(r.shape,r.dtype,I)}const tte={kernelName:nm,backendName:"cpu",kernelFunc:ete};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:l,bias:u,alpha:d,beta:h}=s;mt(o,"LRNGrad");const f=Te(o.shape),m=o.shape[3],I=t.data.get(o.dataId).values,y=t.data.get(r.dataId).values,N=t.data.get(i.dataId).values,w=new Float32Array(f),T=f;for(let v=0;v<T;v++){const E=v%m,_=v-E+Math.max(0,E-l),L=v-E+Math.min(m,E+l+1);let P=0;for(let B=_;B<L;B++)P+=Math.pow(y[B],2);P=d*P+u;for(let B=_;B<L;B++){let U=-2*d*h*y[B]*N[v]/P;v===B&&(U+=Math.pow(P,-h)),U*=I[v],w[B]+=U}}return t.makeTensorInfo(o.shape,r.dtype,w)}const ste={kernelName:qy,backendName:"cpu",kernelFunc:nte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,l=t;let u=r.shape;const d=u.length,h=Bt(i,u);let f=h;const m=En(f,d);let I=l.data.get(r.dataId).values;if(m!=null){const _=new Array(d);for(let L=0;L<_.length;L++)_[L]=u[m[L]];I=Ix(I,u,r.dtype,m,_),f=zn(f.length,d),u=_}mt(r,"max"),xs("max",f,d);const[y,N]=us(u,f),w=Te(N),T=CR(I,w,y,r.dtype),v=l.write(T,y,r.dtype);let E=y;return o&&(E=Fn(y,h)),{dataId:v,shape:E,dtype:r.dtype}}const rte={kernelName:sm,backendName:"cpu",kernelFunc:mV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ite(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;mt(r,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=s,d=1;W(bs(o,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const h=ei(r.shape,i,o,d,l,u);let f;if(h.filterWidth===1&&h.filterHeight===1&&Kt(h.inShape,h.outShape))f=Yi({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,I=wt(r.shape),y=xx(m,r.shape,r.dtype,I,h,"max");f=t.makeTensorInfo(h.outShape,r.dtype,y.values)}return f}const ate={kernelName:rm,backendName:"cpu",kernelFunc:ite};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ote(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:u,dataFormat:d}=s;mt(r,"maxPool3d");const h=ba(r.shape,i,o,1,l,u,d),f=t.data.get(r.dataId).values,m=dV(f,r.shape,r.dtype,wt(r.shape),h,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}const lte={kernelName:im,backendName:"cpu",kernelFunc:ote};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ute(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:l,pad:u,dimRoundingMode:d}=s;mt([r,i],"maxPool3DGrad");const h=ba(i.shape,o,l,1,u,d),f=t.bufferSync(i),m=ZQ(f,h),I=h.strideDepth,y=h.strideHeight,N=h.strideWidth,w=h.dilationDepth,T=h.dilationHeight,v=h.dilationWidth,E=h.effectiveFilterDepth,_=h.effectiveFilterHeight,L=h.effectiveFilterWidth,P=E-1-h.padInfo.front,B=L-1-h.padInfo.left,U=_-1-h.padInfo.top,Z=zt(i.shape,"float32"),Y=t.bufferSync(r);for(let ae=0;ae<h.batchSize;++ae)for(let de=0;de<h.inChannels;++de)for(let ce=0;ce<h.inDepth;++ce)for(let Ie=0;Ie<h.inHeight;++Ie)for(let be=0;be<h.inWidth;++be){const ye=ce-P,we=Ie-U,fe=be-B;let De=0;for(let Pe=0;Pe<E;Pe+=w){const Fe=(ye+Pe)/I;if(!(Fe<0||Fe>=h.outDepth||Math.floor(Fe)!==Fe))for(let Ue=0;Ue<_;Ue+=T){const Ge=(we+Ue)/y;if(!(Ge<0||Ge>=h.outHeight||Math.floor(Ge)!==Ge))for(let Ze=0;Ze<L;Ze+=v){const je=(fe+Ze)/N;if(je<0||je>=h.outWidth||Math.floor(je)!==je)continue;const Qe=E*_*L-1-m.get(ae,Fe,Ge,je,de),he=Pe*_*L+Ue*L+Ze,_e=Qe===he?1:0;if(_e===0)continue;const ke=Y.get(ae,Fe,Ge,je,de);De+=ke*_e}}}Z.set(De,ae,ce,Ie,be,de)}return t.makeTensorInfo(Z.shape,Z.dtype,Z.values)}const cte={kernelName:jy,backendName:"cpu",kernelFunc:ute};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dte(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,l=i;mt([i,o],"maxPoolGrad");const{filterSize:u,strides:d,pad:h,dimRoundingMode:f}=s,m=ei(l.shape,u,d,1,h,f),I=t.data.get(l.dataId).values,y=zt(m.outShape,l.dtype,cV(I,l.shape,l.dtype,m).values),N=m.strideHeight,w=m.strideWidth,T=m.dilationHeight,v=m.dilationWidth,E=m.effectiveFilterHeight,_=m.effectiveFilterWidth,L=_-1-m.padInfo.left,P=E-1-m.padInfo.top,B=zt(l.shape,"float32"),U=t.data.get(r.dataId).values,Z=zt(r.shape,"float32",U);for(let Y=0;Y<m.batchSize;++Y)for(let ae=0;ae<m.inChannels;++ae)for(let de=0;de<m.inHeight;++de)for(let ce=0;ce<m.inWidth;++ce){const Ie=de-P,be=ce-L;let ye=0;for(let we=0;we<E;we+=T){const fe=(Ie+we)/N;if(!(fe<0||fe>=m.outHeight||Math.floor(fe)!==fe))for(let De=0;De<_;De+=v){const Pe=(be+De)/w;if(Pe<0||Pe>=m.outWidth||Math.floor(Pe)!==Pe)continue;const Fe=E*_-1-y.get(Y,fe,Pe,ae),Ue=we*_+De,Ge=Fe===Ue?1:0;if(Ge===0)continue;const Ze=Z.get(Y,fe,Pe,ae);ye+=Ze*Ge}}B.set(ye,Y,de,ce,ae)}return t.makeTensorInfo(B.shape,B.dtype,B.values)}const hte={kernelName:Ky,backendName:"cpu",kernelFunc:dte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pte(n,e,t,s,r){const i=wt(e),o=xx(n,e,t,i,r,"max"),l=cV(n,e,t,r,!0,s);return[o.values,l.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fte={kernelName:Yy,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:l}=e,u=t;mt(s,"MaxPoolWithArgmax");const d=u.data.get(s.dataId).values,h=ei(s.shape,r,i,[1,1],o),[f,m]=pte(d,s.shape,s.dtype,l,h),I=u.write(f,h.outShape,s.dtype),y=u.write(m,h.outShape,s.dtype);return[{dataId:I,shape:h.outShape,dtype:s.dtype},{dataId:y,shape:h.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=Bt(i,r.shape),d=us(r.shape,l)[1],h=Te(d),f=[],m=t.makeTensorInfo([],"float32",new Float32Array([h]));f.push(m);const I=eo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});f.push(I);const y=Nx({inputs:{a:I,b:m},backend:t});f.push(y);const N=Sh({inputs:{x:y},backend:t,attrs:{axis:i,keepDims:o}});return f.forEach(w=>t.disposeIntermediateTensorInfo(w)),N}const gte={kernelName:am,backendName:"cpu",kernelFunc:mte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ite(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;mt(r,"min");const l=Bt(i,r.shape);let u=l;const d=En(u,r.shape.length);let h=r;d!=null&&(h=tr({inputs:{x:r},backend:t,attrs:{perm:d}}),u=zn(u.length,r.shape.length)),xs("min",u,h.shape.length);const[f,m]=us(h.shape,u),I=Te(m),y=$s(Te(f),h.dtype),N=t.data.get(h.dataId).values;for(let T=0;T<y.length;++T){const v=T*I;let E=N[v];for(let _=0;_<I;++_){const L=N[v+_];(Number.isNaN(L)||L<E)&&(E=L)}y[T]=E}d!=null&&t.disposeIntermediateTensorInfo(h);const w=t.makeTensorInfo(f,h.dtype,y);if(o){const T=Fn(f,l),v=gn({inputs:{x:w},backend:t,attrs:{shape:T}});return t.disposeIntermediateTensorInfo(w),v}return w}const yte={kernelName:om,backendName:"cpu",kernelFunc:Ite};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:o}=s;mt(r,"mirrorPad");const l=i.map((E,_)=>E[0]+r.shape[_]+E[1]),u=i.map(E=>E[0]),d=i.map((E,_)=>E[0]+r.shape[_]),h=o==="reflect"?0:1,f=t.data.get(r.dataId).values,m=r.shape.length,I=wt(r.shape),y=Te(l),N=l.length,w=wt(l),T=Is(r.dtype,y);for(let E=0;E<y;E++){let _=Cu(E,N,w);for(let P=0;P<N;P++)_[P]<u[P]?_[P]=u[P]*2-_[P]-h:_[P]>=d[P]&&(_[P]=(d[P]-1)*2-_[P]+h);_=_.map((P,B)=>P-u[B]);const L=Mi(_,m,I);T[E]=f[L]}return{dataId:t.write(T,l,r.dtype),shape:l,dtype:r.dtype}}const xte={kernelName:lm,backendName:"cpu",kernelFunc:bte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nte=Wn((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),wte=es(zd,Nte),Ate={kernelName:zd,backendName:"cpu",kernelFunc:wte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gV(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=r.shape.length;let l=i;if(l===-1&&(l=o-1),l!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${l}`);const u=Bt([l],r.shape),d=mV({inputs:{x:r},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),h=Fn(d.shape,u),f=gn({inputs:{x:d},backend:t,attrs:{shape:h}}),m=bx({inputs:{a:r,b:f},backend:t}),I=xR({inputs:{x:m},backend:t}),y=Sh({inputs:{x:I},backend:t,attrs:{axis:u,keepDims:!1}}),N=gn({inputs:{x:y},backend:t,attrs:{shape:h}}),w=Nx({inputs:{a:I,b:N},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(N),w}const Tte={kernelName:vm,backendName:"cpu",kernelFunc:gV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ste(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:l}=s;mt(r,"multinomial");const u=l?r:gV({inputs:{logits:r},backend:t,attrs:{dim:-1}}),d=u.shape[0],h=u.shape[1],f=t.data.get(u.dataId).values,m=[d,i],I=$s(Te(m),"int32");for(let y=0;y<d;++y){const N=y*h,w=new Float32Array(h-1);w[0]=f[N];for(let E=1;E<w.length;++E)w[E]=w[E-1]+f[N+E];const T=Um.alea(o.toString()),v=y*i;for(let E=0;E<i;++E){const _=T();I[v+E]=w.length;for(let L=0;L<w.length;L++)if(_<w[L]){I[v+E]=L;break}}}return l||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(m,"int32",I)}const vte={kernelName:Xy,backendName:"cpu",kernelFunc:Ste};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $te=pb;function _te(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=s;mt(r,"NonMaxSuppression");const d=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:f}=$te(d,h,o,l,u);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const Dte={kernelName:Zy,backendName:"cpu",kernelFunc:_te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ete=fb;function kte(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u,padToMaxOutputSize:d}=s;mt(r,"NonMaxSuppressionPadded");const h=t.data.get(r.dataId).values,f=t.data.get(i.dataId).values,{selectedIndices:m,validOutputs:I}=Ete(h,f,o,l,u,d);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([I]))]}const Cte={kernelName:Qy,backendName:"cpu",kernelFunc:kte};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lte=mb;function Ote(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:d}=s;mt(r,"NonMaxSuppressionWithScore");const h=t.data.get(r.dataId).values,f=t.data.get(i.dataId).values,m=o,I=l,y=u,N=d,{selectedIndices:w,selectedScores:T}=Lte(h,f,m,I,y,N);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([T.length],"float32",new Float32Array(T))]}const Rte={kernelName:Jy,backendName:"cpu",kernelFunc:Ote};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vte(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:l,offValue:u}=s;mt(r,"oneHot");const d=Te(r.shape),h=new Float32Array(d*o);h.fill(u);const f=t.data.get(r.dataId).values;for(let m=0;m<d;++m)f[m]>=0&&f[m]<o&&(h[m*o+f[m]]=l);return t.makeTensorInfo([...r.shape,o],i,h)}const Pte={kernelName:hm,backendName:"cpu",kernelFunc:Vte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cf(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=hl({inputs:{input:s},backend:t}),i=cf({inputs:{x:r},backend:t}),o=Au({inputs:{input:s},backend:t}),l=cf({inputs:{x:o},backend:t}),u=or({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}else return wx({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Fte={kernelName:Em,backendName:"cpu",kernelFunc:cf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IV(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=hl({inputs:{input:s},backend:t}),i=IV({inputs:{x:r},backend:t}),o=Au({inputs:{input:s},backend:t}),l=cf({inputs:{x:o},backend:t}),u=or({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}else return wx({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const zte={kernelName:dm,backendName:"cpu",kernelFunc:IV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yV(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return uf({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(h=>{yr(i,h.shape,"All tensors passed to stack must have matching shapes"),W(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],u=e.map(h=>{const f=uf({inputs:{input:h},backend:t,attrs:{dim:r}});return l.push(f),f}),d=Tu({inputs:u,backend:t,attrs:{axis:r}});return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}const Mte={kernelName:pm,backendName:"cpu",kernelFunc:yV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wte(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;mt(r,"pad");const l=i.map((v,E)=>v[0]+r.shape[E]+v[1]),u=i.map(v=>v[0]),d=t.data.get(r.dataId).values,h=Te(r.shape),f=r.shape.length,m=wt(r.shape),I=Te(l),y=l.length,N=wt(l),w=Is(r.dtype,I);o!==0&&w.fill(o);for(let v=0;v<h;v++){const _=Cu(v,f,m).map((P,B)=>P+u[B]),L=Mi(_,y,N);w[L]=d[v]}return{dataId:t.write(w,l,r.dtype),shape:l,dtype:r.dtype}}const bV={kernelName:fm,backendName:"cpu",kernelFunc:Wte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bte=Wn((n,e)=>Math.pow(n,e)),Hte=es(Wd,Bte),Ute={kernelName:Wd,backendName:"cpu",kernelFunc:Hte};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gte(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,l=r.map(w=>t.data.get(w.dataId).values),u=r.map(w=>w.shape),d=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,[f,m,I]=FR(l,u,d,i.shape,i.dtype,h,o.shape),y=f.map(w=>t.makeTensorInfo([w.length],"int32",w)),N=t.makeTensorInfo(I,i.dtype,m);return y.concat([N])}const qte={kernelName:e2,backendName:"cpu",kernelFunc:Gte};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kte(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[d,h]=zR(o,s.shape,s.dtype,l,r.shape,u,i.shape),f=t.makeTensorInfo([d.length],"int32",d),m=t.makeTensorInfo([h.length],s.dtype,h);return[f,m]}const jte={kernelName:t2,backendName:"cpu",kernelFunc:Kte};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yte(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:l}=e,{rowPartitionTypes:u}=s,d=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,f=t.data.get(o.dataId).values,m=l.map(w=>t.data.get(w.dataId).values),I=l.map(w=>w.shape),[y,N]=MR(d,r.shape,h,i.shape,i.dtype,f,o.shape,m,I,u);return t.makeTensorInfo(y,i.dtype,N)}const Xte={kernelName:n2,backendName:"cpu",kernelFunc:Yte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zte(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:o}=t,l=WR(s,r,o,i);return e.makeTensorInfo([l.length],i,l)}const Qte={kernelName:s2,backendName:"cpu",kernelFunc:Zte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jte=cn(Bd,n=>1/n),ene={kernelName:Bd,backendName:"cpu",kernelFunc:Jte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tne(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:l}=s;mt(r,"resizeBilinear");const u=wt(r.shape),[d,h]=l,[f,m,I,y]=r.shape,N=t.data.get(r.dataId).values,w=new Float32Array(Te([f,d,h,y])),T=[i&&d>1?m-1:m,i&&h>1?I-1:I],v=[i&&d>1?d-1:d,i&&h>1?h-1:h];let E=0;const _=T[0]/v[0],L=T[1]/v[1];for(let P=0;P<f;P++)for(let B=0;B<d;B++){let U;o?U=_*(B+.5)-.5:U=_*B;const Z=Math.max(0,Math.floor(U)),Y=U-Z,ae=Math.min(m-1,Math.ceil(U)),de=P*u[0]+Z*u[1],ce=P*u[0]+ae*u[1];for(let Ie=0;Ie<h;Ie++){let be;o?be=L*(Ie+.5)-.5:be=L*Ie;const ye=Math.max(0,Math.floor(be)),we=be-ye,fe=Math.min(I-1,Math.ceil(be)),De=de+ye*u[2],Pe=ce+ye*u[2],Fe=de+fe*u[2],Ue=ce+fe*u[2];for(let Ge=0;Ge<y;Ge++){const Ze=N[De+Ge],je=N[Pe+Ge],Qe=N[Fe+Ge],he=N[Ue+Ge],_e=Ze+(Qe-Ze)*we,ke=je+(he-je)*we,ze=_e+(ke-_e)*Y;w[E++]=ze}}}return t.makeTensorInfo([f,d,h,y],"float32",w)}const nne={kernelName:bm,backendName:"cpu",kernelFunc:tne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sne(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;mt([i,r],"resizeBilinearGrad");const l=wt(r.shape),[u,d,h,f]=r.shape,[,m,I]=i.shape,y=new Float32Array(u*d*h*f),N=[o&&m>1?d-1:d,o&&I>1?h-1:h],w=[o&&m>1?m-1:m,o&&I>1?I-1:I],T=N[0]/w[0],v=N[1]/w[1],E=t.data.get(i.dataId).values;let _=0;for(let L=0;L<u;L++){const P=L*l[0];for(let B=0;B<m;B++){const U=B*T,Z=Math.floor(U),Y=Math.min(Math.ceil(U),d-1),ae=P+Z*l[1],de=P+Y*l[1],ce=U-Z,Ie=1-ce;for(let be=0;be<I;be++){const ye=be*v,we=Math.floor(ye),fe=Math.min(Math.ceil(ye),h-1),De=ye-we,Pe=1-De,Fe=ae+we*l[2],Ue=ae+fe*l[2],Ge=de+we*l[2],Ze=de+fe*l[2],je=Ie*Pe,Qe=Ie*De,he=ce*Pe,_e=ce*De;for(let ke=0;ke<f;ke++){const ze=E[_++];y[Fe+ke]+=ze*je,y[Ue+ke]+=ze*Qe,y[Ge+ke]+=ze*he,y[Ze+ke]+=ze*_e}}}}return t.makeTensorInfo([u,h,d,f],"float32",y)}const rne={kernelName:a2,backendName:"cpu",kernelFunc:sne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ine(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:l}=s;mt(r,"resizeNearestNeighbor");const u=wt(r.shape),[d,h]=l,[f,m,I,y]=r.shape,N=t.data.get(r.dataId).values,w=new Float32Array(f*d*h*y),T=[i&&d>1?m-1:m,i&&h>1?I-1:I],v=[i&&d>1?d-1:d,i&&h>1?h-1:h],E=T[0]/v[0],_=T[1]/v[1];let L=0;for(let P=0;P<f;P++){const B=P*u[0];for(let U=0;U<d;U++){const Z=o?E*(U+.5):E*U;let Y=Math.min(m-1,i?Math.round(Z):Math.floor(Z));o&&(Y=Math.max(0,Y));const ae=B+Y*u[1];for(let de=0;de<h;de++){const ce=o?_*(de+.5):_*de;let Ie=Math.min(I-1,i?Math.round(ce):Math.floor(ce));o&&(Ie=Math.max(0,Ie));const be=ae+Ie*u[2];for(let ye=0;ye<y;ye++){const we=N[be+ye];w[L++]=we}}}}return t.makeTensorInfo([f,d,h,y],r.dtype,w)}const ane={kernelName:ym,backendName:"cpu",kernelFunc:ine};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function one(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;mt([i,r],"resizeNearestNeighborGrad");const l=wt(r.shape),u=wt(i.shape),[d,h,f,m]=r.shape,[,I,y]=i.shape,N=new Float32Array(d*h*f*m),w=t.data.get(i.dataId).values,T=[o&&I>1?h-1:h,o&&y>1?f-1:f],v=[o&&I>1?I-1:I,o&&y>1?y-1:y],E=T[0]/v[0],_=T[1]/v[1],L=1/E,P=1/_,B=Math.ceil(L)*2+2,U=Math.ceil(P)*2+2;for(let Z=0;Z<d;Z++){const Y=Z*l[0];for(let ae=0;ae<h;ae++){const de=Y+ae*l[1],ce=Math.floor(ae*L),Ie=Math.floor(ce-B/2);for(let be=0;be<f;be++){const ye=de+be*l[2],we=Math.floor(be*P),fe=Math.floor(we-U/2);for(let De=0;De<m;De++){let Pe=0;for(let Fe=0;Fe<B;Fe++){const Ue=Fe+Ie;if(Ue<0||Ue>=I)continue;const Ge=Y+Ue*u[1],Ze=Ue*E,je=Math.min(h-1,o?Math.round(Ze):Math.floor(Ze));if(ae===je)for(let Qe=0;Qe<U;Qe++){const he=Qe+fe;if(he<0||he>=y)continue;const _e=Ge+he*u[2],ke=he*_,ze=Math.min(f-1,o?Math.round(ke):Math.floor(ke));be===ze&&(Pe+=w[_e+De])}}N[ye+De]=Pe}}}}return t.makeTensorInfo(r.shape,r.dtype,N)}const lne={kernelName:i2,backendName:"cpu",kernelFunc:one};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function une(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;mt(r,"reverse");const o=r.shape.length,l=Bt(i,r.shape);if(o===0)return Yi({inputs:{x:r},backend:t});const u=new Yn(r.shape,r.dtype),d=t.bufferSync(r);for(let h=0;h<u.size;h++){const f=u.indexToLoc(h),m=f.slice();l.forEach(I=>m[I]=r.shape[I]-1-m[I]),u.set(d.get(...m),...f)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}const cne={kernelName:xm,backendName:"cpu",kernelFunc:une};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dne={kernelName:A2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,l=t,u=Is(s.dtype,Te(s.shape)),[d,h,f,m]=s.shape,[I,y]=_b(o,h,f),N=255,w=Math.sin(r),T=Math.cos(r),v=l.data.get(s.dataId).values;for(let _=0;_<d;_++){const L=_*f*h*m;for(let P=0;P<h;P++){const B=P*(f*m);for(let U=0;U<f;U++){const Z=U*m;for(let Y=0;Y<m;Y++){const ae=[d,P,U,Y],de=ae[2],ce=ae[1];let Ie=(de-I)*T-(ce-y)*w,be=(de-I)*w+(ce-y)*T;Ie=Math.round(Ie+I),be=Math.round(be+y);let ye=i;if(typeof i!="number"&&(Y===3?ye=N:ye=i[Y]),Ie>=0&&Ie<f&&be>=0&&be<h){const fe=be*(f*m),De=Ie*m,Pe=L+fe+De+Y;ye=v[Pe]}const we=L+B+Z+Y;u[we]=ye}}}}return{dataId:l.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hne=cn(Gd,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),pne={kernelName:Gd,backendName:"cpu",kernelFunc:hne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fne(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:l,numUpdates:u,sliceSize:d,strides:h,outputSize:f}=Sl(i,r,o),m=!0,I=t.bufferSync(r),y=t.bufferSync(i),N=qo(I,y,o,f,d,u,l,h,0,m);return t.makeTensorInfo(o,N.dtype,N.values)}const mne={kernelName:o2,backendName:"cpu",kernelFunc:fne};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gne(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function Ine(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function yne(n,e,t,s,r,i){const o=Pn("int32",t*r);for(let l=0;l<t;++l){const u=n.slice(l*s,(l+1)*s),d=l*r;for(let h=0;h<r;++h)o[d+h]=i==="left"?gne(u,e[h+d]):Ine(u,e[h+d])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bne(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,l=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,d=yne(l,u,r.shape[0],r.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",d)}const xne={kernelName:u2,backendName:"cpu",kernelFunc:bne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nne(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;mt([s,r,i],"select");const o=s.shape.length,l=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,h=dr(r.dtype,i.dtype),f=$s(Te(r.shape),h);let m=0;const I=o===0||o>1||r.shape.length===1?1:Te(r.shape.slice(1));for(let y=0;y<l.length;y++)for(let N=0;N<I;N++)l[y]===1?f[m++]=u[y]:f[m++]=d[y];return t.makeTensorInfo(r.shape,h,f)}const wne={kernelName:Nm,backendName:"cpu",kernelFunc:Nne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ane=ng,Tne=sg,Sne=cn(Kd,n=>n>=0?Tne*n:Ane*(Math.exp(n)-1)),vne={kernelName:Kd,backendName:"cpu",kernelFunc:Sne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ne=cn(Xd,n=>n<0?-1:n>0?1:0),_ne={kernelName:Xd,backendName:"cpu",kernelFunc:$ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dne=cn(jd,n=>Math.sin(n)),Ene={kernelName:jd,backendName:"cpu",kernelFunc:Dne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kne=cn(Yd,n=>Math.sinh(n)),Cne={kernelName:Yd,backendName:"cpu",kernelFunc:kne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lne=11920928955078125e-23,W3=Math.log(Lne)+2,One=cn(Qd,n=>{const e=n>-W3,t=n<W3,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),Rne={kernelName:Qd,backendName:"cpu",kernelFunc:One};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;mt([r],"spaceToBatchND");const l=Te(i),u=[[0,0]];u.push(...o);for(let P=1+i.length;P<r.shape.length;++P)u.push([0,0]);const d=bV.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),h=fh(d.shape,i,l,!1),f=mh(h.length,i.length,!1),m=gh(d.shape,i,l,!1),N=gn({inputs:{x:d},backend:t,attrs:{shape:h}}),v=tr({inputs:{x:N},backend:t,attrs:{perm:f}}),L=gn({inputs:{x:v},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(v),L}const Pne={kernelName:Tm,backendName:"cpu",kernelFunc:Vne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fne(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values[0],[f,m,I,y,N]=GR(l,s.shape,s.dtype,u,r.dtype,d,h);return[t.makeTensorInfo(m,s.dtype,f),t.makeTensorInfo([m[0]],r.dtype,I),t.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(w=>Number(w)))),t.makeTensorInfo([N.length],s.dtype,new Int32Array(N))]}const zne={kernelName:c2,backendName:"cpu",kernelFunc:Fne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mne(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(r.dataId).values),l=t.data.get(s.dataId).values,u=Array.from(t.data.get(i.dataId).values),[d,h,f]=qR(l,s.shape,s.dtype,o,u);return[t.makeTensorInfo(h,s.dtype,d),t.makeTensorInfo([f.length],i.dtype,new Int32Array(f))]}const Wne={kernelName:d2,backendName:"cpu",kernelFunc:Mne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bne(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[d,h]=yx(o,s.shape,s.dtype,l,u,!0);return t.makeTensorInfo(h,s.dtype,d)}const Hne={kernelName:h2,backendName:"cpu",kernelFunc:Bne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Une(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[d,h]=yx(o,s.shape,s.dtype,l,u);return t.makeTensorInfo(h,s.dtype,d)}const Gne={kernelName:p2,backendName:"cpu",kernelFunc:Une};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qne(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:l}=s,{sliceRank:u,numUpdates:d,sliceSize:h,strides:f,outputSize:m}=Sl(i,r,l),I=!1,y=t.bufferSync(r);let N;switch(i.dtype){case"bool":{const w=t.bufferSync(i),T=!!t.data.get(o.dataId).values[0];N=qo(y,w,l,m,h,d,u,f,T,I);break}case"float32":{const w=t.bufferSync(i),T=t.data.get(o.dataId).values[0];N=qo(y,w,l,m,h,d,u,f,T,I);break}case"int32":{const w=t.bufferSync(i),T=t.data.get(o.dataId).values[0];N=qo(y,w,l,m,h,d,u,f,T,I);break}case"string":{const w=t.bufferSync(i),T=Ga(t.data.get(o.dataId).values[0]);N=qo(y,w,l,m,h,d,u,f,T,I);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(l,N.dtype,N.values)}const Kne={kernelName:f2,backendName:"cpu",kernelFunc:qne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,l=Bt(o,r.shape)[0],u=Hb(r,i,l),d=new Array(r.shape.length).fill(0),h=r.shape.slice();return u.map(f=>{const m=[...h];m[l]=f;const I=pl({inputs:{x:r},backend:t,attrs:{begin:d,size:m}});return d[l]+=f,I})}const Yne={kernelName:Sm,backendName:"cpu",kernelFunc:jne};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xne={kernelName:m2,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;mt(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let l=0;l<r.length;++l){const u=r[l];i[l]=u*u}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zne=cn(ih,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),Qne={kernelName:ih,backendName:"cpu",kernelFunc:Zne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jne(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:l,beginMask:u,endMask:d,ellipsisMask:h,newAxisMask:f,shrinkAxisMask:m}=s;mt(r,"stridedSlice");const{finalShapeSparse:I,finalShape:y,isIdentity:N,sliceDim0:w,isSimpleSlice:T,begin:v,end:E,strides:_}=Sb(r.shape,i,o,l,u,d,h,f,m);let L;if(N)L=gn({inputs:{x:r},backend:t,attrs:{shape:y}});else if(w||T){W(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const P=wb(v,E,_),B=pl({inputs:{x:r},backend:t,attrs:{begin:v,size:P}});L=gn({inputs:{x:B},backend:t,attrs:{shape:y}}),t.disposeIntermediateTensorInfo(B)}else{const P=t.bufferSync(r),B=YR(I,P,_,v);L=t.makeTensorInfo(y,B.dtype,B.values)}return L}const ese={kernelName:g2,backendName:"cpu",kernelFunc:Jne};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tse(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:l,padWidth:u,preserveShortSequences:d}=s,{data:h,dataSplits:f}=e,m=t.data.get(h.dataId).values,I=t.data.get(f.dataId).values,[y,N]=XR(m,I,r,i,o,l,u,d);return[t.makeTensorInfo([y.length],"string",y),t.makeTensorInfo(f.shape,"int32",N)]}const nse={kernelName:I2,backendName:"cpu",kernelFunc:tse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sse(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values[0],[d,h,f]=ZR(l,u,r),m=h.length;return[t.makeTensorInfo([m,2],"int32",d),t.makeTensorInfo([m],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const rse={kernelName:y2,backendName:"cpu",kernelFunc:sse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ise(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,l=QR(o,r);return t.makeTensorInfo(i.shape,"int32",l)}const ase={kernelName:b2,backendName:"cpu",kernelFunc:ise};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ose=cn(nh,n=>Math.tan(n)),lse={kernelName:nh,backendName:"cpu",kernelFunc:ose};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use=cn(sh,n=>Math.tanh(n)),cse={kernelName:sh,backendName:"cpu",kernelFunc:use};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dse(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:o,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=Sl(i,r,s.shape),f=!1,m=t.bufferSync(r),I=t.bufferSync(i),y=t.bufferSync(s),N=qo(m,I,s.shape,h,u,l,o,d,y,f);return t.makeTensorInfo(s.shape,N.dtype,N.values)}const hse={kernelName:l2,backendName:"cpu",kernelFunc:dse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;mt(r,"tile");const o=eV(t.bufferSync(r),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const fse={kernelName:rh,backendName:"cpu",kernelFunc:pse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s;mt(r,"topk");const l=t.data.get(r.dataId).values,[u,d]=nV(l,r.shape,r.dtype,i,o);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(d.shape,d.dtype,d.values)]}const gse={kernelName:x2,backendName:"cpu",kernelFunc:mse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ise(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:l,fillValue:u,outputShape:d}=t,[h,f,m,I]=r.shape,[y,N]=d??[f,m],w=[h,y,N,I],T=wt(r.shape),v=T[0],E=T[1],_=T[2],L=wt(w),P=L[0],B=L[1],U=L[2],Z=Is(r.dtype,Te(w));Z.fill(u);const Y=s.data.get(r.dataId).values,ae=s.data.get(i.dataId).values;for(let ce=0;ce<h;++ce){const Ie=i.shape[0]===1?ae:ae.subarray(ce*8,ce*8+8);for(let be=0;be<y;++be)for(let ye=0;ye<N;++ye)for(let we=0;we<I;++we){let fe;const De=Ie[6]*ye+Ie[7]*be+1;if(De===0)continue;const Pe=(Ie[0]*ye+Ie[1]*be+Ie[2])/De,Fe=(Ie[3]*ye+Ie[4]*be+Ie[5])/De,Ue=B3(Pe,m,l),Ge=B3(Fe,f,l);switch(o){case"nearest":fe=Ase(Y,f,m,v,E,_,ce,Ge,Ue,we,u);break;case"bilinear":fe=Tse(Y,f,m,v,E,_,ce,Ge,Ue,we,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const Ze=ce*P+be*B+ye*U+we;Z[Ze]=fe}return s.makeTensorInfo(w,r.dtype,Z)}return{dataId:s.write(Z,w,r.dtype),shape:r.shape,dtype:r.dtype}}const yse={kernelName:N2,backendName:"cpu",kernelFunc:Ise};function B3(n,e,t){switch(t){case"reflect":return bse(n,e);case"wrap":return xse(n,e);case"nearest":return wse(n,e);case"constant":default:return Nse(n)}}function bse(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return el(0,t,e-1)}function xse(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return el(0,t,e-1)}function Nse(n,e){return n}function wse(n,e){return el(0,n,e-1)}function Ac(n,e,t,s,r,i,o,l,u,d,h){const f=o*s+l*r+u*i+d;return 0<=l&&l<e&&0<=u&&u<t?n[f]:h}function Ase(n,e,t,s,r,i,o,l,u,d,h){const f=Math.round(l),m=Math.round(u);return Ac(n,e,t,s,r,i,o,f,m,d,h)}function Tse(n,e,t,s,r,i,o,l,u,d,h){const f=Math.floor(l),m=Math.floor(u),I=f+1,y=m+1,N=(y-u)*Ac(n,e,t,s,r,i,o,f,m,d,h)+(u-m)*Ac(n,e,t,s,r,i,o,f,y,d,h),w=(y-u)*Ac(n,e,t,s,r,i,o,I,m,d,h)+(u-m)*Ac(n,e,t,s,r,i,o,I,y,d,h);return(I-l)*N+(l-f)*w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sse(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;mt(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:l,outputShape:u,indices:d}=sV(o,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,l),s.makeTensorInfo([d.length],"int32",d)]}const vse={kernelName:w2,backendName:"cpu",kernelFunc:Sse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $se(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,l=r.shape[i],u=new Array(o-1);let d=0;for(let I=0;I<o;I++)I!==i&&(u[d++]=r.shape[I]);const h=new Array(o).fill(0),f=r.shape.slice();f[i]=1;const m=new Array(l);for(let I=0;I<m.length;I++){h[i]=I;const y=pl({inputs:{x:r},backend:t,attrs:{begin:h,size:f}});m[I]=gn({inputs:{x:y},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(y)}return m}const _se={kernelName:_m,backendName:"cpu",kernelFunc:$se};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dse(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s;mt(r,"unsortedSegmentSum");const l=r.shape.length,u=i.shape.length,d=[],h=[],f=l-u;let m=i;for(let y=0;y<f;++y){const N=uf({inputs:{input:m},backend:t,attrs:{dim:y+1}});m=N,h.push(N)}for(let y=0;y<o;++y){const N=io(y,"int32"),w=t.makeTensorInfo([],"int32",N),T=yR({inputs:{a:w,b:m},backend:t}),v=eo({inputs:{x:T},backend:t,attrs:{dtype:"float32"}}),E=mg({inputs:{a:v,b:r},backend:t}),_=Sh({inputs:{x:E},backend:t,attrs:{axis:0,keepDims:!1}});d.push(_),h.push(w),h.push(T),h.push(v),h.push(E),h.push(_)}const I=yV({inputs:d,backend:t,attrs:{axis:0}});return h.forEach(y=>t.disposeIntermediateTensorInfo(y)),I}const Ese={kernelName:Dm,backendName:"cpu",kernelFunc:Dse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kse=[SQ,iZ,$Q,DQ,dZ,kQ,LQ,RQ,PQ,zQ,WQ,HQ,GQ,jQ,XQ,JQ,tJ,sJ,iJ,AQ,oJ,uJ,dJ,pZ,pJ,uZ,mZ,mJ,aZ,IJ,bJ,xJ,wJ,TJ,vJ,_J,EJ,CJ,OJ,VJ,FJ,MJ,BJ,UJ,GJ,KJ,YJ,ZJ,QJ,JJ,eee,nee,iee,gQ,oee,gZ,mee,IZ,gee,bZ,wee,Aee,See,NZ,AZ,$ee,Dee,kee,Lee,SZ,$Z,oZ,Ree,yJ,Pee,zee,Wee,IQ,DZ,kZ,Hee,LZ,Gee,jee,Xee,Jee,tte,ste,rte,RZ,ate,lte,cte,hte,fte,gte,yte,PZ,xte,Ate,vte,zZ,WZ,Dte,Cte,Rte,HZ,Pte,zte,Mte,bV,Ute,bQ,qZ,qte,jte,Xte,Qte,lZ,PI,ene,xQ,NQ,wQ,nne,rne,ane,lne,cne,dne,pne,eQ,mne,xne,wne,vne,nQ,_ne,Ene,Cne,sQ,Tte,Rne,Pne,zne,Wne,Hne,Gne,Kne,Yne,aQ,Xne,lQ,cQ,Qne,ese,nse,rse,ase,fQ,see,lse,cse,hse,fse,gse,yse,UZ,vse,_se,Ese,Fte];for(const n of kse)uk(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bo={},lp={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Cse(n,e){Bo[n]=e}function Ni(n,e){if(!(n in Bo)||e!=null){const s=Ose(n,e);if(s!==null)Bo[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Bo[n];return t==null||t.isContextLost()?(delete Bo[n],Ni(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Bo[n])}function Lse(n){if(!xe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Ose(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??Lse(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Bo[n]},!1),xe().getBool("SOFTWARE_WEBGL_ENABLED")&&(lp.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",lp)||t.getContext("experimental-webgl",lp):t.getContext("webgl2",lp)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var td;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(td||(td={}));var _r;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(_r||(_r={}));var ms;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(ms||(ms={}));function vh(n,e){return[e,n]}function Rse(n,e){return n*e}function up(n){const e=Te(n),t=Math.ceil(e/4);return G1(t)}function Mu(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function Vse(n,e){const[t,s]=Mu(n,e);return t*s*4}function Ax(n,e){const t=n;let s,r,i,o,l,u,d,h,f,m;return xe().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,o=t.RGBA32F,l=t.RED,d=4,h=1,f=t.HALF_FLOAT,m=t.FLOAT,u=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=t.RGBA,l=n.RGBA,d=4,h=4,f=e!=null?e.HALF_FLOAT_OES:null,m=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:l,downloadTextureFormat:u,downloadUnpackNumChannels:d,defaultNumChannels:h,textureTypeHalfFloat:f,textureTypeFloat:m}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ot(n,e){const t=e();return xe().getBool("DEBUG")&&Pse(n),t}function Pse(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+Wse(n,e))}const Fse=596e-10,zse=65504;function Mse(n){return!!(xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Fse<Math.abs(n)&&Math.abs(n)<zse)}function Wse(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function cp(n,e){return Aa(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Bse(n,e){const t=Aa(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ot(n,()=>n.shaderSource(t,e)),ot(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Hse(n,e){const t=Aa(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ot(n,()=>n.shaderSource(t,e)),ot(n,()=>n.compileShader(t)),xe().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw xV(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const Use=/ERROR: [0-9]+:([0-9]+):/g;function xV(n,e){const t=Use.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((f,m)=>iu((m+1).toString(),i)+f);let l=0;for(let f=0;f<o.length;f++)l=Math.max(o[f].length,l);const u=o.slice(0,s-1),d=o.slice(s-1,s),h=o.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${iu(d[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function Gse(n){return Aa(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function qse(n,e){if(ot(n,()=>n.linkProgram(e)),!xe().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function w1(n,e){if(ot(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Kse(n,e){const t=Aa(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ot(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),ot(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function jse(n,e){const t=Aa(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ot(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),ot(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Yse(n){return Aa(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Xse(n,e){const t=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Zse(n){return Aa(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function H3(n,e,t,s,r,i,o){const l=n.getAttribLocation(e,t);return l===-1?!1:(ot(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),ot(n,()=>n.vertexAttribPointer(l,r,n.FLOAT,!1,i,o)),ot(n,()=>n.enableVertexAttribArray(l)),!0)}function Qse(n,e,t){sre(n,t),ot(n,()=>n.activeTexture(n.TEXTURE0+t)),ot(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Jse(n,e,t){return Aa(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function ere(n,e,t){return n.getUniformLocation(e,t)}function tre(n,e,t,s){ot(n,()=>Qse(n,e,s)),ot(n,()=>n.uniform1i(t,s))}function A1(n,e,t){ot(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ot(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function U3(n,e){ot(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ot(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function dp(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+nre(n,e))}function nre(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Aa(n,e,t){const s=ot(n,()=>e());if(s==null)throw new Error(t);return s}function sre(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Su(n,e=2){return Te(n.slice(0,n.length-e))}function vu(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function hp(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Su(n),...vu(n)]),e}function rre(n,e=!1){let t=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=xe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&xe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((l,u)=>u>=n.length-2?Iy(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=ro(n).newShape);let r=Te(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const l=Su(n);let u=2,d=2;n.length&&([u,d]=vu(n)),r=l*(u/2)*(d/2),i=G1(r).map(h=>h*2)}else i=G1(r);return i}function pp(n){return n%2===0}function df(n,e){if(n=n.slice(-2),e=e.slice(-2),Kt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||pp(t)&&pp(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&pp(n[0])&&pp(e[0])}let T1,S1;function ire(n){if(T1==null){const e=Ni(n);T1=e.getParameter(e.MAX_TEXTURE_SIZE)}return T1}function are(n){if(S1==null){const e=Ni(n);S1=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,S1)}function ore(n){if(n===0)return 0;let e;const t=Ni(n);return qr(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:qr(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function qr(n,e){return n.getExtension(e)!=null}function G3(n){try{if(Ni(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function lre(n){if(n===0)return!1;const e=Ni(n);if(n===1){if(!qr(e,"OES_texture_float"))return!1}else if(!qr(e,"EXT_color_buffer_float"))return!1;return zI(e)}function ure(n){if(n===0)return!1;const e=Ni(n);if(n===1){if(!qr(e,"OES_texture_float")||!qr(e,"WEBGL_color_buffer_float"))return!1}else{if(qr(e,"EXT_color_buffer_float"))return zI(e);const s="EXT_color_buffer_half_float";if(qr(e,s)){const r=e.getExtension(s);return cre(e,r)}return!1}return zI(e)}function zI(n){const e=Ax(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const s=1,r=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,s,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function cre(n,e){const t=Ax(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s);const r=1,i=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,r,i,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),l}function dre(n){return n!==2?!1:Ni(n).fenceSync!=null}function $h(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&W(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gt=xe();gt.registerFlag("HAS_WEBGL",()=>gt.getNumber("WEBGL_VERSION")>0);gt.registerFlag("WEBGL_VERSION",()=>G3(2)?2:G3(1)?1:0);gt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);gt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>gt.get("WEBGL_VERSION")===2);gt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);gt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);gt.registerFlag("WEBGL_PACK",()=>gt.getBool("HAS_WEBGL"));gt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_CLIP",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_REDUCE",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_LAZILY_UNPACK",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_CONV_IM2COL",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>ire(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>are(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=gt.getNumber("WEBGL_VERSION");return n===0?0:ore(n)});gt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>gt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!vk());gt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>lre(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>gt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:gt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));gt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>ure(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>dre(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>gt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);gt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});gt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>vk()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});gt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);gt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);gt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);gt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);gt.registerFlag("WEBGL_EXP_CONV",()=>!1);gt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>gt.getBool("IS_TEST"));gt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);gt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);gt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);gt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(){let n,e,t,s,r,i,o,l,u,d;return xe().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",l=xe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",o="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:l,defineSpecialInf:u,defineRound:d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _l(n,e,t="index"){const s=wt(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / ${r}`,l=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${l};`}).join("")}function gg(n,e,t="index"){const s=wt(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,l=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${l};`}).join("")}function hre(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function pre(n,e,t="index"){const s=n.map((i,o)=>o),r=hre(s,e);return r.map((i,o)=>{const l=`int ${n[o]} = ${t} / ${r[o]}`,u=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${l}; ${u};`}).join("")}function Tx(n){const e=wt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Sx(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const NV=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:wV}=DG;function fre(n,e,t){const s=[];if(n.forEach(I=>{const y=Te(I.shapeInfo.logicalShape);if(I.shapeInfo.isUniform?s.push(`uniform float ${I.name}${y>1?`[${y}]`:""};`):(s.push(`uniform sampler2D ${I.name};`),s.push(`uniform int offset${I.name};`)),t.enableShapeUniforms){const{uniformShape:N}=vx(t.packedInputs,I.shapeInfo.logicalShape,I.shapeInfo.texShape);switch(N.length){case 1:s.push(`uniform int ${I.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${I.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${I.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${I.name}Shape;`);break}s.push(`uniform ivec2 ${I.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(I=>{s.push(`uniform ${I.type} ${I.name}${I.arrayIndex?`[${I.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(I=>mre(I,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,l=Hs(),u=yre(l);let d,h,f=Nre(l);return e.isPacked?(d=gre(e.logicalShape,o,t.enableShapeUniforms),h=xre(l)):(d=Ire(e.logicalShape,o,t.enableShapeUniforms),h=bre(l)),t.packedInputs&&(f+=Sre),[f,u,h,r,d,i,t.userCode].join(`
`)}function Wu(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Pre(n,e);case 1:return zre(n,e);case 2:return Wre(n,e);case 3:return Hre(n,e);case 4:return Gre(n,e);case 5:return qre(n);case 6:return Kre(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function AV(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Vre(n);case 1:return Fre(n,e);case 2:return Mre(n,e);case 3:return Bre(n,e);default:return Ure(n,e)}}function mre(n,e,t=!1,s){let r="";t?r+=AV(n,s):r+=Wu(n,s);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?r+=jre(n,e):r+=Yre(n,e)),r}function gre(n,e,t){switch(n.length){case 0:return TV();case 1:return vre(n,e,t);case 2:return Ore(n,e,t);case 3:return _re(n,e,t);default:return Ere(n,e,t)}}function Ire(n,e,t){switch(n.length){case 0:return TV();case 1:return $re(n,e,t);case 2:return Rre(n,e,t);case 3:return Dre(n,e,t);case 4:return kre(n,e,t);case 5:return Cre(n,e);case 6:return Lre(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function yre(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function bre(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function xre(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function Nre(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${wre}
    ${Are}
    ${Tre}
  `}const wre=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Are=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Tre=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Sre=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function TV(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function vre(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function $re(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function _re(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Dre(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${gg(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=_l(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function Ere(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,l="",u="b, r, c";for(let d=2;d<n.length-1;d++)o*=n[n.length-d-1],l=`
      int b${d} = index / ${o};
      index -= b${d} * ${o};
    `+l,u=`b${d}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${l}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${u});
    }
  `}function kre(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${gg(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=_l(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function Cre(n,e){const t=_l(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Lre(n,e){const t=_l(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Ore(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Kt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function Rre(n,e,t){return Kt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Dl(n){return`offset${n}`}function Vre(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Hs();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function Pre(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Dl(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[l,u]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${l}, ${u}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function Fre(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Hs();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function zre(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Bu(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const l=Dl(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${l});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${l});
      return sampleTexture(${t}, uv);
    }
  `}function Mre(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],l=i[1],u=Hs();if(i!=null&&Kt(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${o}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const d=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],h=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${d[0]}, ${d[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function Wre(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&Kt(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],I=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${I}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:l}=ro(t),u=o;if(u.length<t.length){const m=Hu(n,u),I=["row","col"];return`
      ${Wu(m,e)}
      float ${r}(int row, int col) {
        return ${r}(${Uu(I,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Bu(n)}
      }
    `;const d=i[0],h=i[1],f=Dl(s);return h===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `:d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${f};
    vec2 uv = uvFromFlat(${d}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function Bre(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const m=t.slice(1),I=[1,2],y=Hu(n,m),N=["b","row","col"];return`
        ${AV(y,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Uu(N,I)});
        }
      `}const l=Hs();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const u=o[0],d=o[1],h=Math.ceil(t[2]/2),f=h*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${d}, ${f}, ${h}, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function Hre(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],o=t[2],{newShape:l,keptDims:u}=ro(t),d=l;if(d.length<t.length){const N=Hu(n,d),w=["row","col","depth"];return`
        ${Wu(N,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Uu(w,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Bu(n)}
      }
    `;const h=n.shapeInfo.texShape,f=h[0],m=h[1],I=n.shapeInfo.flatOffset;if(m===i&&I==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${f}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===o&&I==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `;const y=Dl(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${y};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${y};
        vec2 uv = uvFromFlat(${f}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Ure(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Hs();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,l=n.shapeInfo.texShape,u=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],d=u[0],h=u[1],f=Math.ceil(i[o-1]/2);let m=f*Math.ceil(i[o-2]/2),I="int b, int row, int col",y=`b * ${m} + (row / 2) * ${f} + (col / 2)`;for(let N=2;N<o-1;N++)I=`int b${N}, `+I,m*=i[o-N-1],y=`b${N} * ${m} + `+y;return`
    vec4 ${s}(${I}) {
      int index = ${y};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${d});
      return ${r.texture2D}(${t}, uv);
    }
  `}function Gre(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],o=t[2]*i,l=t[1]*o,{newShape:u,keptDims:d}=ro(t);if(u.length<t.length){const v=Hu(n,u),E=["row","col","depth","depth2"];return`
      ${Wu(v,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Uu(E,d)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${o}, ${i}, 1)));
        ${Bu(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],I=f[1],y=`int stride2 = ${s}Shape[3];`,N=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(I===l&&h==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${y}
        ${N}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${I}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(I===i&&h==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${I}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const T=Dl(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${y}
      ${N}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${T});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${I}, index + ${T});
      return sampleTexture(${s}, uv);
    }
  `}function qre(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,o=e[2]*i,l=e[1]*o,{newShape:u,keptDims:d}=ro(e);if(u.length<e.length){const N=Hu(n,u),w=["row","col","depth","depth2","depth3"];return`
      ${Wu(N)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Uu(w,d)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${o}, ${i}, ${r})) +
          depth3;
        ${Bu(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],I=f[1];if(I===l&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${I}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(I===r&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${I}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;const y=Dl(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${y};
      vec2 uv = uvFromFlat(${m}, ${I}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Kre(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=ro(e);if(r.length<e.length){const w=Hu(n,r),T=["row","col","depth","depth2","depth3","depth4"];return`
      ${Wu(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Uu(T,i)});
      }
    `}const o=e[5],l=e[4]*o,u=e[3]*l,d=e[2]*u,h=e[1]*d;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${d}, ${u}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Bu(n)}
      }
    `;const f=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,I=m[0],y=m[1];if(y===h&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${d}, ${u}, ${l}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${I}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(y===o&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${I}.0);
        return sampleTexture(${t}, uv);
      }
    `;const N=Dl(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${d} + depth * ${u} +
          depth2 * ${l} + depth3 * ${o} + depth4 + ${N};
      vec2 uv = uvFromFlat(${I}, ${y}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Bu(n){const e=n.name,t=Te(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function jre(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,l=wV(n.shapeInfo.logicalShape,e.logicalShape),u=dn(o),d=o-i;let h;const f=["x","y","z","w","u","v"];i===0?h="":o<2&&l.length>=1?h="coords = 0;":h=l.map(v=>`coords.${f[v+d]} = 0;`).join(`
`);let m="";o<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((v,E)=>`coords.${f[E+d]}`).join(", ");let I="return outputValue;";const N=Te(n.shapeInfo.logicalShape)===1,T=Te(e.logicalShape)===1;if(i===1&&!N&&!T)I=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(N&&!T)o===1?I=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:I=`
        return vec4(outputValue.x);
      `;else if(l.length){const v=i-2,E=i-1;l.indexOf(v)>-1&&l.indexOf(E)>-1?I="return vec4(outputValue.x);":l.indexOf(v)>-1?I="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(E)>-1&&(I="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${m});
      ${I}
    }
  `}function Yre(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,l=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&l===u&&n.shapeInfo.flatOffset==null&&Kt(o,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const d=dn(u),h=wV(n.shapeInfo.logicalShape,e.logicalShape),f=u-l;let m;const I=["x","y","z","w","u","v"];l===0?m="":u<2&&h.length>=1?m="coords = 0;":m=h.map(N=>`coords.${I[N+f]} = 0;`).join(`
`);let y="";return u<2&&l>0?y="coords":y=n.shapeInfo.logicalShape.map((N,w)=>`coords.${I[w+f]}`).join(", "),`
    float ${r}() {
      ${d} coords = getOutputCoords();
      ${m}
      return get${s}(${y});
    }
  `}function dn(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function vx(n,e,t){const{newShape:s,keptDims:r}=ro(e),i=e.length,o=n&&i===3&&e[0]===1,l=o?e.slice(1):s,u=!n&&i>1&&!Kt(e,t)&&s.length<i||o;return{useSqueezeShape:u,uniformShape:u?l:e,keptDims:r}}function Hu(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Uu(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xre(n,e,t,s){const r=t.map((h,f)=>{const m={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(m.flatOffset=h.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:m}}),i=r.map(h=>h.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=fre(r,o,e),u=Hse(n.gl,l),d=n.createProgram(u);return xe().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:l,webGLProgram:d,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(d),Object.assign({program:e,fragmentShader:u,source:l,webGLProgram:d,inShapeInfos:i,outShapeInfo:o},SV(n,e,d)))}function SV(n,e,t){const s=[],r=[];let i,o,l,u=null,d=null;d=n.getUniformLocation(t,"NAN",!1),xe().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const h=!1;for(const f of e.variableNames){const m={name:f,uniform:n.getUniformLocation(t,f,h),offset:n.getUniformLocation(t,`offset${f}`,h)};e.enableShapeUniforms&&(m.shape=n.getUniformLocation(t,`${f}Shape`,h),m.texShape=n.getUniformLocation(t,`${f}TexShape`,h)),s.push(m)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",h),l=n.getUniformLocation(t,"outShapeStrides",h),o=n.getUniformLocation(t,"outTexShape",h)),e.customUniforms)for(const f of e.customUniforms)r.push(n.getUniformLocation(t,f.name,h));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:d,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:o}}function q3(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],o=i.shape;if(!Kt(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const l=t.texShape,u=i.isUniform?null:i.texData.texShape;if(!Kt(l,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${u} must match`)})}function Zre(n,e,t,s,r){e.program.enableShapeUniforms||(q3(e.inShapeInfos,t),q3([e.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),xe().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<t.length;++u){const d=t[u],{uniform:h,offset:f,shape:m,texShape:I}=e.variablesLocations[u];if(m){const{uniformShape:y}=vx(e.program.packedInputs,d.shape,d.texData.texShape);switch(y.length){case 1:n.gl.uniform1iv(m,new Int32Array(y));break;case 2:n.gl.uniform2iv(m,new Int32Array(y));break;case 3:n.gl.uniform3iv(m,new Int32Array(y));break;case 4:n.gl.uniform4iv(m,new Int32Array(y));break}}if(I&&n.gl.uniform2i(I,d.texData.texShape[0],d.texData.texShape[1]),h!=null){if(d.isUniform){if(Te(d.shape)<2)n.gl.uniform1f(h,d.uniformValues[0]);else{let y=d.uniformValues;y instanceof Float32Array||(y=new Float32Array(y)),n.gl.uniform1fv(h,y)}continue}d.texData.slice!=null&&f!=null&&n.gl.uniform1i(f,d.texData.slice.flatOffset),n.setInputMatrixTexture(d.texData.texture.texture,h,u)}}const l=e.outShapeLocation;if(l)switch(s.shape.length){case 1:n.gl.uniform1iv(l,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(l,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(l,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(l,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=wt(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const d=e.program.customUniforms[u],h=e.customUniformLocations[u],f=r[u];if(d.type==="float")n.gl.uniform1fv(h,f);else if(d.type==="vec2")n.gl.uniform2fv(h,f);else if(d.type==="vec3")n.gl.uniform3fv(h,f);else if(d.type==="vec4")n.gl.uniform4fv(h,f);else if(d.type==="int")n.gl.uniform1iv(h,f);else if(d.type==="ivec2")n.gl.uniform2iv(h,f);else if(d.type==="ivec3")n.gl.uniform3iv(h,f);else if(d.type==="ivec4")n.gl.uniform4iv(h,f);else throw Error(`uniform type ${d.type} is not supported yet.`)}n.executeProgram()}function Qre(n,e,t){let s="";e.concat(t).forEach(o=>{const l=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const u=o.texData.texShape,{useSqueezeShape:d,uniformShape:h,keptDims:f}=vx(n.packedInputs,o.shape,u);let m="",I="",y="";if(h.length===1&&n.packedInputs){const L=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${L[0]>1}_${L[1]>1}`}else if(h.length===2&&!n.packedInputs)I=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!n.packedInputs){const L=wt(h);y=`${L[0]===u[1]}_${L[L.length-1]===u[1]}`}const N=o.shape.length,w=h.length===2&&Kt(o.shape,u),T=Te(o.shape)===1,v=yu(o.shape,t.shape),E=!n.packedInputs&&N===t.shape.length&&Kt(u,t.texData.texShape),_=n.packedInputs||h.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${N}_${E}_${d?f:""}_${h.length}_${T}_${v}_${w}_${m}_${I}_${y}_${_}_${l}`}else{const u=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${u}_${l}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${xe().getNumber("WEBGL_VERSION")}`,i}function Ds(n){return xe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jre{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=td.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Hs();this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?gg(["r","c","d"],e):_l(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eie{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=td.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Hs();this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?gg(["r","c","d"],e):_l(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tie{constructor(e){this.variableNames=["A"],this.outTexUsage=_r.DOWNLOAD;const t=Hs();this.outputShape=e,this.userCode=`
      ${NV}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nie{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=_r.DOWNLOAD;const t=Hs();this.outputShape=e,this.userCode=`
      ${NV}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sie={R:0,G:1,B:2,A:3};class K3{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Hs();this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let l=0;l<s.length;l++){const u=s[l];o+=`
          if(offset == ${l}) {
            result = values[${sie[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Sx():Tx(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rie{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Hs();this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){const u=o*2+l;r+=`
          localCoords = coords;
          if(localCoords[2] + ${l} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${l};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Sx():Tx(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iie(n){const e=Hs(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Bse(n,t)}function aie(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Kse(n,e)}function oie(n){const e=new Uint16Array([0,1,2,2,1,3]);return jse(n,e)}function _h(n,e,t,s,r,i){Xse(e,t);const o=Yse(n),l=n.TEXTURE_2D;return ot(n,()=>n.bindTexture(l,o)),ot(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ot(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ot(n,()=>n.texParameteri(l,n.TEXTURE_MIN_FILTER,n.NEAREST)),ot(n,()=>n.texParameteri(l,n.TEXTURE_MAG_FILTER,n.NEAREST)),xe().getNumber("WEBGL_VERSION")===1?ot(n,()=>n.texImage2D(l,0,s,e,t,0,r,i,null)):ot(n,()=>n.texStorage2D(l,1,s,e,t)),ot(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function vV(n){return n.internalFormatFloat}function lie(n,e,t,s){const[r,i]=vh(e,t);return _h(n,r,i,vV(s),s.textureFormatFloat,n.FLOAT)}function $V(n){return n.internalFormatHalfFloat}function uie(n,e,t,s){const[r,i]=vh(e,t);return _h(n,r,i,$V(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function _V(n){return n.downloadTextureFormat}function cie(n,e,t,s){const[r,i]=vh(e,t);return _h(n,r,i,_V(s),n.RGBA,n.UNSIGNED_BYTE)}function DV(n){return n.internalFormatPackedFloat}function die(n,e,t,s){const[r,i]=Mu(e,t);return _h(n,r,i,DV(s),n.RGBA,n.FLOAT)}function EV(n){return n.internalFormatPackedHalfFloat}function hie(n,e,t,s){const[r,i]=Mu(e,t);return _h(n,r,i,EV(s),n.RGBA,s.textureTypeHalfFloat)}function pie(n,e,t){return ot(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),H3(n,e,"clipSpacePos",t,3,20,0)&&H3(n,e,"uv",t,2,20,12)}function fie(n,e,t,s,r,i){ot(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,l,u;r instanceof Uint8Array?(o=new Uint8Array(t*s*4),l=n.UNSIGNED_BYTE,u=n.RGBA):(o=new Float32Array(t*s*4),l=n.FLOAT,u=i.internalFormatPackedFloat),o.set(r),xe().getNumber("WEBGL_VERSION")===2?ot(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,l,o)):ot(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,s,0,n.RGBA,l,o)),ot(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function mie(n,e,t){ot(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?xe().getNumber("WEBGL_VERSION")===2?ot(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):ot(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):xe().getNumber("WEBGL_VERSION")===2?ot(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):ot(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),ot(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function gie(n,e,t,s){const r=n.createBuffer();ot(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const l=4*4*e*t;return ot(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,l,n.STREAM_READ)),ot(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),ot(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function Iie(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function yie(n,e,t,s){const[r,i]=vh(e,t),o=4,l=new Uint8Array(Rse(e*t,o));return ot(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function bie(n,e,t,s,r,i,o,l){const u=n,d=new Float32Array(Vse(i,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,d),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),d}function xie(n,e,t){const s=new Float32Array(e*t*4);return ot(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v1{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=xe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,Cse(t,e)):this.gl=Ni(t),e=this.gl,xe().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>ot(i,()=>i.createVertexArray()),this.bindVertexArray=o=>ot(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>ot(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>ot(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ot(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>ot(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ot(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>ot(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),xe().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=cp(this.gl,i),qr(this.gl,o))this.textureHalfFloatExtension=cp(this.gl,o);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),qr(this.gl,r))this.colorBufferHalfFloatExtension=cp(this.gl,r);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",qr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(qr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=aie(this.gl),this.indexBuffer=oie(this.gl),this.framebuffer=Zse(this.gl),this.textureConfig=Ax(this.gl,this.textureHalfFloatExtension)}get debug(){return xe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ot(e,()=>e.finish()),ot(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ot(e,()=>e.deleteFramebuffer(this.framebuffer)),ot(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ot(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ot(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),lie(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),uie(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),cie(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),mie(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),fie(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),hie(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),die(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(U3(this.gl,this.framebuffer),this.outputTexture=null),ot(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>yie(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,o){return bie(this.gl,e,t,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Iie(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=gie(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(xe().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=i}else xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>xie(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=iie(t));const s=Gse(t);ot(t,()=>t.attachShader(s,this.vertexShader)),ot(t,()=>t.attachShader(s,e)),qse(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&w1(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;ot(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),pie(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(ot(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&w1(this.gl,this.program),ot(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?Jse(this.gl,e,t):ere(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ot(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),tre(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=Mu(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&w1(this.gl,this.program),dp(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ot(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ot(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=cp(this.gl,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await __(()=>this.disposed||this.isQueryAvailable(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=Nie(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in xe().platform&&(s=xe().platform.setTimeoutCustom.bind(xe().platform)),__(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),A1(this.gl,e,this.framebuffer),this.debug&&dp(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(A1(this.gl,this.outputTexture,this.framebuffer),this.debug&&dp(this.gl)):U3(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;A1(r,e,this.framebuffer),this.debug&&dp(r),this.outputTexture=e,ot(r,()=>r.viewport(0,0,t,s)),ot(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),ot(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Nie(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:wie,bincountImpl:kV,bincountReduceImpl:Aie,bitwiseAndImpl:Tie,castImpl:Sie,ceilImpl:vie,concatImpl:$ie,equalImpl:_ie,expImpl:Die,expm1Impl:Eie,floorImpl:kie,gatherNdImpl:Cie,gatherV2Impl:Lie,greaterImpl:Oie,greaterEqualImpl:Rie,lessImpl:Vie,lessEqualImpl:Pie,linSpaceImpl:Fie,logImpl:zie,maxImpl:Mie,maximumImpl:Wie,minimumImpl:Bie,multiplyImpl:Hie,negImpl:Uie,notEqualImpl:Gie,prodImpl:qie,raggedGatherImpl:Kie,raggedRangeImpl:jie,raggedTensorToTensorImpl:Yie,rangeImpl:Xie,rsqrtImpl:Zie,scatterImpl:Qie,sigmoidImpl:Jie,simpleAbsImpl:CV,sliceImpl:eae,sparseFillEmptyRowsImpl:tae,sparseReshapeImpl:nae,sparseSegmentReductionImpl:LV,sqrtImpl:sae,staticRegexReplaceImpl:rae,stridedSliceImpl:iae,stringNGramsImpl:aae,stringSplitImpl:oae,stringToHashBucketFastImpl:lae,subImpl:uae,tileImpl:cae,topKImpl:dae,transposeImpl:$x,uniqueImpl:hae}=mQ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OV(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function zs(n,e){return e===1?[n]:OV(n,e)}function pae(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fae{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ds(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=zs("rc",this.rank),s=dn(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RV{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${mae(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Sx():Tx(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function mae(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?pre(["r","c","d"],"inputShape"):_l(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gae{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=Y3(t,s),i=X3(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=j3(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const u=this.freeTextures[i].pop();return this.usedTextures[i].push(u),u}let l;return r===ms.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===ms.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===ms.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===ms.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===ms.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(l),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),l}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=Y3(s,r),o=X3(t,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const l=j3(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=xe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=l):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const d=this.usedTextures[o],h=d&&d.indexOf(e);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");d[h]=d[d.length-1],d.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Iae(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function j3(n,e,t,s,r){const i=yae(e,s);let o;if(r){const[u,d]=Mu(n[0],n[1]);o=u*d}else{const[u,d]=vh(n[0],n[1]);o=u*d}const l=Iae(t,i);return o*l}function yae(n,e){switch(n){case ms.PACKED_2X2_FLOAT32:return DV(e);case ms.PACKED_2X2_FLOAT16:return EV(e);case ms.UNPACKED_FLOAT32:return vV(e);case ms.UNPACKED_FLOAT16:return $V(e);case ms.PACKED_4X1_UNSIGNED_BYTE:return _V(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function bae(n){return xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?ms.PACKED_2X2_FLOAT32:ms.UNPACKED_FLOAT32:n?ms.PACKED_2X2_FLOAT16:ms.UNPACKED_FLOAT16}function Y3(n,e){if(n===_r.UPLOAD)return ms.PACKED_2X2_FLOAT32;if(n===_r.RENDER||n==null)return bae(e);if(n===_r.DOWNLOAD||n===_r.PIXELS)return ms.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function X3(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fi{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const ni="if (isnan(x)) return x;",xae="return x;",Z3="return abs(x);",Nae="return (x >= 0.0) ? x : (exp(x) - 1.0);",wae=ni+`
  return (x < 0.0) ? 0.0 : x;
`,Aae=ni+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,La="return x;",Tae="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sae="return x;",vae=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,$ae=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_ae=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dae="return 1.0 / (1.0 + exp(-1.0 * x));";class za{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eae{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length);const t=e.length,s=zs("rc",t),r=dn(t),i=pae(t,s),o=s.slice(-2),l=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kae=cb,Cae=1e-7,Lae=1e-4,fp={};function Oae(n){return n in fp||(fp[n]={}),fp[n]}const Rae=xe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Vae=600;function Pae(){return xe().global.screen==null?1024:xe().global.screen.height*xe().global.screen.width*window.devicePixelRatio*Vae/1024/1024}class Ig extends gy{nextDataId(){return Ig.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof v1)t=e;else{const s=Ni(xe().getNumber("WEBGL_VERSION"),e);t=new v1(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Ni(xe().getNumber("WEBGL_VERSION"));t=new v1(s),this.binaryCache=Oae(xe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new gae(this.gpgpu),this.numMBBeforeWarning=Pae(),this.texData=new nk(this,Fr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,o){const l=this.makeTensorInfo(t,s),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,i]},u.texShape=[r,i];const d=hp(t),h=new K3(d,!1,o),f=this.runWebGLProgram(h,[l],s,[[r,i]]);return f.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(l),f.dataId}write(e,t,s){if((xe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xe().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:_r.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(xe().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:_r.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:l,isPacked:u}=t;if(o!=null){let m;u?m=new za(l,La):m=new Fi(l,La);const I=this.runWebGLProgram(m,[{dataId:e,shape:l,dtype:r}],r),y=this.readSync(I.dataId);return this.disposeIntermediateTensorInfo(I),y}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const d=this.activeTimers!=null;let h;d&&(h=js());let f;if(r==="complex64"){const m=this.readSync(i.real.dataId),I=this.readSync(i.imag.dataId);f=ga(m,I)}else f=this.getValuesFromTexture(e);return d&&(this.downloadWaitMs+=js()-h),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const y=this.pendingRead.get(e);return new Promise(N=>y.push(N))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:l,isPacked:u}=t;if(i!=null){let y;u?y=new za(r,La):y=new Fi(r,La);const N=this.runWebGLProgram(y,[{dataId:e,shape:r,dtype:o}],o),w=this.read(N.dataId);return this.disposeIntermediateTensorInfo(N),w}if(s!=null)return this.convertAndCacheOnCPU(e);if(xe().getBool("DEBUG")&&!xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&xe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d=null,h;if(o!=="complex64"&&xe().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(e);const y=this.texData.get(h.dataId);d=this.gpgpu.createBufferFromTexture(y.texture.texture,...up(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(o==="complex64"){const y=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),N=y[0],w=y[1];f=ga(N,w)}else if(d==null)f=this.getValuesFromTexture(e);else{const y=Te(r);f=this.gpgpu.downloadFloat32MatrixFromBuffer(d,y)}if(h!=null&&this.disposeIntermediateTensorInfo(h),d!=null){const y=this.gpgpu.gl;ot(y,()=>y.deleteBuffer(d))}const m=this.convertAndCacheOnCPU(e,f),I=this.pendingRead.get(e);return this.pendingRead.delete(e),I.forEach(y=>y(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Fr().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:o,dtype:l,isPacked:u,texture:d}=s;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let I;u?I=new za(i,La):I=new Fi(i,La);const y=this.runWebGLProgram(I,[{dataId:e,shape:i,dtype:l}],l),N=this.readToGPU(y,t);return this.disposeIntermediateTensorInfo(y),N}if(d==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,t.customTexShape),f=Fr().makeTensorFromTensorInfo(h),m=this.texData.get(h.dataId);return Object.assign({tensorRef:f},m.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ga(r));return zt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!Mse(s))throw xe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=Te(t);if(xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),I=this.texData.get(m.dataId),y=this.gpgpu.downloadMatrixFromPackedTexture(I.texture.texture,...up(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),y}const o=xe().getBool("WEBGL_PACK")&&r===!0,l=o?hp(t):t,u=o?new nie(l):new tie(l),d=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:e}],"float32"),h=this.texData.get(d.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(d),f}timerAvailable(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=nl(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),o=nl(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(i);l.kernelMs=sM(u),l.getExtraProfileInfo=()=>u.map((d,h)=>({name:o[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:js(),endMs:null}}endTimer(e){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=js(),e)}async getQueryTime(e){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:o,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,d=this.dataRefCount.get(u);d>1?this.dataRefCount.set(u,d-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,o)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Rae){return xe().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&Te(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){vr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return kae(e.shape,t)}packedUnaryOp(e,t,s){const r=new za(e.shape,t),i=this.compileAndRun(r,[e],s);return Fr().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=CV(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(xe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Z3,e.dtype);const t=new Fi(e.shape,Z3),s=this.compileAndRun(t,[e]);return Fr().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&cd(s[0])){const i=s.map(o=>Ba(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return Fr().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new Eae(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new fae(e.shape),s=!0;return this.runWebGLProgram(t,[e],e.dtype,null,s)}packedReshape(e,t){const s=[Su(e.shape),...vu(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Su(t),...vu(t)],o=new RV(i,s),l=!0,u=[s],d=this.runWebGLProgram(o,[r],e.dtype,u,l);return{dataId:d.dataId,shape:t,dtype:d.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:o}=s;if(t!=null){const m=Te(i),I=t[0]*t[1]*4;W(m<=I,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=hp(i);let u;r?u=new eie(l):u=new Jre(l);const d=!0,h=[t??up(l)],f=this.runWebGLProgram(u,[{shape:l,dtype:o,dataId:e}],o,h,d,t);return{dtype:o,shape:i,dataId:f.dataId}}runWebGLProgram(e,t,s,r,i=!1,o){const l=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===td.DENSE){const T=o??up(e.outputShape);u.texShape=T.map(v=>v*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),Te(l.shape)===0)return u.values=Is(l.dtype,0),l;const d=[],h=t.map(T=>{if(T.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(T.dataId);if(v.texture==null){if(!e.packedInputs&&Te(T.shape)<=xe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:T.shape,texData:null,isUniform:!0,uniformValues:v.values};e.packedInputs&&(v.isPacked=!0,v.shape=T.shape)}if(this.uploadToGPU(T.dataId),!!v.isPacked!=!!e.packedInputs)T=v.isPacked?this.unpackTensor(T):this.packTensor(T),d.push(T),v=this.texData.get(T.dataId);else if(v.isPacked&&!df(v.shape,T.shape)){const E=T,_=T.shape;T.shape=v.shape,T=this.packedReshape(T,_),d.push(T),v=this.texData.get(T.dataId),E.shape=_}return{shape:T.shape,texData:v,isUniform:!1}});this.uploadToGPU(l.dataId);const f={shape:l.shape,texData:u,isUniform:!1},m=Qre(e,h,f),I=this.getAndSaveBinary(m,()=>Xre(this.gpgpu,e,h,f)),y=this.activeTimers!=null;let N;y&&(N=this.startTimer()),xe().get("ENGINE_COMPILE_ONLY")||Zre(this.gpgpu,I,h,f,r),d.forEach(T=>this.disposeIntermediateTensorInfo(T)),y&&(N=this.endTimer(N),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(N)}));const w=xe().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const T=js();T-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=T)}if(!xe().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){const T=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),T}return l}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(xe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=pe(()=>{if(!xe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=xe().getBool("DEBUG");xe().set("DEBUG",!1);const t=this.abs(At(1e-8)).dataSync()[0];if(xe().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Cae:Lae}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:o,usage:l,isPacked:u}=t;if(o!=null)return;const d=this.activeTimers!=null;let h;d&&(h=js());let f=t.texShape;if(f==null&&(f=rre(s,u),t.texShape=f),i!=null){const m=hp(s);let I,y=f[1],N=f[0];const w=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!w)&&([y,N]=Mu(f[0],f[1])),u?I=new rie(m,w):I=new K3(m,w);const T=w?[N,y]:f,v=this.makeTensorInfo(T,r),E=this.texData.get(v.dataId);w?E.usage=_r.PIXELS:E.usage=_r.UPLOAD,E.texShape=T,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),y,N,i);const _=[[N,y]],L=!0,P=this.runWebGLProgram(I,[v],r,_,L),B=this.texData.get(P.dataId);t.texShape=B.texShape,t.isPacked=B.isPacked,t.usage=B.usage,xe().get("ENGINE_COMPILE_ONLY")?this.disposeData(P.dataId):(t.texture=B.texture,t.values=null,this.texData.delete(P.dataId)),this.disposeIntermediateTensorInfo(v),d&&(this.uploadWaitMs+=js()-h)}else{const m=this.acquireTexture(f,l,r,u);t.texture=m}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=Fae(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Fp(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await bL(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(xV(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:u}=SV(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:o,channels:l}=e,u=Fr().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const d=u.writeTexture(r,t,s,i,o,l);return Fr().makeTensorFromDataId(d,t,s,u)}}Ig.nextDataId=0;function Fae(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */$k()&&Ek("webgl",()=>new Ig,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _x=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class fl{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Lt(t,s),this.enableShapeUniforms=Ds(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const El=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Gu{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Lt(t,s);const i=this.outputShape.length;this.enableShapeUniforms=Ds(i);let o="";if(r)if(i===0||Te(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${dn(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=zs("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gr(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const zae={kernelName:kd,backendName:"webgl",kernelFunc:gr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function go(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(i.dataId),l=gr({inputs:{x:s},backend:t}),u=gr({inputs:{x:r},backend:t});return o.complexTensorInfos={real:l,imag:u},i}const Mae={kernelName:vy,backendName:"webgl",kernelFunc:go};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VV="return (a < 0.) ? b * a : a;",PV=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Wae(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,o=t.makeTensorInfo([],"float32",io(i,"float32")),l=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gu(PV,r.shape,o.shape):new fl(VV,r.shape,o.shape),u=t.runWebGLProgram(l,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),u}const Bae={kernelName:Xf,backendName:"webgl",kernelFunc:Wae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FV="return (a < 0.) ? b * a : a;",zV=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Hae(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gu(zV,s.shape,r.shape):new fl(FV,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const Uae={kernelName:mm,backendName:"webgl",kernelFunc:Hae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qu="if (isnan(x)) return x;";function Qt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,l=i,u=s||o.dtype;if(l.shouldExecuteOnCPU([o])&&t!=null){const f=l.texData.get(o.dataId),m=t(f.values,u);return l.makeTensorInfo(o.shape,u,m)}const d=xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let h;return d?h=new za(o.shape,e):h=new Fi(o.shape,n),l.runWebGLProgram(h,[o],u)}}function ws({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:l})=>{const{a:u,b:d}=o,h=l;if(s&&u.dtype==="complex64"){const y=h.texData.get(u.dataId),N=h.texData.get(d.dataId),[w,T]=[[y.complexTensorInfos.real,N.complexTensorInfos.real],[y.complexTensorInfos.imag,N.complexTensorInfos.imag]].map(E=>{const[_,L]=E,P={dataId:_.dataId,dtype:_.dtype,shape:u.shape},B={dataId:L.dataId,dtype:L.dtype,shape:d.shape},U=new fl(n,u.shape,d.shape);return h.runWebGLProgram(U,[P,B],dr(_.dtype,L.dtype))}),v=go({inputs:{real:w,imag:T},backend:h});return h.disposeIntermediateTensorInfo(w),h.disposeIntermediateTensorInfo(T),v}const f=i||dr(u.dtype,d.dtype);if((u.dtype==="string"||d.dtype==="string"||h.shouldExecuteOnCPU([u,d]))&&r!=null){const y=h.texData.get(u.dataId).values,N=h.texData.get(d.dataId).values,w=u.dtype==="string"?Ia(y):y,T=u.dtype==="string"?Ia(N):N,[v,E]=r(u.shape,d.shape,w,T,f),_=h.makeTensorInfo(E,f),L=h.texData.get(_.dataId);return L.values=v,_}const m=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let I;return m?I=new Gu(e,u.shape,d.shape,t):I=new fl(n,u.shape,d.shape),h.runWebGLProgram(I,[u,d],f)}}function nd(n,e=!1){if(n==="linear")return e?Sae:xae;if(n==="relu")return e?$ae:wae;if(n==="elu")return e?vae:Nae;if(n==="relu6")return e?_ae:Aae;if(n==="prelu")return e?zV:FV;if(n==="leakyrelu")return e?PV:VV;if(n==="sigmoid")return e?Dae:Tae;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MV{constructor(e,t,s,r=!1,i=!1,o=!1,l=null,u=!1,d=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Ds(this.outputShape.length);const h=r?e[1]:e[2],f=Math.ceil(h/2),m=r?"i * 2, rc.y":"rc.y, i * 2",I=i?"rc.z, i * 2":"i * 2, rc.z",y=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],N=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",T="";l&&(u?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:d?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:w=`vec4 activation(vec4 x) {
          ${l}
        }`,T="result = activation(result);");const v=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),d&&this.variableNames.push("leakyreluAlpha");let E="rc.x",_="rc.x";e[0]<t[0]?E=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(_=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${E};
        int batchB = ${_};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${I});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${y[0]} * ${N[0]});
          result += (${y[1]} * ${N[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${T}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q3={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class J3{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Lt(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eD="return a * b;";function Dx(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=dr(s.dtype,r.dtype);if(s.dtype==="complex64"){const l=t.texData.get(s.dataId),u=t.texData.get(r.dataId),d=new J3(Q3.REAL,s.shape,r.shape),h=new J3(Q3.IMAG,s.shape,r.shape),f=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],m=t.runWebGLProgram(d,f,"float32"),I=t.runWebGLProgram(h,f,"float32"),y=go({inputs:{real:m,imag:I},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(I),y}if(t.shouldExecuteOnCPU([s,r])){const l=t.texData.get(s.dataId),u=t.texData.get(r.dataId),[d,h]=Hie(s.shape,r.shape,l.values,u.values,i),f=t.makeTensorInfo(h,i),m=t.texData.get(f.dataId);return m.values=d,f}let o;return xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Gu(eD,s.shape,r.shape):o=new fl(eD,s.shape,r.shape),t.runWebGLProgram(o,[s,r],i)}const Gae={kernelName:Md,backendName:"webgl",kernelFunc:Dx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qae(n,e,t){const s=[Su(n.shape),...vu(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[Su(e),...vu(e)],o=new RV(i,s),l=!0,u=[s],d=t.runWebGLProgram(o,[r],n.dtype,u,l);return{dataId:d.dataId,shape:e,dtype:d.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function et(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=t,l=Te(r.shape),u=sk(i,l),d=Te(u);W(l===d,()=>`The new shape (${u}) has ${d} elements and the old shape (${r.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const h=o.texData.get(r.dataId);return h.isPacked&&!df(r.shape,u)&&!(h.texture!==null&&df(h.shape,u))?qae(r,u,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const Kae={kernelName:Im,backendName:"webgl",kernelFunc:et};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tD{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];const l=Math.floor(s/4)*4,u=s%4;let d="sumValue += dot(values, ones);";if(t!=null){const f=1/t;d=`sumValue += dot(values * ${fu(f)?f.toPrecision(2):f}, ones);`}let h="";i%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${l};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${d}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${d}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${d}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jae{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];let l="0.0",u="";t==="prod"?l="1.0":t==="min"?(l="1.0 / 1e-20",u="min"):t==="max"&&(l="-1.0 / 1e-20",u="max");let d=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?d="sumValue":t==="prod"?d="prodValue":t==="all"?d="allValue":t==="any"&&(d="anyValue");const h=Math.floor(s/4)*4,f=s%4;let m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,I="vec4";t==="all"?(l="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,I="bvec4"):t==="any"&&(l="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,I="bvec4");let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${l};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${l});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${I} values = ${I}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${h};
        if (${f===1}) {
          ${I} values = ${I}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${f===2}) {
          ${I} values = ${I}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${f===3}) {
          ${I} values = ${I}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${d});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yae(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=tg(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function kl(n,e,t,s){const r=Yae(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:l,windowSize:u,outSize:d}=r[o];let h,f;t==="mean"?h=o===0?new tD({windowSize:u,inSize:l,batchSize:n.shape[0],outSize:d},l):new tD({windowSize:u,inSize:l,batchSize:n.shape[0],outSize:d}):h=new jae({windowSize:u,inSize:l,batchSize:n.shape[0],outSize:d},t),f=i,i=s.runWebGLProgram(h,[i],e),f.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(f)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xae{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const r=dn(this.rank),i=Zae(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Zae(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qae{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let h=0;h<s.length;h++)s[h]=e[t[h]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=dn(this.rank),i=OV("rc",this.rank),o=new Array(this.rank);for(let h=0;h<t.length;h++)o[t[h]]=i[h];const l=`vec2(${o.slice(-2).join()})`,u=`++${i[this.rank-1]} < ${s[this.rank-1]}`,d=`getChannel(getA(${o.join()}), ${l})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${d};
      if(${u}) {
        result[1] = ${d};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${d};
        if(${u}) {
          result[3] = ${d};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yg(n,e,t){const s=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qae(n.shape,e):new Xae(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jae(n,e,t,s){const r=e,i=n.shape.length,o=Bt(r,n.shape);let l=o;const u=En(l,i),d=u!=null;let h=n;d&&(h=yg(n,u,s),l=zn(l.length,i)),xs("sum",l,i);const[f,m]=us(h.shape,l);let I=f;t&&(I=Fn(f,o));const y=Te(m),w=Te(n.shape)/y,T=et({inputs:{x:h},attrs:{shape:[w,y]},backend:s}),v=S2(n.dtype),E=kl(T,v,"sum",s),_=et({inputs:{x:E},attrs:{shape:I},backend:s});return s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(E),d&&s.disposeIntermediateTensorInfo(h),_}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bg(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return Jae(r,i,o,t)}const eoe={kernelName:Am,backendName:"webgl",kernelFunc:bg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ws(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,o=t,l=r.shape.length,u=new Array(l);for(let h=0;h<u.length;h++)u[h]=r.shape[i[h]];let d;if(o.shouldExecuteOnCPU([r])){const f=o.texData.get(r.dataId).values,m=$x(f,r.shape,r.dtype,i,u);d=o.makeTensorInfo(u,r.dtype);const I=o.texData.get(d.dataId);I.values=m}else d=yg(r,i,o);return d}const toe={kernelName:au,backendName:"webgl",kernelFunc:Ws};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WV=1e3;function hf({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}){const d=n.shape.length,h=e.shape.length,f=t?n.shape[d-2]:n.shape[d-1],m=s?e.shape[h-1]:e.shape[h-2],I=t?n.shape[d-1]:n.shape[d-2],y=s?e.shape[h-2]:e.shape[h-1],N=n.shape.slice(0,-2),w=e.shape.slice(0,-2),T=Te(N),v=Te(w),_=Lt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([I,y]);W(f===m,()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const L=t?[T,f,I]:[T,I,f],P=s?[v,y,m]:[v,m,y],B=et({inputs:{x:n},backend:r,attrs:{shape:L}}),U=et({inputs:{x:e},backend:r,attrs:{shape:P}}),Z=[B,U],Y=Math.max(T,v),ae=t?B.shape[1]:B.shape[2],de=i!=null,ce=o!=null,Ie=u==="leakyrelu",be=u!=null?nd(u,!0):null,ye=de||ce||Ie||be!=null;let we;if((I===1||y===1)&&ae>WV&&ye===!1){let De=B,Pe=U;t&&(De=Ws({inputs:{x:B},backend:r,attrs:{perm:[0,2,1]}}),Z.push(De)),s&&(Pe=Ws({inputs:{x:U},backend:r,attrs:{perm:[0,2,1]}}),Z.push(Pe));const Fe=y!==1,Ue=y===1;let Ge=De;Fe&&(Ge=et({inputs:{x:De},backend:r,attrs:{shape:[Y,ae,1]}}),Z.push(Ge));const Ze=y===1?2:1;let je=Pe;Ue&&(je=et({inputs:{x:Pe},backend:r,attrs:{shape:[Y,1,ae]}}),Z.push(je));const Qe=Dx({inputs:{a:Ge,b:je},backend:r});we=bg({inputs:{x:Qe},backend:r,attrs:{axis:Ze,keepDims:!0}}),Z.push(Qe)}else{const De=dr(n.dtype,e.dtype),Pe=new MV(L,P,[Y,I,y],t,s,de,be,ce,Ie),Fe=[B,U];if(i!=null&&Fe.push(i),ce&&Fe.push(o),Ie){const Ue=r.makeTensorInfo([],"float32",io(l,"float32"));Fe.push(Ue),Z.push(Ue)}we=r.runWebGLProgram(Pe,Fe,De)}const fe=et({inputs:{x:we},backend:r,attrs:{shape:_}});Z.push(we);for(const De of Z)r.disposeIntermediateTensorInfo(De);return fe}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function noe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:l}=e,{transposeA:u,transposeB:d,activation:h,leakyreluAlpha:f}=s;return hf({a:r,b:i,transposeA:u,transposeB:d,backend:t,bias:o,preluActivationWeights:l,leakyreluAlpha:f,activation:h})}const soe={kernelName:zp,backendName:"webgl",kernelFunc:noe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nD="return abs(x);";function roe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),o=CV(i.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let r;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new za(s.shape,nD):r=new Fi(s.shape,nD),t.runWebGLProgram(r,[s],s.dtype)}const ioe={kernelName:_f,backendName:"webgl",kernelFunc:roe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aoe=ni+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,ooe=Qt({opSnippet:aoe}),loe={kernelName:dd,backendName:"webgl",kernelFunc:ooe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uoe=ni+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,coe=Qt({opSnippet:uoe}),doe={kernelName:hd,backendName:"webgl",kernelFunc:coe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sD="return a + b;",hoe=ws({opSnippet:sD,packedOpSnippet:sD,supportsComplex:!0,cpuKernelImpl:wie}),poe={kernelName:Lu,backendName:"webgl",kernelFunc:hoe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class foe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class moe{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vp(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return gr({inputs:{x:s[0]},backend:t});if(s.length>xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),d=vp({inputs:s.slice(0,u),backend:t}),h=vp({inputs:s.slice(u),backend:t});return vp({inputs:[d,h],backend:t})}const r=s.map(u=>u.dtype).reduce((u,d)=>dr(u,d)),i=s.map(u=>u.shape),l=xe().getBool("WEBGL_PACK")?new moe(s[0].shape,i):new foe(s[0].shape,i);return t.runWebGLProgram(l,s,r)}const goe={kernelName:Df,backendName:"webgl",kernelFunc:vp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ioe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=r.shape.length,u=Bt(i,r.shape);let d=u;const h=En(d,l);let f=r;h!=null&&(f=Ws({inputs:{x:r},backend:t,attrs:{perm:h}}),d=zn(d.length,l)),xs("all",d,l);const[m,I]=us(f.shape,d),y=Te(I),N=et({inputs:{x:f},backend:t,attrs:{shape:[-1,y]}}),w=kl(N,N.dtype,"all",t);let T;if(o){const v=Fn(m,u);T=et({inputs:{x:w},backend:t,attrs:{shape:v}})}else T=et({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(w),h!=null&&t.disposeIntermediateTensorInfo(f),T}const yoe={kernelName:xy,backendName:"webgl",kernelFunc:Ioe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function boe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=r.shape.length,u=Bt(i,r.shape);let d=u;const h=En(d,l);let f=r;h!=null&&(f=Ws({inputs:{x:r},backend:t,attrs:{perm:h}}),d=zn(d.length,l)),xs("any",d,l);const[m,I]=us(f.shape,d),y=Te(I),N=et({inputs:{x:f},backend:t,attrs:{shape:[-1,y]}}),w=kl(N,N.dtype,"any",t);let T;if(o){const v=Fn(m,u);T=et({inputs:{x:w},backend:t,attrs:{shape:v}})}else T=et({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(w),h!=null&&t.disposeIntermediateTensorInfo(f),T}const xoe={kernelName:Ny,backendName:"webgl",kernelFunc:boe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Noe{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const l=t==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${l} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class woe{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,W(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const l=this.outputShape,u=l.length,d=dn(u),h=zs("coords",u);let f,m;if(o===1){m=u+1;const U=dn(m);f=`
        ${U} sourceLocR = ${U}(${h.join()}, 0);
        ++${h[u-1]};
        ${U} sourceLocG = ${U}(${h.join()}, 0);
        ++${h[u-2]};
        ${U} sourceLocA = ${U}(${h.join()}, 0);
        --${h[u-1]};
        ${U} sourceLocB = ${U}(${h.join()}, 0);
        --${h[u-2]};`}else m=u,f=`
        ${d} sourceLocR = coords;
        ++${h[u-1]};
        ${d} sourceLocG = coords;
        ++${h[u-2]};
        ${d} sourceLocA = coords;
        --${h[u-1]};
        ${d} sourceLocB = coords;
        --${h[u-2]};`;const I=["x","y","z","w","u","v"].slice(0,m),y="."+I[m-1],N=I.map(U=>"int "+U),w=zs("sourceLocR",m-1).concat("inIdx.r"),T=zs("sourceLocG",m-1).concat("inIdx.g"),v=zs("sourceLocB",m-1).concat("inIdx.b"),E=zs("sourceLocA",m-1).concat("inIdx.a"),_=s==="max"?"greaterThan":"lessThan",L=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${E.join()})));`,P=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${T.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${E.join()}) : 0.)`,B=r?"":`
      float getBestIndicesAChannel(${N.join()}) {
        return getChannel(getBestIndicesA(${I.join()}),
                                          vec2(${I.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${N.join()}) {
        return getChannel(getA(${I.join()}),
                               vec2(${I.slice(-2).join()}));
      }
      ${B}
      void main() {
        ${d} coords = getOutputCoords();
        bool hasNextCol = ${h[u-1]} < ${l[u-1]-1};
        bool hasNextRow = ${h[u-2]} < ${l[u-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},
          sourceLocB${y}, sourceLocA${y}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${P};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${L}
          vec4 candidate = ${P};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${_}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BV(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=tg(i),l={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},u=new Noe(l,t,s==null),d=[e];s!=null&&d.push(s);const h=n.runWebGLProgram(u,d,"int32");if(h.shape[1]===1)return h;const f=BV(n,e,t,h);return n.disposeIntermediateTensorInfo(h),f}function HV(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],o=tg(i),l=new woe(r,o,t,s==null),u=s==null?[e]:[e,s],d=n.runWebGLProgram(l,u,"int32");if(d.shape.length===e.shape.length){const h=HV(n,e,t,d);return n.disposeIntermediateTensorInfo(d),h}return d}function UV(n,e,t,s){const r=[t];if(xs("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!xe().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),l=o!==null&&o.isPacked;let u=e;l&&(u=n.unpackTensor(e),i.push(u));const[d,h]=us(u.shape,r),f=Te(h),m=et({inputs:{x:u},backend:n,attrs:{shape:[-1,f]}});i.push(m);const I=BV(n,m,s);i.push(I);const y=et({inputs:{x:I},backend:n,attrs:{shape:d}});return i.forEach(N=>n.disposeIntermediateTensorInfo(N)),y}return HV(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aoe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=Bt(i,r.shape);const l=En(o,r.shape.length);let u=r;const d=[];l!=null&&(u=Ws({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(u),o=zn(o.length,u.shape.length)),xs("argMax",[o[0]],u.shape.length);const h=UV(t,u,o[0],"max");return d.forEach(f=>t.disposeIntermediateTensorInfo(f)),h}const Toe={kernelName:Ef,backendName:"webgl",kernelFunc:Aoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Soe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=Bt(i,r.shape);const l=En(o,r.shape.length);let u=r;const d=[];l!=null&&(u=Ws({inputs:{x:r},backend:t,attrs:{perm:l}}),d.push(u),o=zn(o.length,u.shape.length)),xs("argMin",[o[0]],u.shape.length);const h=UV(t,u,o[0],"min");return d.forEach(f=>t.disposeIntermediateTensorInfo(f)),h}const voe={kernelName:kf,backendName:"webgl",kernelFunc:Soe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $oe=ni+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,_oe=Qt({opSnippet:$oe}),Doe={kernelName:pd,backendName:"webgl",kernelFunc:_oe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eoe=ni+"return log(x + sqrt(x * x + 1.0));",koe=Qt({opSnippet:Eoe}),Coe={kernelName:fd,backendName:"webgl",kernelFunc:koe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Loe=ni+`
  return atan(x);
`,Ooe=Qt({opSnippet:Loe}),Roe={kernelName:md,backendName:"webgl",kernelFunc:Ooe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Voe=_x+`
  return atan(a, b);
`,Poe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+El+`
  return result;
`,Foe=ws({opSnippet:Voe,packedOpSnippet:Poe}),zoe={kernelName:Id,backendName:"webgl",kernelFunc:Foe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Moe=ni+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Woe=Qt({opSnippet:Moe}),Boe={kernelName:gd,backendName:"webgl",kernelFunc:Woe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sd{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,l=e.strideHeight,u=e.strideWidth,d=e.dilationHeight,h=e.dilationWidth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,I=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const N=t==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,T=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let v="0.0";if(N||(v="-1.0 / 1e-20"),s){const U=">=";this.userCode=`
        const ivec2 strides = ivec2(${l}, ${u});
        const ivec2 pads = ivec2(${I}, ${y});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${U} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?w:T:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / max(count, 1.0)");const L=Math.floor(o/4)*4,P=o%4,B=`
      if (${N}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${I}, ${y});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${d}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${L}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${B}
          }

          int xC = xCCorner + ${L};
          if (${P===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${B}
          } else if (${P===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${B}
          } else if (${P===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${B}
          }
        }
        setOutput(${_});
      }
    `}}class Ex{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,l=e.strideDepth,u=e.strideHeight,d=e.strideWidth,h=e.dilationDepth,f=e.dilationHeight,m=e.dilationWidth,I=e.effectiveFilterDepth,y=e.effectiveFilterHeight,N=e.effectiveFilterWidth,w=e.padInfo.front,T=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;const E=t==="avg";let _="0.0";if(E||(_="-1.0 / 1e-20"),s){const Y=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${l}, ${u}, ${d});
        const ivec3 pads = ivec3(${w}, ${T}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${I};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${y};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${N};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${Y} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${y} * ${N} +
                      wR * ${N} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const L="max";let P=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(P="avgValue / max(count, 1.0)");const B=Math.floor(o/4)*4,U=o%4,Z=`
      if (${E}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${L}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${l}, ${u}, ${d});
      const ivec3 pads = ivec3(${w}, ${T}, ${v});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${I};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${y};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${B}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${Z}
            }

            int xC = xCCorner + ${B};
            if (${U===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${Z}
            } else if (${U===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${Z}
            } else if (${U===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${Z}
            }
          }
        }
        setOutput(${P});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hoe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;$h(r,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=s,d=1;W(bs(o,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const h=ei(r.shape,i,o,d,l,u);if(h.filterWidth===1&&h.filterHeight===1&&Kt(h.inShape,h.outShape))return gr({inputs:{x:r},backend:t});const f=new sd(h,"avg",!1);return t.runWebGLProgram(f,[r],"float32")}const Uoe={kernelName:Cf,backendName:"webgl",kernelFunc:Hoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Goe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:u,dataFormat:d}=s,h=[1,1,1],f=ba(r.shape,i,o,h,l,u,d),m=new Ex(f,"avg",!1);return t.runWebGLProgram(m,[r],"float32")}const qoe={kernelName:Lf,backendName:"webgl",kernelFunc:Goe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Koe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=u-1-e.padInfo.top,f=d-1-e.padInfo.left,m=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${f});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${d};
            wC+= ${l}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class joe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,h=e.dilationWidth,f=e.effectiveFilterDepth,m=e.effectiveFilterHeight,I=e.effectiveFilterWidth,y=f-1-e.padInfo.front,N=m-1-e.padInfo.top,w=I-1-e.padInfo.left,T=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${y}, ${N}, ${w});
      const float avgMultiplier = float(${T});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${d}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${I};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yoe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:l,strides:u,pad:d,dimRoundingMode:h}=s,f=[1,1,1],m=ba(o.shape,l,u,f,d,h),I=new joe(m);return t.runWebGLProgram(I,[r],o.dtype)}const Xoe={kernelName:Ay,backendName:"webgl",kernelFunc:Yoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zoe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;$h([r,i],"avgPoolGrad");const{filterSize:l,strides:u,pad:d}=s,h=ei(o.shape,l,u,1,d),f=new Koe(h);return t.runWebGLProgram(f,[r],o.dtype)}const Qoe={kernelName:wy,backendName:"webgl",kernelFunc:Zoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Joe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:l}=s;return hf({a:r,b:i,transposeA:o,transposeB:l,backend:t})}const ele={kernelName:Of,backendName:"webgl",kernelFunc:Joe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tle{constructor(e,t,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Lt(e,t),Lt(e,s);let l="0.0";r!=null&&(Lt(e,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let u="1.0";i!=null&&(Lt(e,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${l};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nle{constructor(e,t,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Lt(e,t),Lt(e,s);let l="vec4(0.0)";r!=null&&(Lt(e,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let u="vec4(1.0)";i!=null&&(Lt(e,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${l};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sle=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:o,scale:l}=n;W(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),W(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),W(l==null||r.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const d=[s,r,i];let h=null;o!=null&&(h=o.shape,d.push(o));let f=null;l!=null&&(f=l.shape,d.push(l));const m=xe().getBool("WEBGL_PACK_NORMALIZATION")?new nle(s.shape,r.shape,i.shape,h,f,u):new tle(s.shape,r.shape,i.shape,h,f,u);return e.runWebGLProgram(m,d,d[0].dtype)},rle={kernelName:Kf,backendName:"webgl",kernelFunc:sle};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ile{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=dn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=ale(this.rank);let r;const i=e.map((o,l)=>`sourceLoc.${MI[l]} = start[${l}] + coords.${MI[l]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const MI=["x","y","z","w","u","v"];function ale(n){if(n===1)return"sourceLoc";if(n<=6)return MI.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ole{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=dn(this.rank),s=zs("coords",this.rank),r=zs("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,l=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,d=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((h,f)=>`start[${f}]`).join()});`:e.map((h,f)=>`${r[f]} = ${s[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${d}
        vec4 result = vec4(0.);
        ${l}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lle(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let l=Tb(e,wt(n.shape));r.slice&&(l+=r.slice.flatOffset),o.slice={flatOffset:l,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,u+1),i}function Ku(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s,[l,u]=eg(r,i,o);if(Nb(r,l,u),Te(u)===0)return t.makeTensorInfo(u,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const f=t.texData.get(r.dataId),m=eae(f.values,l,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,m)}const{isPacked:d}=t.texData.get(r.dataId),h=Ab(r.shape,l,u);if(d||!h){const f=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ole(u):new ile(u),m=[l];return t.runWebGLProgram(f,[r],r.dtype,m)}return t.uploadToGPU(r.dataId),lle(r,l,u,t)}const ule={kernelName:wm,backendName:"webgl",kernelFunc:Ku};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cle=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;W(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((v,E)=>v*E),u=fh(r.shape,i,l),d=mh(u.length,i.length),h=gh(r.shape,i,l),f=Db(o,i.length),m=Eb(h,o,i.length),I=[],y=et({inputs:{x:r},backend:t,attrs:{shape:u}}),N=Ws({inputs:{x:y},backend:t,attrs:{perm:d}}),w=et({inputs:{x:N},backend:t,attrs:{shape:h}}),T=Ku({inputs:{x:w},backend:t,attrs:{begin:f,size:m}});return I.push(y),I.push(N),I.push(w),I.forEach(v=>t.disposeIntermediateTensorInfo(v)),T},dle={kernelName:Rf,backendName:"webgl",kernelFunc:cle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,l=t.readSync(r.dataId),u=t.readSync(i.dataId),d=kV(l,u,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,d)}const ple={kernelName:Ty,backendName:"webgl",kernelFunc:hle};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fle=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,mle=`
  return float(int(a.r) & int(b.r));
`;function gle(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=xe().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||o===1){const u=t.texData.get(s.dataId).values,d=t.texData.get(r.dataId).values,[h,f]=Tie(s.shape,r.shape,u,d,s.dtype),m=t.makeTensorInfo(f,s.dtype),I=t.texData.get(m.dataId);return I.values=h,m}let l;return i?l=new Gu(fle,s.shape,r.shape,!1):l=new fl(mle,s.shape,r.shape),t.runWebGLProgram(l,[s,r],s.dtype)}const Ile={kernelName:Vf,backendName:"webgl",kernelFunc:gle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yle(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),o=t.readSync(r.dataId),l=Lt(Array.from(i),Array.from(o));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const ble={kernelName:Sy,backendName:"webgl",kernelFunc:yle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xle="return float(a != b);",GV=ws({opSnippet:xle,cpuKernelImpl:Gie,dtype:"bool"}),Nle={kernelName:cm,backendName:"webgl",kernelFunc:GV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dh(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return gr({inputs:{x:r.complexTensorInfos.real},backend:t})}const wle={kernelName:r2,backendName:"webgl",kernelFunc:Dh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ale="return float(int(x));";function Tle(n,e){const t=new Fi(n.shape,Ale),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return gr({inputs:{x:r},backend:t});const o=qn(r.shape),l=WI({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=go({inputs:{real:l,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(l),u}if(r.dtype==="complex64"){const o=Dh({inputs:{input:r},backend:t}),l=WI({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),l}if(!rk(r.dtype,i)){const o=gr({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId).values,[l,u,d]=Sie(o,r.shape,r.dtype,i);return t.makeTensorInfo(l,u,d)}if(i==="int32")return Tle(r,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",Is("bool",1)),u=GV({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const Sle={kernelName:yd,backendName:"webgl",kernelFunc:WI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rD="return ceil(x);",vle=Qt({opSnippet:rD,packedOpSnippet:rD,cpuKernelImpl:vie}),$le={kernelName:bd,backendName:"webgl",kernelFunc:vle};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _le{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dle{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ele(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let l;xe().getBool("WEBGL_PACK_CLIP")?l=new Dle(r.shape):l=new _le(r.shape);const u=[[i],[o]];return t.runWebGLProgram(l,[r],r.dtype,u)}const kle={kernelName:xd,backendName:"webgl",kernelFunc:Ele};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cle{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iD(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Lle(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new Cle(s.shape),o=[iD(s,r.complexTensorInfos.real),iD(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const Ole={kernelName:Pf,backendName:"webgl",kernelFunc:Lle};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rle{constructor(e){this.outputShape=[],this.outputShape=Bi(e,1),this.variableNames=e.map((o,l)=>`T${l}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const l=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${l}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vle{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Bi(e,t);const s=this.outputShape,r=s.length,i=dn(r),o=zs("coords",r),l=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((N,w)=>`T${w}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let N=1;N<u.length;N++)u[N]=u[N-1]+e[N][t];const d=l[t],h=l.slice(-2),f=l.join();let m=`if (${d} < ${u[0]}) {
        return getChannel(
            getT0(${f}), vec2(${h.join()}));
        }`;for(let N=1;N<u.length;N++){const w=u[N-1];m+=`
        if (${d} < ${u[N]}  && ${d} >= ${u[N-1]}) {
          return getChannel(
            getT${N}(${mp(l,d,w)}),
            vec2(${mp(h,d,w)}));
        }`}const I=u.length,y=u[u.length-1];m+=`
        return getChannel(
          getT${I}(${mp(l,d,y)}),
          vec2(${mp(h,d,y)}));`,this.userCode=`
      float getValue(${l.map(N=>"int "+N)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function mp(n,e,t){const s=n.indexOf(e);return n.map((i,o)=>o===s?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xg(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return gr({inputs:{x:r.complexTensorInfos.imag},backend:t})}const Ple={kernelName:Uy,backendName:"webgl",kernelFunc:xg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tc(n,e,t){const s=n[0].dtype;if(s==="complex64"){const I=n.map(v=>Dh({inputs:{input:v},backend:t})),y=n.map(v=>xg({inputs:{input:v},backend:t})),N=Tc(I,e,t),w=Tc(y,e,t),T=go({inputs:{real:N,imag:w},backend:t});return I.forEach(v=>t.disposeIntermediateTensorInfo(v)),y.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(w),T}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const I=n.map(_=>{const P=[-1,Te(_.shape.slice(e))];return et({inputs:{x:_},backend:t,attrs:{shape:P}})}),y=I.map(_=>({vals:t.readSync(_.dataId),shape:_.shape})),N=Bi(I.map(_=>_.shape),1),w=I[0].shape[0]===1,T=$ie(y,N,s,w),v=Bi(n.map(_=>_.shape),e),E=t.makeTensorInfo(v,s,T);return I.forEach(_=>t.disposeIntermediateTensorInfo(_)),E}const i=n.filter(I=>Te(I.shape)>0),o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const I=o?new Fi(n[0].shape,La):new za(n[0].shape,La);return t.runWebGLProgram(I,n,s)}const l=xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>l){const I=[];for(let N=0;N<i.length;N+=l){const w=i.slice(N,N+l);I.push(Tc(w,e,t))}const y=Tc(I,e,t);for(const N of I)t.disposeIntermediateTensorInfo(N);return y}if(o){const I=new Vle(i.map(y=>y.shape),e);return t.runWebGLProgram(I,i,s)}const{tensors2D:u,outShape:d}=Fle(i,e,t),h=new Rle(u.map(I=>I.shape)),f=t.runWebGLProgram(h,u,s);u.forEach(I=>t.disposeIntermediateTensorInfo(I));const m=et({inputs:{x:f},attrs:{shape:d},backend:t});return t.disposeIntermediateTensorInfo(f),m}function Fle(n,e,t){const s=Bi(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>et({inputs:{x:i},attrs:{shape:[-1,Te(i.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qV(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=Bt(r,e[0].shape)[0],o=e.map(d=>d.shape);vb(o,i);const l=Bi(e.map(d=>d.shape),i);if(Te(l)===0)return t.makeTensorInfo(l,e[0].dtype,[]);const u=e.filter(d=>Te(d.shape)>0);return u.length===1?gr({inputs:{x:u[0]},backend:t}):Tc(u,i,t)}const zle={kernelName:Ff,backendName:"webgl",kernelFunc:qV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KV{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,l=e.padInfo.left,u=e.strideHeight,d=e.strideWidth,h=e.dilationHeight,f=e.dilationWidth,m=e.filterHeight,I=e.filterWidth,y=Math.floor(e.inChannels/4)*4,N=e.inChannels%4,w=e.dataFormat==="channelsLast",T=w?1:2,v=w?2:3,E=w?3:1;let _="",L="";s&&(r?_=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?_=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:_=`
          float activation(float x) {
            ${s}
          }
        `,L="result = activation(result);");const P=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${_}

      const ivec2 strides = ivec2(${u}, ${d});
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${E}];

        ivec2 xRCCorner =
            ivec2(coords[${T}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${y}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${N===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${y}) *
                    getW(wR, wC, ${y}, d2);
              } else {
                dotProd +=
                    getX(batch, ${y}, xR, xC) *
                    getW(wR, wC, ${y}, d2);
              }

            } else if (${N===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${N===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2),
                getW(wR, wC, ${y} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1),
                  getX(batch, xR, xC, ${y} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC),
                  getX(batch, ${y} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${P}
        ${L}
        setOutput(result);
      }
    `}}class Mle{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,h=e.dilationWidth,f=e.filterDepth,m=e.filterHeight,I=e.filterWidth,y=Math.floor(e.inChannels/4)*4,N=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${d};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${I}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${y}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${N===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${y}) *
                  getW(wF, wR, wC, ${y}, d2);
              } else if (${N===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${N===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1),
                  getX(batch, xF, xR, xC, ${y} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2),
                  getW(wF, wR, wC, ${y} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jV{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ds(this.outputShape.length);const o=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,f=h;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<h;w++)m+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;m+=`
     for (int r = 0; r < ${d}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<h;w++)m+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(f+1)/2;w++){const T=w*2;if(m+=`
           xC = xCCorner + ${T*u};
           `,l===1){if(T<h&&(o%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                   xTexelC${T} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${T}.zw = vec2(0.0);
                   }
                   xTexelC${T}Ready = 1;
                 }
               `,u===1&&T>0?m+=`
                 xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                   } else {
                     xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                   xTexelC${T} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${T}.zw = vec2(0.0);
                   }
                   xTexelC${T}Ready = 1;
                 }

                 xC${T} = xTexelC${T};
                 `,T+1<h)){const v=o%2===0?Iy(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${v};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                     xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${T+1}.zw = vec2(0.0);
                     }
                     xTexelC${T+1}Ready = 1;
                   }
                   `,u>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                     } else {
                      xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                     }
                     `:m+=`
                     xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                     `):v===1?m+=`
                     xC${T+1} = xTexelC${T};
                     `:m+=`
                     xCOffset = xC + ${v};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                       xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${T+1}.zw = vec2(0.0);
                       }
                       xTexelC${T+1}Ready = 1;
                     }

                     xC${T+1} = xTexelC${T+1};
                     `}}else T<h&&(o%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                   xTexelC${T} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${T}.zw = vec2(0.0);
                   }
                   xTexelC${T}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                   xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${T+1}.zw = vec2(0.0);
                   }
                   xTexelC${T+1}Ready = 1;
                 }

                 xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
               `,T+1<h&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                   xTexelC${T} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${T}.zw = vec2(0.0);
                   }
                   xTexelC${T}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                   xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${T+1}.zw = vec2(0.);
                   }
                   xTexelC${T+1}Ready = 1;
                 }

                 xC${T} = vec4(
                   xTexelC${T}.xy, xTexelC${T+1}.xy);
               `,T+1<h&&(m+=`
                   xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                 `)));T<h&&(m+=`
             wTexel = getW(r, ${T}, d1, d2);
             dotProd += xC${T}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${T}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,T+1<h&&(m+=`
               wTexel = getW(r, ${T+1}, d1, d2);
               dotProd += xC${T+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${T+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let I="",y="";s&&(r?I=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?I=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:I=`vec4 activation(vec4 x) {
           ${s}
         }`,y="result = activation(result);");const N=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${I}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${N}
         ${y}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wle{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ds(this.outputShape.length);const{dataFormat:s}=t,r=Hs(),i=s==="channelsLast",o=i?1:2,l=i?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let d="";for(let h=0;h<=1;h++)for(let f=0;f<=1;f++)d+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${h};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${l}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${d}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pf(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function YV({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=n.shape,d=s.texData.get(n.dataId),h=t.inChannels,f=u[0]*u[1]*u[2],m=t.outChannels,I=t.dataFormat==="channelsLast",y=!1,N=!1;let w;const T=[];if(i!=null){const _=pf(i.shape,I);_!=null&&(i=et({inputs:{x:i},backend:s,attrs:{shape:_}}),T.push(i))}if(r!=null){const _=pf(r.shape,I);_!=null&&(r=et({inputs:{x:r},backend:s,attrs:{shape:_}}),T.push(r))}if(!((f===1||m===1)&&h>WV)&&d.isPacked&&I&&d.texture!=null&&u[2]%2!==0&&Kt(d.shape.slice(-3),u.slice(-3))){const _=u[0]*u[1]*(u[2]+1),L={dataId:n.dataId,shape:[1,_,t.inChannels],dtype:n.dtype},P=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,W(df(d.shape,L.shape),()=>`packed reshape ${d.shape} to ${L.shape} isn't free`);const B=et({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});T.push(B);const U=hf({a:L,b:B,backend:s,transposeA:y,transposeB:N,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),Z=s.texData.get(U.dataId);W(Z.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=P,Z.shape=t.outShape,w=gr({inputs:{x:U},backend:s}),w.shape=t.outShape,T.push(U)}else{const _=t.outHeight*t.outWidth,L=et({inputs:{x:n},backend:s,attrs:{shape:I?[t.batchSize,_,t.inChannels]:[t.batchSize,t.inChannels,_]}}),P=et({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),B=hf({a:I?L:P,b:I?P:L,transposeA:!I,transposeB:N,backend:s,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:o});w=et({inputs:{x:B},backend:s,attrs:{shape:t.outShape}}),T.push(L),T.push(P),T.push(B)}for(const _ of T)s.disposeIntermediateTensorInfo(_);return w}function XV({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:u,filterHeight:d,inChannels:h,outWidth:f,outHeight:m,dataFormat:I}=t,y=I==="channelsLast",N=u*d*h,w=m*f,T=[t.batchSize,N,w],v=!0,E=!1,_=[];if(i!=null){const fe=pf(i.shape,y);fe!=null&&(i=et({inputs:{x:i},backend:s,attrs:{shape:fe}}),_.push(i))}if(r!=null){const fe=pf(r.shape,y);fe!=null&&(r=et({inputs:{x:r},backend:s,attrs:{shape:fe}}),_.push(r))}const L=et({inputs:{x:e},backend:s,attrs:{shape:[1,N,Te(e.shape)/N]}});_.push(L);const P=new Wle(T,t),B=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],U=s.runWebGLProgram(P,[n],"float32",B),Z=et({inputs:{x:U},backend:s,attrs:{shape:T}});_.push(U),_.push(Z);const Y=r!=null,ae=i!=null,de=l==="leakyrelu",ce=l?nd(l,!0):null,Ie=new MV(y?Z.shape:L.shape,y?L.shape:Z.shape,y?[t.batchSize,w,t.outChannels]:[t.batchSize,t.outChannels,w],v,E,Y,ce,ae,de),be=y?[Z,L]:[L,Z];if(r&&be.push(r),ae&&be.push(i),de){const fe=s.makeTensorInfo([],"float32",io(o,"float32"));be.push(fe),_.push(fe)}const ye=s.runWebGLProgram(Ie,be,"float32"),we=et({inputs:{x:ye},backend:s,attrs:{shape:t.outShape}});_.push(ye);for(const fe of _)s.disposeIntermediateTensorInfo(fe);return we}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ble(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}=s,f=xa(u),m=ls(r.shape,i.shape,o,d,l,h,!1,f);let I;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))I=YV({x:r,filter:i,convInfo:m,backend:t});else if(m.strideWidth<=2&&f==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){const N=new jV(m),w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];I=t.runWebGLProgram(N,[r,i],"float32",w)}else if(xe().getBool("WEBGL_CONV_IM2COL"))I=XV({x:r,filter:i,convInfo:m,backend:t});else{const N=new KV(m);I=t.runWebGLProgram(N,[r,i],"float32")}const y=et({inputs:{x:I},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(I),y}const Hle={kernelName:zf,backendName:"webgl",kernelFunc:Ble};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ule{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Gle{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",l=t-1-e.padInfo.top,u=s-1-e.padInfo.left,d=o?1:2,h=o?2:3,f=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${d}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class qle{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,l=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${l};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Kle{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=t-1-e.padInfo.front,d=s-1-e.padInfo.top,h=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${d}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:l,dataFormat:u,dimRoundingMode:d,filterShape:h}=s,f=xa(u),m=ls(r.shape,h,o,1,l,d,!1,f),I=new Ule(m);return t.runWebGLProgram(I,[r,i],"float32")}const Yle={kernelName:$y,backendName:"webgl",kernelFunc:jle};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xle{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Ds(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zle(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:l,pad:u,dataFormat:d,dimRoundingMode:h}=s,f=xa(d),m=ls(o,i.shape,l,1,u,h,!1,f);if(xe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const I=[[m.strideHeight,m.strideWidth]],y=new Xle(m);return t.runWebGLProgram(y,[r,i],"float32",I)}else{const I=new Gle(m);return t.runWebGLProgram(I,[r,i],"float32")}}const Qle={kernelName:Mf,backendName:"webgl",kernelFunc:Zle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jle(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:u}=s,d=lo(r.shape,i.shape,o,u,l),h=new Mle(d);return t.runWebGLProgram(h,[r,i],"float32")}const eue={kernelName:Wf,backendName:"webgl",kernelFunc:Jle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:l,filterShape:u}=s,d=lo(r.shape,u,o,1,l),h=new qle(d);return t.runWebGLProgram(h,[r,i],"float32")}const nue={kernelName:_y,backendName:"webgl",kernelFunc:tue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sue(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:l,inputShape:u}=s,d=lo(u,i.shape,l,1,o),h=new Kle(d);return t.runWebGLProgram(h,[r,i],"float32")}const rue={kernelName:Dy,backendName:"webgl",kernelFunc:sue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iue=qu+`
  return cos(x);
`,aue=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${El}
  return result;
`,oue=Qt({opSnippet:iue,packedOpSnippet:aue}),lue={kernelName:Nd,backendName:"webgl",kernelFunc:oue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uue=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,cue=Qt({opSnippet:uue}),due={kernelName:wd,backendName:"webgl",kernelFunc:cue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hue{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,l,u,d]=e,[h]=t,[f,m]=s;this.outputShape=[h,f,m,d];const I=r==="bilinear"?1:0,[y,N]=[`${l-1}.0`,`${u-1}.0`],[w,T,v]=f>1?[`${(l-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[E,_,L]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${N} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${N}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${E});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${T};
        float width_scale = ${_};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${y} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${L};
        if( in_x < 0.0 || in_x > ${N} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${I} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pue=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:l,method:u,extrapolationValue:d}=s,h=new hue(r.shape,i.shape,l,u,d);return t.runWebGLProgram(h,[r,i,o],"float32")},fue={kernelName:ky,backendName:"webgl",kernelFunc:pue};var rd;(function(n){n.Prod="*",n.Sum="+"})(rd||(rd={}));class aD{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===rd.Prod?"1.0":"0.0",l=s?o:`getX(${oD(i,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let d="",h="";s?(d=r?`end != ${u-1}`:"end != 0",h=r?"end + 1":"end - 1"):(d=r?`end + pow2 < ${u}`:"end >= pow2",h=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${dn(i)} coords = getOutputCoords();
        int end = ${lD(i,"coords",this.op)};
        float val = ${l};
        int pow2 = int(pow(2.0, index));
        if (${d}) {
          int idx = ${h};
          ${lD(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${oD(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function oD(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function lD(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZV(n,e,t,s,r,i){const o=e.shape.length,l=En([s],o);let u=e;l!=null&&(u=Ws({inputs:{x:e},backend:t,attrs:{perm:l}}));const d=zn(1,o)[0];if(d!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const h=u.shape[d];let f=gr({inputs:{x:u},backend:t});for(let m=0;m<=Math.ceil(Math.log2(h))-1;m++){const I=new aD(n,u.shape,!1,i),y=[[m]],N=f;f=t.runWebGLProgram(I,[f],f.dtype,y),t.disposeIntermediateTensorInfo(N)}if(r){const m=new aD(n,u.shape,r,i),I=f;f=t.runWebGLProgram(m,[f],f.dtype),t.disposeIntermediateTensorInfo(I)}if(l!=null){const m=uo(l),I=Ws({inputs:{x:f},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(u),I}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:l}=s;return ZV(rd.Prod,r,t,i,o,l)}const gue={kernelName:Ey,backendName:"webgl",kernelFunc:mue};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:l}=s;return ZV(rd.Sum,r,t,i,o,l)}const yue={kernelName:Bf,backendName:"webgl",kernelFunc:Iue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:l}=s;if(r.shape.length===1){const u=t.readSync(r.dataId),d=t.readSync(i.dataId),h=kV(u,d,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,h)}else if(r.shape.length===2){const u=t.bufferSync(r),d=t.bufferSync(i),h=Aie(u,d,o,l);return t.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const xue={kernelName:Cy,backendName:"webgl",kernelFunc:bue};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nue{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s,l=r.shape[0],u=o==="NHWC"?r.shape[1]:r.shape[2],d=o==="NHWC"?r.shape[2]:r.shape[3],h=o==="NHWC"?r.shape[3]:r.shape[1],f=u*i,m=d*i,I=h/(i*i),y=o==="NHWC"?[l,f,m,I]:[l,I,f,m],N=new Nue(y,i,o);return t.runWebGLProgram(N,[r],r.dtype)}const Aue={kernelName:Ly,backendName:"webgl",kernelFunc:wue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QV{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ds(this.outputShape.length);const o=e.filterHeight,l=e.filterWidth,u=e.outChannels/e.inChannels;let d="",h="";s&&(r?d=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?d=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:d=`
          float activation(float x) {
            ${s}
          }
        `,h="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${l}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JV{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ds(this.outputShape.length);const o=e.outChannels/e.inChannels,l=e.padInfo.left,u=e.strideWidth,d=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,m=f;let I=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let T=0;T<f;T++)I+=`
          vec4 xTexelC${T*2};
          int xTexelC${T*2}Ready;
          vec4 xTexelC${T*2+1};
          int xTexelC${T*2+1}Ready;
          vec4 xC${T};`;I+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let T=0;T<f;T++)I+=`
          xTexelC${T*2} = vec4(0.0);
          xTexelC${T*2}Ready = 0;
          xTexelC${T*2+1} = vec4(0.0);
          xTexelC${T*2+1}Ready = 0;
          xC${T} = vec4(0.0);`;I+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let T=0;T<(m+1)/2;T++){const v=T*2;if(I+=`
          xC = xCCorner + ${v*d};
          `,u===1){if(v<f&&(l%2===1?(I+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,d===1&&v>0?I+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:I+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):I+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<f)){const E=l%2===0?Iy(d):d;d%2===0&&l%2===1||d%2!==0&&l%2!==1?(I+=`
                  xCOffset = xC + imod(pads[1], 2) + ${E};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,d>1?I+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                    } else {
                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                    }
                    `:I+=`
                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                    `):E===1?I+=`
                    xC${v+1} = xTexelC${v};
                    `:I+=`
                    xCOffset = xC + ${E};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<f&&(l%2===1?(I+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<f&&(I+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(I+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<f&&(I+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<f&&(I+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<f&&(I+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}I+=`
    }
  `,I+=`
      }
    `;let y="",N="";s&&(r?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:y=`vec4 activation(vec4 x) {
          ${s}
        }`,N="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${I}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${N}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:u,dimRoundingMode:d}=s;let h=u;h==null&&(h=[1,1]),W(bs(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const f=ls(r.shape,i.shape,o,h,l,d,!0);let m;xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?m=new JV(f):m=new QV(f);const I=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return t.runWebGLProgram(m,[r,i],"float32",I)}const Sue={kernelName:Hf,backendName:"webgl",kernelFunc:Tue};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vue{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $ue{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,l=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:l,pad:u,dimRoundingMode:d,filterShape:h}=s,f=ls(r.shape,h,o,l,u,d,!0),m=new vue(f);return t.runWebGLProgram(m,[r,i],"float32")}const Due={kernelName:Oy,backendName:"webgl",kernelFunc:_ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eue(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:l,pad:u,dimRoundingMode:d,inputShape:h}=s,f=ls(h,i.shape,o,l,u,d,!0),m=new $ue(f);return t.runWebGLProgram(m,[r,i],"float32")}const kue={kernelName:Ry,backendName:"webgl",kernelFunc:Eue};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cue{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lue(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=Te(s.shape),o=et({inputs:{x:s},backend:t,attrs:{shape:[i]}}),l=new Cue(i),u=t.runWebGLProgram(l,[o],o.dtype),d=et({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),d}const Oue={kernelName:Vy,backendName:"webgl",kernelFunc:Lue};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rue{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:l,filterWidth:u,dilationHeight:d,dilationWidth:h}=e,{top:f,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${f}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${l}; h++) {
          int hIn = hBeg + h * ${d};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:l,dilations:u}=s,d=oh(r.shape,i.shape,o,l,"NHWC",u);let h;const f=new Rue(d);h=t.runWebGLProgram(f,[r,i],"float32");const m=et({inputs:{x:h},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(h),m}const Pue={kernelName:Uf,backendName:"webgl",kernelFunc:Vue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fue(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:l,idDims:u}=Fb(r,i.length);Mb(o.length,u,i);const{path:d,steps:h}=Wb(l,u),f=h.length;let m=null,I=o.length;const y=[];for(let N=0;N<f;++N){for(const w of h[N]){const{permutationIndices:T,expandDims:v}=zb(I,u[w]);let E;Bb(T)?E=i[w]:(E=Ws({inputs:{x:i[w]},backend:t,attrs:{perm:T}}),y.push(E));const _=E.shape.slice();for(let L=0;L<v.length;++L)_.splice(v[L],0,1);Kt(E.shape,_)||(E=et({inputs:{x:E},backend:t,attrs:{shape:_}}),y.push(E)),m===null?m=E:(m=Dx({inputs:{a:E,b:m},backend:t}),y.push(m))}N<f-1&&(d[N]>=0&&(m=bg({inputs:{x:m},backend:t,attrs:{axis:d[N]-(o.length-I),keepDims:!1}}),y.push(m)),I--)}for(const N of y)N!==m&&t.disposeIntermediateTensorInfo(N);return m}const zue={kernelName:Py,backendName:"webgl",kernelFunc:Fue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mue="return (x >= 0.0) ? x : (exp(x) - 1.0);",Wue=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Bue=Qt({opSnippet:Mue,packedOpSnippet:Wue}),Hue={kernelName:Td,backendName:"webgl",kernelFunc:Bue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uue="return (b >= 0.0) ? a : a * (b + 1.0);",Gue=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,que=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Gu(Gue,s.shape,r.shape):new fl(Uue,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},Kue={kernelName:Fy,backendName:"webgl",kernelFunc:que};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jue=`
  return vec4(equal(a, b));
`,Yue="return float(a == b);",Xue=ws({opSnippet:Yue,packedOpSnippet:jue,dtype:"bool",cpuKernelImpl:_ie}),Zue={kernelName:Gf,backendName:"webgl",kernelFunc:Xue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Que=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${kb};
  float a1 = ${Cb};
  float a2 = ${Lb};
  float a3 = ${Ob};
  float a4 = ${Rb};
  float a5 = ${Vb};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Jue=Qt({opSnippet:Que}),ece={kernelName:Sd,backendName:"webgl",kernelFunc:Jue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tce=qu+`
  return exp(x);
`,nce=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,e5=Qt({opSnippet:tce,packedOpSnippet:nce,cpuKernelImpl:Die,dtype:"float32"}),sce={kernelName:vd,backendName:"webgl",kernelFunc:e5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,o=i.shape.length,l=i.shape.slice();let u=r;return r<0&&(W(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+r+1),l.splice(u,0,1),et({inputs:{x:i},backend:s,attrs:{shape:l}})}const rce={kernelName:qf,backendName:"webgl",kernelFunc:BI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uD="return exp(x) - 1.0;",ice=Qt({opSnippet:uD,packedOpSnippet:uD,cpuKernelImpl:Eie}),ace={kernelName:$d,backendName:"webgl",kernelFunc:ice};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cD{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let l;if(e==="real")l="return real * expR - imag * expI;";else if(e==="imag")l="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${l}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t5(n,e,t){const s=t.texData.get(n.dataId),r=Te(n.shape),i=n.shape[n.shape.length-1],o=r/i,l=et({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),u=l.shape,d=new cD("real",u,e),h=new cD("imag",u,e),f=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],m=t.runWebGLProgram(d,f,"float32"),I=t.runWebGLProgram(h,f,"float32"),y=go({inputs:{real:m,imag:I},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(I);const N=et({inputs:{x:y},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(y),N}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oce(n){const{inputs:e,backend:t}=n,{input:s}=e;return t5(s,!1,t)}const lce={kernelName:zy,backendName:"webgl",kernelFunc:oce};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uce{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eh(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||ku(r),i==="string"){const o=Pn(i,Te(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new uce(s,r),l=[[r]];return e.runWebGLProgram(o,[],i,l)}}const cce={kernelName:My,backendName:"webgl",kernelFunc:Eh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dce{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hce={kernelName:Wy,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new dce(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dD="return floor(x);",pce=Qt({opSnippet:dD,packedOpSnippet:dD,cpuKernelImpl:kie}),fce={kernelName:_d,backendName:"webgl",kernelFunc:pce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mce=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,gce=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Ice=ws({opSnippet:mce,packedOpSnippet:gce,dtype:"int32"}),yce={kernelName:Dd,backendName:"webgl",kernelFunc:Ice};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bce{constructor(e){this.variableNames=["A"];const t=Hs(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xce{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Hs(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nce={kernelName:bM,backendName:"webgl",kernelFunc:wce};let Hl,$1=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function wce(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,d]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],h=[d,u],f=[d,u,i];if(l||o){const N=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Hl==null||N!==$1)&&($1=N,Hl=document.createElement("canvas").getContext("2d",{willReadFrequently:$1})),Hl.canvas.width=u,Hl.canvas.height=d,Hl.drawImage(r,0,0,u,d),r=Hl.canvas}const m=t.makeTensorInfo(h,"int32");t.texData.get(m.dataId).usage=_r.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),r);const I=xe().getBool("WEBGL_PACK")?new xce(f):new bce(f),y=t.runWebGLProgram(I,[m],"int32");return t.disposeData(m.dataId),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ace(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=e,{strides:u,pad:d,dataFormat:h,dilations:f,dimRoundingMode:m,activation:I,leakyreluAlpha:y}=s,N=xa(h),w=ls(r.shape,i.shape,u,f,d,m,!1,N);let T;const v=[],E=o!=null,_=l!=null,L=I==="leakyrelu",P=()=>{const U=[r,i],Z=(Y,ae)=>{if(ae==="NCHW"&&Y.shape.length===1&&Y.shape[0]!==1){const de=et({inputs:{x:Y},backend:t,attrs:{shape:[Y.shape[0],1,1]}});return v.push(de),de}return Y};if(E&&U.push(Z(o,h)),_&&U.push(Z(l,h)),L){const Y=t.makeTensorInfo([],"float32",io(y,"float32"));U.push(Y),v.push(Y)}return U};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))T=YV({x:r,filter:i,convInfo:w,backend:t,bias:o,activation:I,preluActivationWeights:l,leakyreluAlpha:y});else if(w.strideWidth<=2&&N==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){const U=I?nd(I,!0):null,Z=new jV(w,E,U,_,L),Y=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],ae=P();T=t.runWebGLProgram(Z,ae,"float32",Y)}else if(xe().getBool("WEBGL_CONV_IM2COL"))T=XV({x:r,filter:i,convInfo:w,backend:t,bias:o,activation:I,preluActivationWeights:l,leakyreluAlpha:y});else{const U=I?nd(I,!1):null,Z=new KV(w,E,U,_,L),Y=P();T=t.runWebGLProgram(Z,Y,"float32")}const B=et({inputs:{x:T},backend:t,attrs:{shape:w.outShape}});return v.push(T),v.forEach(U=>t.disposeIntermediateTensorInfo(U)),B}const Tce={kernelName:Mp,backendName:"webgl",kernelFunc:Ace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=e,{strides:u,pad:d,dilations:h,dimRoundingMode:f,activation:m,leakyreluAlpha:I}=s,y=[];let N=h;N==null&&(N=[1,1]),W(bs(u,N),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${N}'`);const w=ls(r.shape,i.shape,u,N,d,f,!0),T=xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,v=m?nd(m,T):null,E=[r,i],_=o!=null,L=l!=null,P=m==="leakyrelu";if(_&&E.push(o),L&&E.push(l),P){const Y=t.makeTensorInfo([],"float32",io(I,"float32"));E.push(Y),y.push(Y)}let B;T?B=new JV(w,_,v,L,P):B=new QV(w,_,v,L,P);const U=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],Z=t.runWebGLProgram(B,E,"float32",U);return y.forEach(Y=>t.disposeIntermediateTensorInfo(Y)),Z}const vce={kernelName:Wp,backendName:"webgl",kernelFunc:Sce};class $ce{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=dn(s.length);let o=`
    int index;`;for(let l=0;l<this.sliceDim;l++)o+=`
          index = round(getIndices(coords[0], ${l}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[l]};
          flattenIndex += index * ${this.strides[l]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ce(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],l=Te(s.shape),[u,d,h,f]=xb(s,r),m=et({inputs:{x:r},backend:t,attrs:{shape:[d,o]}}),I=et({inputs:{x:s},backend:t,attrs:{shape:[Te(s.shape)/h,h]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const T=t.readSync(r.dataId),v=t.bufferSync(s),E=Cie(T,v,s.dtype,d,o,h,f,s.shape,l);return t.makeTensorInfo(u,s.dtype,E.values)}const y=new $ce(o,f,[d,h],s.shape),N=t.runWebGLProgram(y,[I,m],I.dtype),w=et({inputs:{x:N},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(N),w}const Dce={kernelName:By,backendName:"webgl",kernelFunc:_ce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ece{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=dn(this.rank),r=kce(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function kce(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:l}=s,u=Bt(o,r.shape)[0];if(xe().get("DEBUG")){const v=t.readSync(i.dataId),E=r.shape[u];for(let _=0;_<v.length;++_){const L=v[_];W(L<=E-1&&L>=0,()=>`GatherV2: the index value ${L} is not in [0, ${E-1}]`)}}const d=Ub(r,i,u,l),h=Te(i.shape),f=[],m=et({inputs:{x:r},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),I=et({inputs:{x:i},backend:t,attrs:{shape:[d.batchSize,h/d.batchSize]}});f.push(m),f.push(I);const y=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const v=t.bufferSync(I),E=t.bufferSync(m),_=Lie(E,v,y);return f.forEach(L=>t.disposeIntermediateTensorInfo(L)),t.makeTensorInfo(d.outputShape,_.dtype,_.values)}const N=new Ece(m.shape,y),w=t.runWebGLProgram(N,[m,I],m.dtype);f.push(w);const T=et({inputs:{x:w},backend:t,attrs:{shape:d.outputShape}});return f.forEach(v=>t.disposeIntermediateTensorInfo(v)),T}const Cce={kernelName:jf,backendName:"webgl",kernelFunc:n5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lce="return float(a > b);",Oce=`
  return vec4(greaterThan(a, b));
`,Rce=ws({opSnippet:Lce,packedOpSnippet:Oce,cpuKernelImpl:Oie,dtype:"bool"}),Vce={kernelName:Yf,backendName:"webgl",kernelFunc:Rce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pce="return float(a >= b);",Fce=`
  return vec4(greaterThanEqual(a, b));
`,zce=ws({opSnippet:Pce,packedOpSnippet:Fce,dtype:"bool",cpuKernelImpl:Rie}),Mce={kernelName:Ed,backendName:"webgl",kernelFunc:zce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wce(n){const{inputs:e,backend:t}=n,{input:s}=e;return t5(s,!0,t)}const Bce={kernelName:Hy,backendName:"webgl",kernelFunc:Wce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hce="return float(!isnan(x) && !isinf(x));",Uce=Qt({opSnippet:Hce,dtype:"bool"}),Gce={kernelName:Cd,backendName:"webgl",kernelFunc:Uce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qce="return float(isinf(x));",Kce=Qt({opSnippet:qce,dtype:"bool"}),jce={kernelName:Ld,backendName:"webgl",kernelFunc:Kce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yce="return float(isnan(x));",Xce=Qt({opSnippet:Yce,dtype:"bool"}),Zce={kernelName:Od,backendName:"webgl",kernelFunc:Xce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qce="return float(a < b);",Jce=`
  return vec4(lessThan(a, b));
`,ede=ws({opSnippet:Qce,packedOpSnippet:Jce,cpuKernelImpl:Vie,dtype:"bool"}),tde={kernelName:Zf,backendName:"webgl",kernelFunc:ede};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nde="return float(a <= b);",sde=`
  return vec4(lessThanEqual(a, b));
`,rde=ws({opSnippet:nde,packedOpSnippet:sde,cpuKernelImpl:Pie,dtype:"bool"}),ide={kernelName:Qf,backendName:"webgl",kernelFunc:rde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ade(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=Fie(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const ode={kernelName:Gy,backendName:"webgl",kernelFunc:ade};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lde=qu+`
  return x < 0.0 ? 0./0. : log(x);
`,ude=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cde=Qt({opSnippet:lde,packedOpSnippet:ude,cpuKernelImpl:zie}),dde={kernelName:Rd,backendName:"webgl",kernelFunc:cde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hde=qu+`
  return log(1.0 + x);
`,pde=Qt({opSnippet:hde}),fde={kernelName:Vd,backendName:"webgl",kernelFunc:pde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mde="return float(a >= 1.0 && b >= 1.0);",gde=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Ide=ws({opSnippet:mde,packedOpSnippet:gde,dtype:"bool"}),yde={kernelName:Jf,backendName:"webgl",kernelFunc:Ide};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bde="return float(!(x >= 1.0));",xde=Qt({opSnippet:bde}),Nde={kernelName:em,backendName:"webgl",kernelFunc:xde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wde="return float(a >= 1.0 || b >= 1.0);",Ade=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Tde=ws({opSnippet:wde,packedOpSnippet:Ade,dtype:"bool"}),Sde={kernelName:tm,backendName:"webgl",kernelFunc:Tde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vde{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=t,l=e[3]-1;this.outputShape=e;let u;const d=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${d})`:i===1?u=`1.0/(${d})`:u=`exp(log(${d}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${l}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $de{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,l=e[3]-1;this.outputShape=e;let u;const d=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${d})`:i===1?u=`1.0/(${d})`:u=`exp(log(${d}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _de=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:l,beta:u}=s,d=xe().getBool("WEBGL_PACK_NORMALIZATION")?new $de(r.shape,i,o,l,u):new vde(r.shape,i,o,l,u);return t.runWebGLProgram(d,[r],r.dtype)},Dde={kernelName:nm,backendName:"webgl",kernelFunc:_de};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ede{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kde=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:l,bias:u,alpha:d,beta:h}=s,f=new Ede(r.shape,l,u,d,h);return t.runWebGLProgram(f,[r,i,o],r.dtype)},Cde={kernelName:qy,backendName:"webgl",kernelFunc:kde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lde(n,e,t,s){const r=Te(e),o=Te(n.shape)/r,l=et({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),u=kl(l,n.dtype,"max",s),d=et({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(u),d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,l=r.shape.length,u=Bt(i,r.shape);let d=u;const h=En(d,l),f=h!=null,m=t.shouldExecuteOnCPU([r]);let I=r;if(f){if(m){const E=t.texData.get(I.dataId).values,_=new Array(l);for(let B=0;B<_.length;B++)_[B]=r.shape[h[B]];const L=$x(E,r.shape,r.dtype,h,_);I=t.makeTensorInfo(_,r.dtype);const P=t.texData.get(I.dataId);P.values=L}else I=yg(r,h,t);d=zn(d.length,l)}xs("max",d,l);const[y,N]=us(I.shape,d);let w=y;o&&(w=Fn(y,u));let T;if(m){const E=t.texData.get(I.dataId).values,_=Mie(E,Te(N),w,r.dtype);T=t.makeTensorInfo(w,r.dtype);const L=t.texData.get(T.dataId);L.values=_}else T=Lde(I,N,w,t);return f&&t.disposeIntermediateTensorInfo(I),T}const Ode={kernelName:sm,backendName:"webgl",kernelFunc:s5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rde=_x+`
  return max(a, b);
`,Vde=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+El+`
  return result;
`,Pde=ws({opSnippet:Rde,packedOpSnippet:Vde,cpuKernelImpl:Wie}),Fde={kernelName:Pd,backendName:"webgl",kernelFunc:Pde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;$h(r,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=s,d=1;W(bs(o,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const h=ei(r.shape,i,o,d,l,u);if(h.filterWidth===1&&h.filterHeight===1&&Kt(h.inShape,h.outShape))return gr({inputs:{x:r},backend:t});const f=new sd(h,"max",!1);return t.runWebGLProgram(f,[r],r.dtype)}const Mde={kernelName:rm,backendName:"webgl",kernelFunc:zde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:d}=s,h=[1,1,1],f=ba(r.shape,i,o,h,l,d,u),m=new Ex(f,"max",!1);return t.runWebGLProgram(m,[r],r.dtype)}const Bde={kernelName:im,backendName:"webgl",kernelFunc:Wde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hde{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,l=i-1-e.padInfo.top,u=o-1-e.padInfo.left,d=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${d} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Ude{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=u-1-e.padInfo.front,m=d-1-e.padInfo.top,I=h-1-e.padInfo.left,y=u*d*h-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${I});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${y} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${d} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:l,strides:u,pad:d,dimRoundingMode:h}=s,f=[1,1,1],m=ba(o.shape,l,u,f,d,h),I=new Ex(m,"max",!0),y=t.runWebGLProgram(I,[o],o.dtype),N=new Ude(m),w=t.runWebGLProgram(N,[r,y],o.dtype);return t.disposeIntermediateTensorInfo(y),w}const qde={kernelName:jy,backendName:"webgl",kernelFunc:Gde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,l=i;$h([i,o],"maxPoolGrad");const{filterSize:u,strides:d,pad:h,dimRoundingMode:f}=s,m=ei(l.shape,u,d,1,h,f),I=!0,y=new sd(m,"max",I),N=t.runWebGLProgram(y,[l],l.dtype),w=new Hde(m),T=t.runWebGLProgram(w,[r,N],l.dtype);return t.disposeIntermediateTensorInfo(N),T}const jde={kernelName:Ky,backendName:"webgl",kernelFunc:Kde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yde(n,e,t,s){let r=new sd(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new sd(t,"max",!0,!0,e);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xde={kernelName:Yy,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:l}=e,u=t;W(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const d=[1,1];W(bs(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const h=ei(s.shape,r,i,d,o),[f,m]=Yde(s,l,h,u);return[f,m]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zde(n,e,t,s){const r=Te(e),o=Te(n.shape)/r,l=et({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),u=kl(l,"float32","mean",s),d=et({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(u),d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qde={kernelName:am,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,o=t,l=s.shape.length,u=Bt(i,s.shape);let d=u;const h=En(d,l),f=h!=null,m=o.shouldExecuteOnCPU([s]),I=[];let y=s;if(f){if(m){const _=o.texData.get(y.dataId).values,L=new Array(l);for(let U=0;U<L.length;U++)L[U]=s.shape[h[U]];const P=$x(_,s.shape,s.dtype,h,L);y=o.makeTensorInfo(L,s.dtype);const B=o.texData.get(y.dataId);B.values=P}else y=yg(s,h,o);I.push(y),d=zn(d.length,l)}xs("sum",d,l);const[N,w]=us(y.shape,d);let T=N;r&&(T=Fn(N,u));const v=Zde(y,w,T,o);for(const E of I)o.disposeIntermediateTensorInfo(E);return v}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=r.shape.length,u=Bt(i,r.shape);let d=u;const h=En(d,l);let f=r;h!=null&&(f=Ws({inputs:{x:r},backend:t,attrs:{perm:h}}),d=zn(d.length,r.shape.length)),xs("min",d,l);const[m,I]=us(f.shape,d),y=Te(I),N=et({inputs:{x:f},backend:t,attrs:{shape:[-1,y]}}),w=kl(N,N.dtype,"min",t);let T;if(o){const v=Fn(m,u);T=et({inputs:{x:w},backend:t,attrs:{shape:v}})}else T=et({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(w),h!=null&&t.disposeIntermediateTensorInfo(f),T}const ehe={kernelName:om,backendName:"webgl",kernelFunc:Jde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const the=_x+`
  return min(a, b);
`,nhe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+El+`
  return result;
`,she=ws({opSnippet:the,packedOpSnippet:nhe,cpuKernelImpl:Bie}),rhe={kernelName:Fd,backendName:"webgl",kernelFunc:she};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ihe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((h,f)=>h[0]+e[f]+h[1]);const r=e.length,i=dn(r),o=t.map(h=>h[0]).join(","),l=t.map((h,f)=>h[0]+e[f]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),d=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${d};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${d};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${d};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${d};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ahe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((y,N)=>y[0]+e[N]+y[1]);const r=e.length,i=dn(r),o=t.map(y=>y[0]).join(","),l=t.map((y,N)=>y[0]+e[N]).join(","),u=zs("rc",r),d=zs("source",r),h=`${u[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${d.slice(-2).join()})`,m=s==="reflect"?0:1;let I="";if(r===1){const y=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;I=`
        ${i} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${d.join()}), ${f});
        ${u[r-1]} += 1;
        if(${h}) {
          ${y}
          result[1] = getChannel(getX(${d.join()}), ${f});
        }
      `}else{const y=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;I=`
        ${i} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${d.join()}), ${f});
        ${u[r-1]} += 1;
        if(${h}) {
          ${y}
          result[1] = getChannel(getX(${d.join()}), ${f});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${y}
          result[2] = getChannel(getX(${d.join()}), ${f});
          ${u[r-1]} += 1;
          if(${h}) {
            ${y}
            result[3] = getChannel(getX(${d.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${I}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ohe=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ahe(s.shape,r,i):new ihe(s.shape,r,i);return e.runWebGLProgram(o,[s],s.dtype)},lhe={kernelName:lm,backendName:"webgl",kernelFunc:ohe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uhe=`if (b == 0.0) return NAN;
  return mod(a, b);`,che=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+El+`
  return result;
`,dhe=ws({opSnippet:uhe,packedOpSnippet:che}),hhe={kernelName:zd,backendName:"webgl",kernelFunc:dhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class phe{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fhe=`
if (a == b) {
  return 1.0;
};
return a / b;`,mhe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,r5=ws({opSnippet:fhe,packedOpSnippet:mhe,checkOutOfBounds:!0}),ghe={kernelName:Ad,backendName:"webgl",kernelFunc:r5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hD="return a - b;",i5=ws({opSnippet:hD,packedOpSnippet:hD,supportsComplex:!0,cpuKernelImpl:uae}),Ihe={kernelName:th,backendName:"webgl",kernelFunc:i5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a5(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=Bt([i],r.shape),l=s5({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),u=Fn(l.shape,o),d=et({inputs:{x:l},backend:t,attrs:{shape:u}}),h=i5({inputs:{a:r,b:d},backend:t}),f=e5({inputs:{x:h},backend:t}),m=bg({inputs:{x:f},backend:t,attrs:{axis:o,keepDims:!1}}),I=et({inputs:{x:m},backend:t,attrs:{shape:u}}),y=r5({inputs:{a:f,b:I},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(I),y}const yhe={kernelName:vm,backendName:"webgl",kernelFunc:a5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bhe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:l}=s,u=l?r:a5({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),d=u.shape[0],h=u.shape[1],f=new phe(d,h,i),m=[[o]],I=t.runWebGLProgram(f,[u],"int32",m);return l||t.disposeIntermediateTensorInfo(u),I}const xhe={kernelName:Xy,backendName:"webgl",kernelFunc:bhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nhe=ni+`
  return -x;
`,whe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Ahe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[o,l]=Uie(i.values,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,o)}let r;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new za(s.shape,whe):r=new Fi(s.shape,Nhe),t.runWebGLProgram(r,[s],s.dtype)}const The={kernelName:um,backendName:"webgl",kernelFunc:Ahe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const She=pb;function vhe(n){vr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=s,d=t.readSync(r.dataId),h=t.readSync(i.dataId),{selectedIndices:f}=She(d,h,o,l,u);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const $he={kernelName:Zy,backendName:"webgl",kernelFunc:vhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _he=fb;function Dhe(n){vr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u,padToMaxOutputSize:d}=s,h=t.readSync(r.dataId),f=t.readSync(i.dataId),{selectedIndices:m,validOutputs:I}=_he(h,f,o,l,u,d);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([I]))]}const Ehe={kernelName:Qy,backendName:"webgl",kernelFunc:Dhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const khe=mb;function Che(n){vr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:d}=s,h=t.readSync(r.dataId),f=t.readSync(i.dataId),m=o,I=l,y=u,N=d,{selectedIndices:w,selectedScores:T}=khe(h,f,m,I,y,N);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([T.length],"float32",new Float32Array(T))]}const Lhe={kernelName:Jy,backendName:"webgl",kernelFunc:Che};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ohe{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rhe=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:l,offValue:u}=s,d=Te(r.shape),h=new Ohe(d,o,l,u),f=et({inputs:{x:r},backend:t,attrs:{shape:[d]}}),m=t.runWebGLProgram(h,[f],i);t.disposeIntermediateTensorInfo(f);const I=[...r.shape,o],y=et({inputs:{x:m},backend:t,attrs:{shape:I}});return t.disposeIntermediateTensorInfo(m),y},Vhe={kernelName:hm,backendName:"webgl",kernelFunc:Rhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ff(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Dh({inputs:{input:s},backend:t}),i=ff({inputs:{x:r},backend:t}),o=xg({inputs:{input:s},backend:t}),l=ff({inputs:{x:o},backend:t}),u=go({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}else return Eh({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const Phe={kernelName:Em,backendName:"webgl",kernelFunc:ff};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Dh({inputs:{input:s},backend:t}),i=o5({inputs:{x:r},backend:t}),o=xg({inputs:{input:s},backend:t}),l=ff({inputs:{x:o},backend:t}),u=go({inputs:{real:i,imag:l},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}else return Eh({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const Fhe={kernelName:dm,backendName:"webgl",kernelFunc:o5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zhe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return BI({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(h=>{yr(i,h.shape,"All tensors passed to stack must have matching shapes"),W(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],u=e.map(h=>{const f=BI({inputs:{input:h},backend:t,attrs:{dim:r}});return l.push(f),f}),d=qV({inputs:u,backend:t,attrs:{axis:r}});return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}const Mhe={kernelName:pm,backendName:"webgl",kernelFunc:zhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Whe{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((d,h)=>d[0]+e[h]+d[1]);const r=e.length,i=dn(r),o=t.map(d=>d[0]).join(","),l=t.map((d,h)=>d[0]+e[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bhe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((N,w)=>N[0]+e[w]+N[1]);const r=e.length,i=dn(r),o=t.map(N=>N[0]).join(","),l=t.map((N,w)=>N[0]+e[w]).join(","),u=zs("rc",r),d=zs("source",r),h=`${u[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${d.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${h}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${h}) {`],I=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let N=0,w=r===1?2:4;N<w;N++)y+=`
        ${m[N]}
        if (${I}) {
          result[${N}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${N}] = getChannel(getX(${d.join()}), ${f});
        }
      `;y+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l5=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;if(Te(r.shape)===0){const d=i.map((h,f)=>h[0]+r.shape[f]+h[1]);return Eh({backend:t,attrs:{shape:d,value:o,dtype:r.dtype}})}const l=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bhe(r.shape,i,o):new Whe(r.shape,i,o),u=[[o]];return t.runWebGLProgram(l,[r],r.dtype,u)},Hhe={kernelName:fm,backendName:"webgl",kernelFunc:l5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uhe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Ghe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+El+`
  return result;
`,qhe=ws({opSnippet:Uhe,packedOpSnippet:Ghe}),Khe={kernelName:Wd,backendName:"webgl",kernelFunc:qhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,l=r.shape.length,u=[],d=Bt(i,r.shape);let h=d;const f=En(h,l);let m=r;f!=null&&(m=Ws({inputs:{x:r},backend:t,attrs:{perm:f}}),h=zn(h.length,l),u.push(m)),xs("prod",h,l);let I;if(t.shouldExecuteOnCPU([m])){const y=t.texData.get(m.dataId).values,{outVals:N,outShape:w,outDtype:T}=qie(m.shape,m.dtype,y,h);I=t.makeTensorInfo(w,T,N)}else{const[y,N]=us(m.shape,h),w=Te(N),T=et({inputs:{x:m},backend:t,attrs:{shape:[-1,w]}}),v=S2(r.dtype),E=kl(T,v,"prod",t);I=et({inputs:{x:E},backend:t,attrs:{shape:y}}),u.push(T),u.push(E)}if(o){u.push(I);const y=Fn(I.shape,d);I=et({inputs:{x:I},backend:t,attrs:{shape:y}})}return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),I}const Yhe={kernelName:gm,backendName:"webgl",kernelFunc:jhe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xhe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:l}=s,u=r.map(T=>t.readSync(T.dataId)),d=r.map(T=>T.shape),h=t.readSync(i.dataId),f=t.readSync(o.dataId),[m,I,y]=Kie(u,d,h,i.shape,i.dtype,f,o.shape,l),N=m.map(T=>t.makeTensorInfo([T.length],"int32",T)),w=t.makeTensorInfo(y,i.dtype,I);return N.concat([w])}const Zhe={kernelName:e2,backendName:"webgl",kernelFunc:Xhe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qhe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(i.dataId),[d,h]=jie(o,s.shape,s.dtype,l,r.shape,u,i.shape),f=t.makeTensorInfo([d.length],"int32",d),m=t.makeTensorInfo([h.length],s.dtype,h);return[f,m]}const Jhe={kernelName:t2,backendName:"webgl",kernelFunc:Qhe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function epe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:l}=e,{rowPartitionTypes:u}=s,d=t.readSync(r.dataId),h=t.readSync(i.dataId),f=t.readSync(o.dataId),m=l.map(w=>t.readSync(w.dataId)),I=l.map(w=>w.shape),[y,N]=Yie(d,r.shape,h,i.shape,i.dtype,f,o.shape,m,I,u);return t.makeTensorInfo(y,i.dtype,N)}const tpe={kernelName:n2,backendName:"webgl",kernelFunc:epe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u5=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:o}=t,l=Xie(s,r,i,o);return e.makeTensorInfo([l.length],o,l)},npe={kernelName:s2,backendName:"webgl",kernelFunc:u5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const spe="return 1.0 / x;",rpe=Qt({opSnippet:spe}),ipe={kernelName:Bd,backendName:"webgl",kernelFunc:rpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ape=ni+`
  return (x < 0.0) ? 0.0 : x;
`,ope=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lpe=Qt({opSnippet:ape,packedOpSnippet:ope}),upe={kernelName:Hd,backendName:"webgl",kernelFunc:lpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cpe=ni+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,dpe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hpe=Qt({opSnippet:cpe,packedOpSnippet:dpe}),ppe={kernelName:Ud,backendName:"webgl",kernelFunc:hpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fpe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,l,u,d]=e;this.outputShape=[o,t,s,d];const h=[r&&t>1?l-1:l,r&&s>1?u-1:u],f=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/f[0]},
          ${h[1]/f[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mpe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,u,d]=e;this.outputShape=[o,t,s,d];const h=[r&&t>1?l-1:l,r&&s>1?u-1:u],f=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/f[0]},
          ${h[1]/f[1]},
          ${h[1]/f[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${d-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gpe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:l}=s,[u,d]=l,h=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new mpe(r.shape,u,d,i,o):new fpe(r.shape,u,d,i,o);return t.runWebGLProgram(h,[r],"float32")}const Ipe={kernelName:bm,backendName:"webgl",kernelFunc:gpe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ype{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,l]=e,u=[s&&o>1?r-1:r,s&&l>1?i-1:i],d=[s&&o>1?o-1:o,s&&l>1?l-1:l],h=u[0]/d[0],f=u[1]/d[1],m=1/h,I=1/f,y=Math.ceil(m)*2+2,N=Math.ceil(I)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${f});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${I});

        const int winHeight = int(${y});
        const int winWidth = int(${N});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bpe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,l=new ype(i.shape,r.shape,o);return t.runWebGLProgram(l,[i],i.dtype)}const xpe={kernelName:a2,backendName:"webgl",kernelFunc:bpe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Npe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,l,u,d]=e;this.outputShape=[o,t,s,d];const h=[r&&t>1?l-1:l,r&&s>1?u-1:u],f=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let I;i?I="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":I="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/f[0]},
          ${h[1]/f[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${I};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wpe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,u,d]=e;this.outputShape=[o,t,s,d];const h=[r&&t>1?l-1:l,r&&s>1?u-1:u],f=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let I;i?I="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":I="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/f[0]},
          ${h[1]/f[1]},
          ${h[1]/f[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${I};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${d-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ape(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:l}=s,[u,d]=l,h=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wpe(r.shape,u,d,i,o):new Npe(r.shape,u,d,i,o);return t.runWebGLProgram(h,[r],r.dtype)}const Tpe={kernelName:ym,backendName:"webgl",kernelFunc:Ape};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Spe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,l]=e,u=[s&&o>1?r-1:r,s&&l>1?i-1:i],d=[s&&o>1?o-1:o,s&&l>1?l-1:l],h=u[0]/d[0],f=u[1]/d[1],m=1/h,I=1/f,y=Math.ceil(m)*2+2,N=Math.ceil(I)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${f});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${I});

        const int winHeight = int(${y});
        const int winWidth = int(${N});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${d[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${d[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vpe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,l=new Spe(i.shape,r.shape,o);return t.runWebGLProgram(l,[i],i.dtype)}const $pe={kernelName:i2,backendName:"webgl",kernelFunc:vpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _pe{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=l=>t.indexOf(l)!==-1&&e[l]!==1?`${e[l]} - coords[${l}] - 1`:`coords[${l}]`,i=e.map((l,u)=>r(u)).join(","),o=dn(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dpe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=zs("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,l=dn(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${i}){
            result.g = ${d(r.slice())};
          }
          if(${o}) {
            result.b = ${h(r.slice())};
            if(${i}) {
              result.a = ${f(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(y){return m(y)}function d(y){return y[s-1]="("+y[s-1]+" + 1)",m(y)}function h(y){return y[s-2]="("+y[s-2]+" + 1)",m(y)}function f(y){return y[s-1]="("+y[s-1]+" + 1)",y[s-2]="("+y[s-2]+" + 1)",m(y)}function m(y){const N=e.map((v,E)=>I(E,y)),w=N.join(","),T=N.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${T}))`}function I(y,N){return t.indexOf(y)!==-1&&e[y]!==1?`${e[y]} - ${N[y]} - 1`:`${N[y]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Epe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,o=r.shape.length,l=Bt(i,r.shape);if(o===0)return gr({inputs:{x:r},backend:t});const u=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dpe(r.shape,l):new _pe(r.shape,l);return t.runWebGLProgram(u,[r],r.dtype)}const kpe={kernelName:xm,backendName:"webgl",kernelFunc:Epe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cpe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lpe={kernelName:A2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,l=t,u=new Cpe(s.shape,i),[d,h]=_b(o,s.shape[1],s.shape[2]),f=[[d,h,Math.sin(r),Math.cos(r)]];return l.runWebGLProgram(u,[s],s.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ope=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Rpe=Qt({opSnippet:Ope}),Vpe={kernelName:Gd,backendName:"webgl",kernelFunc:Rpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ppe="return inversesqrt(x);",Fpe=Qt({opSnippet:Ppe,cpuKernelImpl:Zie}),zpe={kernelName:qd,backendName:"webgl",kernelFunc:Fpe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kx{constructor(e,t,s,r,i,o,l=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const d=dn(i.length),h=dn(o.length);let f="";s===1?f="i":s===2&&(f="i, j");const m=`getIndices(${f})`;let I="";r===1?I="i":r===2&&(I="i, coords[1]");const y=`getUpdates(${I})`;let N="";u&&(N="coords[0], coords[1]");const w=`getDefaultValue(${N})`,T=t>1?"strides[j]":"strides";this.userCode=`
        ${d} strides = ${d}(${i});

        void main() {
          ${h} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${T};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${y};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mpe{constructor(e,t,s,r,i,o,l=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const d=dn(i.length),h=dn(o.length);let f="";s===1?f="i":s===2&&(f="i, j");const m=`getIndices(${f})`;let I="";r===1?I="i":r===2&&(I="i, coords[1]");const y=`getUpdates(${I})`;let N="";u&&(N="coords[0], coords[1]");const w=`getDefaultValue(${N})`,T=t>1?"strides[j]":"strides",v=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${d} strides = ${d}(${i});

        void main() {
          ${h} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${T};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${v};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${y};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wpe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:l,numUpdates:u,sliceSize:d,strides:h,outputSize:f}=Sl(i,r,o),m=[f/d,d];if(f===0)return t.makeTensorInfo(o,r.dtype);const I=et({inputs:{x:r},backend:t,attrs:{shape:[u,l]}}),y=et({inputs:{x:i},backend:t,attrs:{shape:[u,d]}}),N=t.makeTensorInfo([],"float32",new Float32Array([0]));let w;xe().getBool("WEBGL_PACK")?w=new Mpe(u,l,I.shape.length,y.shape.length,h,m):w=new kx(u,l,I.shape.length,y.shape.length,h,m);const T=t.runWebGLProgram(w,[y,I,N],y.dtype),v=et({inputs:{x:T},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(N),v}const Bpe={kernelName:o2,backendName:"webgl",kernelFunc:Wpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hpe{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,l=xe().getNumber("WEBGL_VERSION")===2?i:o,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${l}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Upe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,l=new Hpe(r.shape[0],r.shape[1],i.shape[1],o),u=[[r.shape[1]]];return t.runWebGLProgram(l,[r,i],"int32",u)}const Gpe={kernelName:u2,backendName:"webgl",kernelFunc:Upe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qpe{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const l=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],d=[];for(let h=0;h<t.length;h++)d.push(`${l[h]}`),h<e&&u.push(`${l[h]}`);r=u.join(),i=d.join()}const o=dn(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kpe(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,o=new qpe(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[s,r,i],dr(r.dtype,i.dtype))}const jpe={kernelName:Nm,backendName:"webgl",kernelFunc:Kpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ype=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${ng};
  float scale = ${sg};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Xpe=Qt({opSnippet:Ype}),Zpe={kernelName:Kd,backendName:"webgl",kernelFunc:Xpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qpe=qu+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Jpe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,efe=Qt({opSnippet:Qpe,packedOpSnippet:Jpe,cpuKernelImpl:Jie}),tfe={kernelName:Zd,backendName:"webgl",kernelFunc:efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nfe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,sfe=Qt({opSnippet:nfe}),rfe={kernelName:Xd,backendName:"webgl",kernelFunc:sfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ife=qu+`
  return sin(x);
`,afe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${El}
  return result;
`,ofe=Qt({opSnippet:ife,packedOpSnippet:afe}),lfe={kernelName:jd,backendName:"webgl",kernelFunc:ofe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ufe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,cfe=Qt({opSnippet:ufe}),dfe={kernelName:Yd,backendName:"webgl",kernelFunc:cfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hfe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,pfe=Qt({opSnippet:hfe}),ffe={kernelName:Qd,backendName:"webgl",kernelFunc:pfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mfe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;W(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((T,v)=>T*v),u=[[0,0]];u.push(...o);for(let T=1+i.length;T<r.shape.length;++T)u.push([0,0]);const d=[],h=l5({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),f=fh(h.shape,i,l,!1),m=mh(f.length,i.length,!1),I=gh(h.shape,i,l,!1),y=et({inputs:{x:h},backend:t,attrs:{shape:f}}),N=Ws({inputs:{x:y},backend:t,attrs:{perm:m}}),w=et({inputs:{x:N},backend:t,attrs:{shape:I}});return d.push(h),d.push(y),d.push(N),d.forEach(T=>t.disposeIntermediateTensorInfo(T)),w},gfe={kernelName:Tm,backendName:"webgl",kernelFunc:mfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ife(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=t.readSync(s.dataId),u=t.readSync(r.dataId),d=t.readSync(i.dataId),h=t.readSync(o.dataId)[0],[f,m,I,y,N]=tae(l,s.shape,s.dtype,u,r.dtype,d,h);return[t.makeTensorInfo(m,s.dtype,f),t.makeTensorInfo([m[0]],r.dtype,I),t.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(w=>Number(w)))),t.makeTensorInfo([N.length],s.dtype,new Int32Array(N))]}const yfe={kernelName:c2,backendName:"webgl",kernelFunc:Ife};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bfe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(r.dataId)),l=t.readSync(s.dataId),u=Array.from(t.readSync(i.dataId)),[d,h,f]=nae(l,s.shape,s.dtype,o,u);return[t.makeTensorInfo(h,s.dtype,d),t.makeTensorInfo([f.length],i.dtype,new Int32Array(f))]}const xfe={kernelName:d2,backendName:"webgl",kernelFunc:bfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nfe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(i.dataId),[d,h]=LV(o,s.shape,s.dtype,l,u,!0);return t.makeTensorInfo(h,s.dtype,d)}const wfe={kernelName:h2,backendName:"webgl",kernelFunc:Nfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Afe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(i.dataId),[d,h]=LV(o,s.shape,s.dtype,l,u);return t.makeTensorInfo(h,s.dtype,d)}const Tfe={kernelName:p2,backendName:"webgl",kernelFunc:Afe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sfe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:l}=s,{sliceRank:u,numUpdates:d,sliceSize:h,strides:f,outputSize:m}=Sl(i,r,l),I=!1;if(i.dtype==="string"){const T=t.bufferSync(r),v=t.bufferSync(i),E=Ga(t.readSync(o.dataId)[0]),_=Qie(T,v,l,m,h,d,u,f,E,I);return t.makeTensorInfo(l,_.dtype,_.values)}const y=new kx(d,u,r.shape.length,i.shape.length,f,[m,1],I),N=t.runWebGLProgram(y,[i,r,o],i.dtype),w=et({inputs:{x:N},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(N),w}const vfe={kernelName:f2,backendName:"webgl",kernelFunc:Sfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $fe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,l=Bt(o,r.shape)[0],u=Hb(r,i,l),d=r.shape.length,h=new Array(d).fill(0),f=r.shape.slice();return u.map(m=>{const I=[...f];I[l]=m;const y=Ku({inputs:{x:r},backend:t,attrs:{begin:h,size:I}});return h[l]+=m,y})}const _fe={kernelName:Sm,backendName:"webgl",kernelFunc:$fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pD="return sqrt(x);",Dfe=Qt({opSnippet:pD,packedOpSnippet:pD,cpuKernelImpl:sae}),Efe={kernelName:Jd,backendName:"webgl",kernelFunc:Dfe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kfe="return x * x;",Cfe=Qt({opSnippet:kfe}),Lfe={kernelName:m2,backendName:"webgl",kernelFunc:Cfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fD="return (a - b) * (a - b);",Ofe=ws({opSnippet:fD,packedOpSnippet:fD}),Rfe={kernelName:eh,backendName:"webgl",kernelFunc:Ofe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),o=Ia(i),l=rae(o,"string",s);return t.makeTensorInfo(r.shape,"string",l)}const Pfe={kernelName:$m,backendName:"webgl",kernelFunc:Vfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ffe({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=ni+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new Fi(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const zfe={kernelName:ih,backendName:"webgl",kernelFunc:Ffe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mfe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=dn(s.length),o=dn(s.length);let l="";if(r===1)l="coords * strides + begin";else{let u=0;l=s.map((d,h)=>(u++,s.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${u-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:l,beginMask:u,endMask:d,ellipsisMask:h,newAxisMask:f,shrinkAxisMask:m}=s,{finalShapeSparse:I,finalShape:y,isIdentity:N,sliceDim0:w,isSimpleSlice:T,begin:v,end:E,strides:_}=Sb(r.shape,i,o,l,u,d,h,f,m);let L;if(N)L=et({inputs:{x:r},backend:t,attrs:{shape:y}});else if(w||T){W(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const B=wb(v,E,_),U=Ku({inputs:{x:r},backend:t,attrs:{begin:v,size:B}});L=et({inputs:{x:U},backend:t,attrs:{shape:y}}),t.disposeIntermediateTensorInfo(U)}else if(t.shouldExecuteOnCPU([r])){const U=t.readSync(r.dataId),Z=zt(r.shape,r.dtype,U),Y=iae(I,Z,_,v);L=t.makeTensorInfo(y,r.dtype,Y.values)}else{const U=new Mfe(v,_,I);L=t.runWebGLProgram(U,[r],r.dtype)}const P=et({inputs:{x:L},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(L),P}const Bfe={kernelName:g2,backendName:"webgl",kernelFunc:Wfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hfe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:l,padWidth:u,preserveShortSequences:d}=s,{data:h,dataSplits:f}=e,m=t.readSync(h.dataId),I=t.readSync(f.dataId),[y,N]=aae(m,I,r,i,o,l,u,d);return[t.makeTensorInfo([y.length],"string",y),t.makeTensorInfo(f.shape,"int32",N)]}const Ufe={kernelName:I2,backendName:"webgl",kernelFunc:Hfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gfe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=t.readSync(i.dataId),u=t.readSync(o.dataId)[0],[d,h,f]=oae(l,u,r),m=h.length;return[t.makeTensorInfo([m,2],"int32",d),t.makeTensorInfo([m],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const qfe={kernelName:y2,backendName:"webgl",kernelFunc:Gfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kfe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),l=lae(o,r);return t.makeTensorInfo(i.shape,"int32",l)}const jfe={kernelName:b2,backendName:"webgl",kernelFunc:Kfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yfe="return tan(x);",Xfe=Qt({opSnippet:Yfe}),Zfe={kernelName:nh,backendName:"webgl",kernelFunc:Xfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qfe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Jfe=Qt({opSnippet:Qfe}),eme={kernelName:sh,backendName:"webgl",kernelFunc:Jfe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tme(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:o}=e,{sliceRank:l,numUpdates:u,sliceSize:d,strides:h,outputSize:f}=Sl(o,i,r.shape),m=[f/d,d];if(f===0)return t.makeTensorInfo(r.shape,i.dtype);const I=et({inputs:{x:i},backend:t,attrs:{shape:[u,l]}}),y=et({inputs:{x:o},backend:t,attrs:{shape:[u,d]}}),N=et({inputs:{x:r},backend:t,attrs:{shape:m}}),w=new kx(u,l,I.shape.length,y.shape.length,h,m,!1,!0),T=t.runWebGLProgram(w,[y,I,N],N.dtype),v=et({inputs:{x:T},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(T),v}const nme={kernelName:l2,backendName:"webgl",kernelFunc:tme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sme{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const r=dn(this.rank),i=rme(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function rme(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const u=t.readSync(r.dataId),d=r.dtype==="string"?u.map(m=>Ga(m)):u,h=zt(r.shape,r.dtype,d),f=cae(h,i);return t.makeTensorInfo(f.shape,f.dtype,f.values)}const o=new sme(r.shape,i);return t.runWebGLProgram(o,[r],r.dtype)}const ime={kernelName:rh,backendName:"webgl",kernelFunc:c5};class ame{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class ome{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ro(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function mD(n){let e=1;for(;e<n;)e*=2;return e}function lme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s,l=xe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=xe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=r.shape,h=d[d.length-1];if(t.shouldExecuteOnCPU([r])||h<l||i>u){const Y=t.readSync(r.dataId),[ae,de]=dae(Y,d,r.dtype,i,o);return[t.makeTensorInfo(ae.shape,ae.dtype,ae.values),t.makeTensorInfo(de.shape,de.dtype,de.values)]}if(i===0)return d[d.length-1]=0,[t.makeTensorInfo(d,r.dtype,[]),t.makeTensorInfo(d,"int32",[])];if(h===1)return[r,Eh({attrs:{shape:d,dtype:"int32",value:0},backend:t})];const f=t.texData.get(r.dataId),m=f!==null&&f.isPacked,I=m?t.unpackTensor(r):r,N=Te(d)/h,w=et({inputs:{x:I},attrs:{shape:[N,h]},backend:t});m&&Ro(t,I);const T=mD(i),v=mD(h);let E=null;const _=()=>E===null?[w,w]:[w,E],L=(Y,ae,de)=>{const ce=_(),Ie=new ame(de),ye=[[h],[E===null?1:0],[Number.NEGATIVE_INFINITY],[Y],[ae]],we=E;E=t.runWebGLProgram(Ie,ce,"int32",ye),Ro(t,we)};for(let Y=1;Y<T;Y*=2){const ae=Y*2;for(let de=Y;de>=1;de/=2)L(ae,de,[N,v])}for(let Y=v;Y>T;Y/=2){const ae=_(),de=new ome([N,Y/2]),Ie=[[h],[E===null?1:0],[T]],be=E;E=t.runWebGLProgram(de,ae,"int32",Ie),Ro(t,be);const ye=T/2,we=ye*2;for(let fe=ye;fe>=1;fe/=2)L(we,fe,E.shape)}let P=E;E=Ku({inputs:{x:E},backend:t,attrs:{begin:0,size:[N,i]}}),Ro(t,P);let B=n5({inputs:{x:w,indices:E},backend:t,attrs:{axis:1,batchDims:1}});Ro(t,w);const U=d.slice(0,-1);U.push(i),P=E,E=et({inputs:{x:E},attrs:{shape:U},backend:t}),Ro(t,P);const Z=B;return B=et({inputs:{x:B},attrs:{shape:U},backend:t}),Ro(t,Z),[B,E]}const ume={kernelName:x2,backendName:"webgl",kernelFunc:lme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cme{constructor(e,t,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const l=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${l} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dme(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:l,fillValue:u,outputShape:d}=s,[h,f,m,I]=r.shape,[y,N]=d??[f,m],w=[h,y,N,I],T=new cme(f,m,o,l,u,w);return t.runWebGLProgram(T,[r,i],"float32")}const hme={kernelName:N2,backendName:"webgl",kernelFunc:dme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pme(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;$h(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:l,outputShape:u,indices:d}=hae(o,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,l),s.makeTensorInfo([d.length],"int32",d)]}const fme={kernelName:w2,backendName:"webgl",kernelFunc:pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mme(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,l=o.shape.length,u=r.shape[i],d=new Array(l-1);let h=0;for(let N=0;N<l;N++)N!==i&&(d[h++]=o.shape[N]);const f=[],m=new Array(l).fill(0),I=o.shape.slice();I[i]=1;const y=new Array(u);for(let N=0;N<y.length;N++){m[i]=N;const w=Ku({inputs:{x:o},backend:t,attrs:{begin:m,size:I}}),T=et({inputs:{x:w},backend:t,attrs:{shape:d}});y[N]=T,f.push(w)}return f.forEach(N=>t.disposeIntermediateTensorInfo(N)),y}const gme={kernelName:_m,backendName:"webgl",kernelFunc:mme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ime{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,o=e.numSegments,l=o*Math.ceil(i/s);this.outputShape=[r,l];const u="0.0",d="sumValue",h=Math.floor(s/4)*4,f=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let I="";i%s>0&&(I=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${I}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${y}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${h};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${d});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s,l=r.shape.length,u=[];let d=0;const h=En([d],l);let f=r;h!=null&&(f=Ws({inputs:{x:r},backend:t,attrs:{perm:h}}),u.push(f),d=zn(1,l)[0]);const m=BL(f.shape,d,o),I=Te([f.shape[d]]),y=et({inputs:{x:f},backend:t,attrs:{shape:[-1,I]}});u.push(y);const N=S2(r.dtype),w=(_,L,P,B,U)=>{const Z=_.shape[0],Y=_.shape[1],ae=WL(Y,U),de={windowSize:ae,inSize:Y,batchSize:Z,numSegments:U},ce=new Ime(de,L),Ie=t.compileAndRun(ce,[_,P],B);if(u.push(Ie),Ie.shape[1]===U)return Ie;const be=u5({backend:t,attrs:{start:0,stop:U,step:1,dtype:"float32"}}),ye=c5({inputs:{x:be},backend:t,attrs:{reps:[Y/ae]}});return u.push(be),u.push(ye),w(Ie,L,ye,B,U)},T=w(y,"unsortedSegmentSum",i,N,o),v=et({inputs:{x:T},backend:t,attrs:{shape:m}});let E=v;if(h!=null){u.push(v);const _=uo(h);E=Ws({inputs:{x:E},backend:t,attrs:{perm:_}})}return u.forEach(_=>t.disposeIntermediateTensorInfo(_)),E}const bme={kernelName:Dm,backendName:"webgl",kernelFunc:yme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xme=[soe,ioe,loe,doe,poe,goe,yoe,xoe,Toe,voe,Doe,Coe,Roe,zoe,Boe,Uoe,qoe,Xoe,Qoe,ele,rle,dle,ple,Ile,ble,Sle,$le,kle,Mae,Ole,zle,Hle,Yle,Qle,eue,nue,rue,lue,due,fue,gue,yue,xue,Aue,Sue,Due,kue,Oue,Pue,zue,Hue,Kue,Zue,ece,sce,rce,ace,lce,cce,hce,fce,yce,Nce,Tce,vce,Dce,Cce,Vce,Mce,zae,Bce,Ple,Gce,jce,Zce,Bae,tde,ide,ode,dde,fde,yde,Nde,Sde,Dde,Cde,Ode,Fde,Mde,Bde,qde,jde,Xde,Qde,ehe,rhe,lhe,hhe,xhe,Gae,The,$he,Ehe,Lhe,Nle,Vhe,Fhe,Mhe,Hhe,Khe,Uae,Yhe,Zhe,Jhe,tpe,npe,wle,ghe,ipe,upe,ppe,Kae,Ipe,xpe,Tpe,$pe,kpe,Lpe,Vpe,zpe,Bpe,Gpe,jpe,Zpe,tfe,rfe,lfe,dfe,ule,yhe,ffe,gfe,yfe,xfe,wfe,Tfe,vfe,_fe,Efe,Lfe,Rfe,Pfe,zfe,Bfe,Ufe,qfe,jfe,Ihe,eoe,Zfe,eme,nme,ime,ume,hme,toe,fme,gme,bme,Phe];for(const n of xme)uk(n);class Nme{constructor(){Mt(this,"nnetSession");Mt(this,"model");Mt(this,"initialized",!1)}async init(e){const t="/nichess2/1/model.json";this.model=await tZ(t),this.initialized=!0}async nnPredict(e){const t=e.canonicalized(),s=Dr(t).expandDims(0),r=this.model.execute(s),i=r[0].dataSync(),o=r[1].dataSync();return Ft([s,r]),[i,o]}async nnPredictBatch(e,t){let s=[];for(let h=0;h<t;h++)s.push(e[h].gs.canonicalized());const r=Dr(s),i=performance.now(),o=this.model.execute(r),l=performance.now();console.log(`Model execution took ${(l-i).toFixed(3)}ms`),console.log(`batch size: ${t}`);const u=o[0].dataSync(),d=o[1].dataSync();for(let h=0;h<t;h++){e[h].pi=new Array(Ho),e[h].v=new Array(3);let f=0;for(let m=h*Ho;m<h*Ho+Ho;m++)e[h].pi[f]=u[m],f+=1;f=0;for(let m=h*3;m<h*3+3;m++)e[h].v[f]=d[m],f+=1}Ft([r,o])}async runSearch(e,t,s){Fr().startScope();const r=performance.now();let i=new my({encodedBoard:t}),o=new Kz(1.25,i.num_players(),i.num_moves(),0,1.4,.25),l=new Array(s);for(let v=0;v<60;v++){const E=performance.now();let _=new Array(s),L=0;for(let B=0;B<s;B++)l[v]=o.find_leaf(i),l[v]!=null&&(_[L]=new qz(o.path_,o.current_,l[v]),L+=1),o.path_=[],o.current_={};this.nnPredictBatch(_,L);for(let B=0;B<L;B++){let U=_[B];o.process_result(U.gs,U.v,U.pi,!1,U.current,U.path)}const P=performance.now();console.log(`One entire simulation took ${(P-E).toFixed(3)}ms`)}const d=o.counts().map((v,E)=>[E,v]).sort((v,E)=>E[1]-v[1]);let h=`Counts:
`;for(let v=0;v<8;v++){let E=d[v];if(E[1]==0)continue;let _=i.gameWrapper.createNichessAction(E[0]);h+=_.srcIdx+" -> "+_.dstIdx+": "+E[1]+`
`}console.log(h);let f=o.root_value();console.log(f);let m="AI chance of winning: "+f[0]+`
`;m+="Human chance of winning: "+f[1]+`
`,m+="Draw chance: "+f[2]+`
`,console.log(m);let I=h+m,y=o.probs(0),N=y.indexOf(Math.max(...y)),w=i.gameWrapper.createNichessAction(N);const T=performance.now();return console.log(`runSearch took ${(T-r).toFixed(3)}ms`),Fr().endScope(),[w,I]}}const wme=["white","black"],d5=["a","b","c","d","e","f","g","h"],Cx=["1","2","3","4","5","6","7","8"];[...Cx].reverse();const Lx=Array.prototype.concat(...d5.map(n=>Cx.map(e=>n+e))),Vi=n=>Lx[8*n[0]+n[1]],Ln=n=>[n.charCodeAt(0)-97,n.charCodeAt(1)-49],h5=Lx.map(Ln);function Ame(n){let e;const t=()=>(e===void 0&&(e=n()),e);return t.clear=()=>{e=void 0},t}const Tme=()=>{let n;return{start(){n=performance.now()},cancel(){n=void 0},stop(){if(!n)return 0;const e=performance.now()-n;return n=void 0,e}}},Ng=n=>n==="white"?"black":"white",id=(n,e)=>{const t=n[0]-e[0],s=n[1]-e[1];return t*t+s*s},HI=(n,e)=>n.role===e.role&&n.color===e.color,kh=n=>(e,t)=>[(t?e[0]:7-e[0])*n.width/8,(t?7-e[1]:e[1])*n.height/8],ki=(n,e)=>{n.style.transform=`translate(${e[0]}px,${e[1]}px)`},p5=(n,e,t=1)=>{n.style.transform=`translate(${e[0]}px,${e[1]}px) scale(${t})`},Ox=(n,e)=>{n.style.visibility=e?"visible":"hidden"},Cl=n=>{var e;if(n.clientX||n.clientX===0)return[n.clientX,n.clientY];if(!((e=n.targetTouches)===null||e===void 0)&&e[0])return[n.targetTouches[0].clientX,n.targetTouches[0].clientY]},f5=n=>n.buttons===2||n.button===2,ua=(n,e)=>{const t=document.createElement(n);return e&&(t.className=e),t};function m5(n,e,t){const s=Ln(n);return e||(s[0]=7-s[0],s[1]=7-s[1]),[t.left+t.width*s[0]/8+t.width/16,t.top+t.height*(7-s[1])/8+t.height/16]}const ml=(n,e)=>Math.abs(n-e),Sme=n=>(e,t,s,r)=>ml(e,s)<2&&(n==="white"?r===t+1||t<=1&&r===t+2&&e===s:r===t-1||t>=6&&r===t-2&&e===s),g5=(n,e,t,s)=>{const r=ml(n,t),i=ml(e,s);return r===1&&i===2||r===2&&i===1},I5=(n,e,t,s)=>ml(n,t)===ml(e,s),y5=(n,e,t,s)=>n===t||e===s,b5=(n,e,t,s)=>I5(n,e,t,s)||y5(n,e,t,s),vme=(n,e,t)=>(s,r,i,o)=>ml(s,i)<2&&ml(r,o)<2||t&&r===o&&r===(n==="white"?0:7)&&(s===4&&(i===2&&e.includes(0)||i===6&&e.includes(7))||e.includes(i));function $me(n,e){const t=e==="white"?"1":"8",s=[];for(const[r,i]of n)r[1]===t&&i.color===e&&i.role==="rook"&&s.push(Ln(r)[0]);return s}function x5(n,e,t){const s=n.get(e);if(!s)return[];const r=Ln(e),i=s.role,o=i==="pawn"?Sme(s.color):i==="knight"?g5:i==="bishop"?I5:i==="rook"?y5:i==="queen"?b5:vme(s.color,$me(n,s.color),t);return h5.filter(l=>(r[0]!==l[0]||r[1]!==l[1])&&o(r[0],r[1],l[0],l[1])).map(Vi)}function nr(n,...e){n&&setTimeout(()=>n(...e),1)}function _me(n){n.orientation=Ng(n.orientation),n.animation.current=n.draggable.current=n.selected=void 0}function Dme(n,e){for(const[t,s]of e)s?n.pieces.set(t,s):n.pieces.delete(t)}function Eme(n,e){if(n.check=void 0,e===!0&&(e=n.turnColor),e)for(const[t,s]of n.pieces)s.role==="king"&&s.color===e&&(n.check=t)}function kme(n,e,t,s){yo(n),n.premovable.current=[e,t],nr(n.premovable.events.set,e,t,s)}function Io(n){n.premovable.current&&(n.premovable.current=void 0,nr(n.premovable.events.unset))}function Cme(n,e,t){Io(n),n.predroppable.current={role:e,key:t},nr(n.predroppable.events.set,e,t)}function yo(n){const e=n.predroppable;e.current&&(e.current=void 0,nr(e.events.unset))}function Lme(n,e,t){if(!n.autoCastle)return!1;const s=n.pieces.get(e);if(!s||s.role!=="king")return!1;const r=Ln(e),i=Ln(t);if(r[1]!==0&&r[1]!==7||r[1]!==i[1])return!1;r[0]===4&&!n.pieces.has(t)&&(i[0]===6?t=Vi([7,i[1]]):i[0]===2&&(t=Vi([0,i[1]])));const o=n.pieces.get(t);return!o||o.color!==s.color||o.role!=="rook"?!1:(n.pieces.delete(e),n.pieces.delete(t),r[0]<i[0]?(n.pieces.set(Vi([6,i[1]]),s),n.pieces.set(Vi([5,i[1]]),o)):(n.pieces.set(Vi([2,i[1]]),s),n.pieces.set(Vi([3,i[1]]),o)),!0)}function N5(n,e,t){const s=n.pieces.get(e),r=n.pieces.get(t);if(e===t||!s)return!1;const i=r&&r.color!==s.color?r:void 0;return t===n.selected&&Qs(n),nr(n.events.move,e,t,i),Lme(n,e,t)||(n.pieces.set(t,s),n.pieces.delete(e)),n.lastMove=[e,t],n.check=void 0,nr(n.events.change),i||!0}function Ome(n,e,t){const s=n.pieces.get(e);if(e===t||!s)return!1;const r=void 0;return t===n.selected&&Qs(n),n.lastMove=[e,t],n.check=void 0,nr(n.events.change),r||!0}function Rx(n,e,t,s){if(n.pieces.has(t))if(s)n.pieces.delete(t);else return!1;return nr(n.events.dropNewPiece,e,t),n.pieces.set(t,e),n.lastMove=[t],n.check=void 0,nr(n.events.change),n.movable.dests=void 0,n.turnColor=Ng(n.turnColor),!0}function w5(n,e,t){const s=N5(n,e,t);return s&&(n.movable.dests=void 0,n.turnColor=Ng(n.turnColor),n.animation.current=void 0),s}function Rme(n,e,t){const s=Ome(n,e,t);return s&&(n.movable.dests=void 0,n.turnColor=Ng(n.turnColor),n.animation.current=void 0),s}function A5(n,e,t){if(Vx(n,e,t)){const s=w5(n,e,t);if(s){const r=n.hold.stop();Qs(n);const i={premove:!1,ctrlKey:n.stats.ctrlKey,holdTime:r};return s!==!0&&(i.captured=s),n.movePhaseNichess=!0,nr(n.movable.events.after,e,t,i),!0}}else if(zme(n,e,t))return kme(n,e,t,{ctrlKey:n.stats.ctrlKey}),Qs(n),!0;return Qs(n),!1}function T5(n,e,t){if(Pme(n,e,t)&&Rme(n,e,t)){const r=n.hold.stop();return Qs(n),n.stats.ctrlKey,n.movePhaseNichess=!0,!0}return Qs(n),!1}function S5(n,e,t,s){const r=n.pieces.get(e);r&&(Fme(n,e,t)||s)?(n.pieces.delete(e),Rx(n,r,t,s),nr(n.movable.events.afterNewPiece,r.role,t,{premove:!1,predrop:!1})):r&&Mme(n,e,t)?Cme(n,r.role,t):(Io(n),yo(n)),n.pieces.delete(e),Qs(n)}function UI(n,e,t){if(nr(n.events.select,e),n.selected){if(n.selected===e&&!n.draggable.enabled){Qs(n),n.hold.cancel();return}else if((n.selectable.enabled||t)&&n.selected!==e){if(n.movePhaseNichess){if(A5(n,n.selected,e)){n.stats.dragged=!1;return}}else if(T5(n,n.selected,e)){n.stats.dragged=!1;return}}}(n.selectable.enabled||n.draggable.enabled)&&($5(n,e)||Px(n,e))&&(v5(n,e),n.hold.start())}function v5(n,e){n.selected=e,Px(n,e)?n.premovable.customDests||(n.premovable.dests=x5(n.pieces,e,n.premovable.castle)):n.premovable.dests=void 0}function Qs(n){n.selected=void 0,n.premovable.dests=void 0,n.hold.cancel()}function $5(n,e){const t=n.pieces.get(e);return!!t&&(n.movable.color==="both"||n.movable.color===t.color&&n.turnColor===t.color)}function Vme(n,e){const t=n.pieces.get(e);return!!t&&(n.movable.color==="both"||n.movable.color===t.color&&n.turnColor===t.color)}const Vx=(n,e,t)=>{var s,r;return e!==t&&$5(n,e)&&(n.movable.free||!!(!((r=(s=n.movable.dests)===null||s===void 0?void 0:s.get(e))===null||r===void 0)&&r.includes(t)))},Pme=(n,e,t)=>{var s,r;return e!==t&&Vme(n,e)&&(n.movable.free||!!(!((r=(s=n.movable.dests)===null||s===void 0?void 0:s.get(e))===null||r===void 0)&&r.includes(t)))};function Fme(n,e,t){const s=n.pieces.get(e);return!!s&&(e===t||!n.pieces.has(t))&&(n.movable.color==="both"||n.movable.color===s.color&&n.turnColor===s.color)}function Px(n,e){const t=n.pieces.get(e);return!!t&&n.premovable.enabled&&n.movable.color===t.color&&n.turnColor!==t.color}function zme(n,e,t){var s,r;const i=(r=(s=n.premovable.customDests)===null||s===void 0?void 0:s.get(e))!==null&&r!==void 0?r:x5(n.pieces,e,n.premovable.castle);return e!==t&&Px(n,e)&&i.includes(t)}function Mme(n,e,t){const s=n.pieces.get(e),r=n.pieces.get(t);return!!s&&(!r||r.color!==n.movable.color)&&n.predroppable.enabled&&(s.role!=="pawn"||t[1]!=="1"&&t[1]!=="8")&&n.movable.color===s.color&&n.turnColor!==s.color}function Wme(n,e){const t=n.pieces.get(e);return!!t&&n.draggable.enabled&&(n.movable.color==="both"||n.movable.color===t.color&&(n.turnColor===t.color||n.premovable.enabled))}function Bme(n){const e=n.premovable.current;if(!e)return!1;const t=e[0],s=e[1];let r=!1;if(Vx(n,t,s)){const i=w5(n,t,s);if(i){const o={premove:!0};i!==!0&&(o.captured=i),nr(n.movable.events.after,t,s,o),r=!0}}return Io(n),r}function Hme(n,e){const t=n.predroppable.current;let s=!1;if(!t)return!1;if(e(t)){const r={role:t.role,color:n.movable.color};Rx(n,r,t.key)&&(nr(n.movable.events.afterNewPiece,t.role,t.key,{premove:!1,predrop:!0}),s=!0)}return yo(n),s}function Fx(n){Io(n),yo(n),Qs(n)}function gD(n){n.movable.color=n.movable.dests=n.animation.current=void 0,Fx(n)}function Ll(n,e,t){let s=Math.floor(8*(n[0]-t.left)/t.width);e||(s=7-s);let r=7-Math.floor(8*(n[1]-t.top)/t.height);return e||(r=7-r),s>=0&&s<8&&r>=0&&r<8?Vi([s,r]):void 0}function Ume(n,e,t,s){const r=Ln(n),i=h5.filter(d=>b5(r[0],r[1],d[0],d[1])||g5(r[0],r[1],d[0],d[1])),l=i.map(d=>m5(Vi(d),t,s)).map(d=>id(e,d)),[,u]=l.reduce((d,h,f)=>d[0]<h?d:[h,f],[l[0],0]);return Vi(i[u])}const Ir=n=>n.orientation==="white";function Gme(n){let e=n-Math.floor(n/8)*8,t=Math.floor(n/8);return[e+1,t+1]}function qme(n){let e=Gme(n),t=e[0],s=e[1],r="";switch(t){case 1:r="a";break;case 2:r="b";break;case 3:r="c";break;case 4:r="d";break;case 5:r="e";break;case 6:r="f";break;case 7:r="g";break;case 8:r="h";break}return r+s.toString()}function _5(n){const e=new Map;let s=n.substring(2).split(",");s.pop();let r=0;return s.forEach(i=>{let o=i.split("-");if(o[0]!="empty"){let l=Number(o[2]),u=o[0]+o[1],d=qme(r);u=="0king"?e.set(d,{role:"king",color:"white",healthPoints:l}):u=="0pawn"?e.set(d,{role:"pawn",color:"white",healthPoints:l}):u=="0mage"?e.set(d,{role:"queen",color:"white",healthPoints:l}):u=="0assassin"?e.set(d,{role:"bishop",color:"white",healthPoints:l}):u=="0knight"?e.set(d,{role:"knight",color:"white",healthPoints:l}):u=="0warrior"?e.set(d,{role:"rook",color:"white",healthPoints:l}):u=="1king"?e.set(d,{role:"king",color:"black",healthPoints:l}):u=="1pawn"?e.set(d,{role:"pawn",color:"black",healthPoints:l}):u=="1mage"?e.set(d,{role:"queen",color:"black",healthPoints:l}):u=="1assassin"?e.set(d,{role:"bishop",color:"black",healthPoints:l}):u=="1knight"?e.set(d,{role:"knight",color:"black",healthPoints:l}):u=="1warrior"&&e.set(d,{role:"rook",color:"black",healthPoints:l})}r+=1}),e}function D5(n,e){e.animation&&(zx(n.animation,e.animation),(n.animation.duration||0)<70&&(n.animation.enabled=!1))}function E5(n,e){var t,s,r;if(!((t=e.movable)===null||t===void 0)&&t.dests&&(n.movable.dests=void 0),!((s=e.drawable)===null||s===void 0)&&s.autoShapes&&(n.drawable.autoShapes=[]),zx(n,e),e.fen&&(n.pieces=_5(e.fen),n.drawable.shapes=((r=e.drawable)===null||r===void 0?void 0:r.shapes)||[]),"check"in e&&Eme(n,e.check||!1),"lastMove"in e&&!e.lastMove?n.lastMove=void 0:e.lastMove&&(n.lastMove=e.lastMove),n.selected&&v5(n,n.selected),D5(n,e),!n.movable.rookCastle&&n.movable.dests){const i=n.movable.color==="white"?"1":"8",o="e"+i,l=n.movable.dests.get(o),u=n.pieces.get(o);if(!l||!u||u.role!=="king")return;n.movable.dests.set(o,l.filter(d=>!(d==="a"+i&&l.includes("c"+i))&&!(d==="h"+i&&l.includes("g"+i))))}}function zx(n,e){for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&(Object.prototype.hasOwnProperty.call(n,t)&&ID(n[t])&&ID(e[t])?zx(n[t],e[t]):n[t]=e[t])}function ID(n){if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return e===Object.prototype||e===null}const Fo=(n,e)=>e.animation.enabled?Yme(n,e):Da(n,e);function Da(n,e){const t=n(e);return e.dom.redraw(),t}const _1=(n,e)=>({key:n,pos:Ln(n),piece:e}),Kme=(n,e)=>e.sort((t,s)=>id(n.pos,t.pos)-id(n.pos,s.pos))[0];function jme(n,e){const t=new Map,s=[],r=new Map,i=[],o=[],l=new Map;let u,d,h;for(const[f,m]of n)l.set(f,_1(f,m));for(const f of Lx)u=e.pieces.get(f),d=l.get(f),u?d?HI(u,d.piece)||(i.push(d),o.push(_1(f,u))):o.push(_1(f,u)):d&&i.push(d);for(const f of o)d=Kme(f,i.filter(m=>HI(f.piece,m.piece))),d&&(h=[d.pos[0]-f.pos[0],d.pos[1]-f.pos[1]],t.set(f.key,h.concat(h)),s.push(d.key));for(const f of i)s.includes(f.key)||r.set(f.key,f.piece);return{anims:t,fadings:r}}function k5(n,e){const t=n.animation.current;if(t===void 0){n.dom.destroyed||n.dom.redrawNow();return}const s=1-(e-t.start)*t.frequency;if(s<=0)n.animation.current=void 0,n.dom.redrawNow();else{const r=Xme(s);for(const i of t.plan.anims.values())i[2]=i[0]*r,i[3]=i[1]*r;n.dom.redrawNow(!0),requestAnimationFrame((i=performance.now())=>k5(n,i))}}function Yme(n,e){const t=new Map(e.pieces),s=n(e),r=jme(t,e);if(r.anims.size||r.fadings.size){const i=e.animation.current&&e.animation.current.start;e.animation.current={start:performance.now(),frequency:1/e.animation.duration,plan:r},i||k5(e,performance.now())}else e.dom.redraw();return s}const Xme=n=>n<.5?4*n*n*n:(n-1)*(2*n-2)*(2*n-2)+1,Zme=["green","red","blue","yellow"];function Qme(n,e){if(e.touches&&e.touches.length>1)return;e.stopPropagation(),e.preventDefault(),e.ctrlKey?Qs(n):Fx(n);const t=Cl(e),s=Ll(t,Ir(n),n.dom.bounds());s&&(n.drawable.current={orig:s,pos:t,brush:nge(e),snapToValidMove:n.drawable.defaultSnapToValidMove},C5(n))}function C5(n){requestAnimationFrame(()=>{const e=n.drawable.current;if(e){const t=Ll(e.pos,Ir(n),n.dom.bounds());t||(e.snapToValidMove=!1);const s=e.snapToValidMove?Ume(e.orig,e.pos,Ir(n),n.dom.bounds()):t;s!==e.mouseSq&&(e.mouseSq=s,e.dest=s!==e.orig?s:void 0,n.dom.redrawNow()),C5(n)}})}function Jme(n,e){n.drawable.current&&(n.drawable.current.pos=Cl(e))}function ege(n){const e=n.drawable.current;e&&(e.mouseSq&&sge(n.drawable,e),L5(n))}function L5(n){n.drawable.current&&(n.drawable.current=void 0,n.dom.redraw())}function tge(n){n.drawable.shapes.length&&(n.drawable.shapes=[],n.dom.redraw(),O5(n.drawable))}function nge(n){var e;const t=(n.shiftKey||n.ctrlKey)&&f5(n),s=n.altKey||n.metaKey||((e=n.getModifierState)===null||e===void 0?void 0:e.call(n,"AltGraph"));return Zme[(t?1:0)+(s?2:0)]}function sge(n,e){const t=r=>r.orig===e.orig&&r.dest===e.dest,s=n.shapes.find(t);s&&(n.shapes=n.shapes.filter(r=>!t(r))),(!s||s.brush!==e.brush)&&n.shapes.push({orig:e.orig,dest:e.dest,brush:e.brush}),O5(n)}function O5(n){n.onChange&&n.onChange(n.shapes)}function rge(n,e){if(!(n.trustAllEvents||e.isTrusted)||e.button!==void 0&&e.button!==0||e.touches&&e.touches.length>1)return;const t=n.dom.bounds(),s=Cl(e),r=Ll(s,Ir(n),t);if(!r)return;const i=n.pieces.get(r),o=n.selected;if(!o&&n.drawable.enabled&&(n.drawable.eraseOnClick||!i||i.color!==n.turnColor)&&tge(n),e.cancelable!==!1&&(!e.touches||n.blockTouchScroll||i||o||ige(n,s)))e.preventDefault();else if(e.touches)return;const l=!!n.premovable.current,u=!!n.predroppable.current;n.stats.ctrlKey=e.ctrlKey,n.selected&&Vx(n,n.selected,r)?Fo(f=>UI(f,r),n):UI(n,r);const d=n.selected===r,h=V5(n,r);if(i&&h&&d&&Wme(n,r)){n.draggable.current={orig:r,piece:i,origPos:s,pos:s,started:n.draggable.autoDistance&&n.stats.dragged,element:h,previouslySelected:o,originTarget:e.target,keyHasChanged:!1},h.cgDragging=!0,h.classList.add("dragging");const f=n.dom.elements.ghost;f&&(f.className=`ghost ${i.color} ${i.role}`,ki(f,kh(t)(Ln(r),Ir(n))),Ox(f,!0)),Mx(n)}else l&&Io(n),u&&yo(n);n.dom.redraw()}function ige(n,e){const t=Ir(n),s=n.dom.bounds(),r=Math.pow(s.width/8,2);for(const i of n.pieces.keys()){const o=m5(i,t,s);if(id(o,e)<=r)return!0}return!1}function age(n,e,t,s){const r="a0";n.pieces.set(r,e),n.dom.redraw();const i=Cl(t);n.draggable.current={orig:r,piece:e,origPos:i,pos:i,started:!0,element:()=>V5(n,r),originTarget:t.target,newPiece:!0,force:!!s,keyHasChanged:!1},Mx(n)}function Mx(n){requestAnimationFrame(()=>{var e;const t=n.draggable.current;if(!t)return;!((e=n.animation.current)===null||e===void 0)&&e.plan.anims.has(t.orig)&&(n.animation.current=void 0);const s=n.pieces.get(t.orig);if(!s||!HI(s,t.piece))mf(n);else if(!t.started&&id(t.pos,t.origPos)>=Math.pow(n.draggable.distance,2)&&(t.started=!0),t.started){if(typeof t.element=="function"){const i=t.element();if(!i)return;i.cgDragging=!0,i.classList.add("dragging"),t.element=i}const r=n.dom.bounds();ki(t.element,[t.pos[0]-r.left-r.width/16,t.pos[1]-r.top-r.height/16]),t.keyHasChanged||(t.keyHasChanged=t.orig!==Ll(t.pos,Ir(n),r))}Mx(n)})}function oge(n,e){n.draggable.current&&(!e.touches||e.touches.length<2)&&(n.draggable.current.pos=Cl(e))}function lge(n,e){const t=n.draggable.current;if(!t)return;if(e.type==="touchend"&&e.cancelable!==!1&&e.preventDefault(),e.type==="touchend"&&t.originTarget!==e.target&&!t.newPiece){n.draggable.current=void 0;return}Io(n),yo(n);const s=Cl(e)||t.pos,r=Ll(s,Ir(n),n.dom.bounds());r&&t.started&&t.orig!==r?t.newPiece?S5(n,t.orig,r,t.force):(n.stats.ctrlKey=e.ctrlKey,n.movePhaseNichess?A5(n,t.orig,r)&&(n.stats.dragged=!0):T5(n,t.orig,r)&&(n.stats.dragged=!0)):t.newPiece?n.pieces.delete(t.orig):n.draggable.deleteOnDropOff&&!r&&(n.pieces.delete(t.orig),nr(n.events.change)),(t.orig===t.previouslySelected||t.keyHasChanged)&&(t.orig===r||!r)?Qs(n):n.selectable.enabled||Qs(n),R5(n),n.draggable.current=void 0,n.dom.redraw()}function mf(n){const e=n.draggable.current;e&&(e.newPiece&&n.pieces.delete(e.orig),n.draggable.current=void 0,Qs(n),R5(n),n.dom.redraw())}function R5(n){const e=n.dom.elements;e.ghost&&Ox(e.ghost,!1)}function V5(n,e){let t=n.dom.elements.board.firstChild;for(;t;){if(t.cgKey===e&&t.tagName==="PIECE")return t;t=t.nextSibling}}function uge(n,e){n.exploding={stage:1,keys:e},n.dom.redraw(),setTimeout(()=>{yD(n,2),setTimeout(()=>yD(n,void 0),120)},120)}function yD(n,e){n.exploding&&(e?n.exploding.stage=e:n.exploding=void 0,n.dom.redraw())}function cge(n,e){function t(){_me(n),e()}return{set(s){s.orientation&&s.orientation!==n.orientation&&t(),D5(n,s),(s.fen?Fo:Da)(r=>E5(r,s),n)},state:n,toggleOrientation:t,setPieces(s){Fo(r=>Dme(r,s),n)},selectSquare(s,r){s?Fo(i=>UI(i,s,r),n):n.selected&&(Qs(n),n.dom.redraw())},move(s,r){Fo(i=>N5(i,s,r),n)},newPiece(s,r){Fo(i=>Rx(i,s,r),n)},playPremove(){if(n.premovable.current){if(Fo(Bme,n))return!0;n.dom.redraw()}return!1},playPredrop(s){if(n.predroppable.current){const r=Hme(n,s);return n.dom.redraw(),r}return!1},cancelPremove(){Da(Io,n)},cancelPredrop(){Da(yo,n)},cancelMove(){Da(s=>{Fx(s),mf(s)},n)},stop(){Da(s=>{gD(s),mf(s)},n)},explode(s){uge(n,s)},setAutoShapes(s){Da(r=>r.drawable.autoShapes=s,n)},setShapes(s){Da(r=>r.drawable.shapes=s,n)},getKeyAtDomPos(s){return Ll(s,Ir(n),n.dom.bounds())},redrawAll:e,dragNewPiece(s,r,i){age(n,s,r,i)},destroy(){gD(n),n.dom.unbind&&n.dom.unbind(),n.dom.destroyed=!0}}}function dge(){return{pieces:_5("0|0-warrior-500,0-knight-150,0-assassin-110,0-mage-230,0-king-200,0-assassin-110,0-knight-150,0-warrior-500,0-pawn-300,0-pawn-300,0-pawn-300,0-pawn-300,0-pawn-300,0-pawn-300,0-pawn-300,0-pawn-300,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,empty,1-pawn-300,1-pawn-300,1-pawn-300,1-pawn-300,1-pawn-300,1-pawn-300,1-pawn-300,1-pawn-300,1-warrior-500,1-knight-150,1-assassin-110,1-mage-230,1-king-200,1-assassin-110,1-knight-150,1-warrior-500,"),orientation:"white",turnColor:"white",coordinates:!1,ranksPosition:"right",autoCastle:!0,viewOnly:!1,disableContextMenu:!1,addPieceZIndex:!1,blockTouchScroll:!1,pieceKey:!1,trustAllEvents:!1,highlight:{lastMove:!0,check:!0},animation:{enabled:!0,duration:200},movable:{free:!0,color:"both",showDests:!0,events:{},rookCastle:!0},premovable:{enabled:!0,showDests:!0,castle:!0,events:{}},predroppable:{enabled:!1,events:{}},draggable:{enabled:!0,distance:3,autoDistance:!0,showGhost:!0,deleteOnDropOff:!1},dropmode:{active:!1},selectable:{enabled:!0},stats:{dragged:!("ontouchstart"in window)},events:{},drawable:{enabled:!0,visible:!0,defaultSnapToValidMove:!0,eraseOnClick:!0,shapes:[],autoShapes:[],brushes:{green:{key:"g",color:"#15781B",opacity:1,lineWidth:10},red:{key:"r",color:"#882020",opacity:1,lineWidth:10},blue:{key:"b",color:"#003088",opacity:1,lineWidth:10},yellow:{key:"y",color:"#e68f00",opacity:1,lineWidth:10},paleBlue:{key:"pb",color:"#003088",opacity:.4,lineWidth:15},paleGreen:{key:"pg",color:"#15781B",opacity:.4,lineWidth:15},paleRed:{key:"pr",color:"#882020",opacity:.4,lineWidth:15},paleGrey:{key:"pgr",color:"#4a4a4a",opacity:.35,lineWidth:15},purple:{key:"purp",color:"#68217a",opacity:.65,lineWidth:10},pink:{key:"pink",color:"#ee2080",opacity:.5,lineWidth:10},hilite:{key:"hilite",color:"#fff",opacity:1,lineWidth:1}},prevSvgHash:""},hold:Tme(),movePhaseNichess:!0}}function hge(){const n=os("defs"),e=Js(os("filter"),{id:"cg-filter-blur"});return e.appendChild(Js(os("feGaussianBlur"),{stdDeviation:"0.022"})),n.appendChild(e),n}function pge(n,e,t){var s;const r=n.drawable,i=r.current,o=i&&i.mouseSq?i:void 0,l=new Map,u=n.dom.bounds(),d=r.autoShapes.filter(I=>!I.piece);for(const I of r.shapes.concat(d).concat(o?[o]:[])){if(!I.dest)continue;const y=(s=l.get(I.dest))!==null&&s!==void 0?s:new Set,N=If(gf(Ln(I.orig),n.orientation),u),w=If(gf(Ln(I.dest),n.orientation),u);y.add(qI(N,w)),l.set(I.dest,y)}const h=r.shapes.concat(d).map(I=>({shape:I,current:!1,hash:bD(I,GI(I.dest,l),!1,u)}));o&&h.push({shape:o,current:!0,hash:bD(o,GI(o.dest,l),!0,u)});const f=h.map(I=>I.hash).join(";");if(f===n.drawable.prevSvgHash)return;n.drawable.prevSvgHash=f;const m=e.querySelector("defs");fge(r,h,m),mge(h,e.querySelector("g"),t.querySelector("g"),I=>yge(n,I,r.brushes,l,u))}function fge(n,e,t){var s;const r=new Map;let i;for(const u of e.filter(d=>d.shape.dest&&d.shape.brush))i=P5(n.brushes[u.shape.brush],u.shape.modifiers),!((s=u.shape.modifiers)===null||s===void 0)&&s.hilite&&r.set("hilite",n.brushes.hilite),r.set(i.key,i);const o=new Set;let l=t.firstElementChild;for(;l;)o.add(l.getAttribute("cgKey")),l=l.nextElementSibling;for(const[u,d]of r.entries())o.has(u)||t.appendChild(Nge(d))}function mge(n,e,t,s){const r=new Map;for(const i of n)r.set(i.hash,!1);for(const i of[e,t]){const o=[];let l=i.firstElementChild,u;for(;l;)u=l.getAttribute("cgHash"),r.has(u)?r.set(u,!0):o.push(l),l=l.nextElementSibling;for(const d of o)i.removeChild(d)}for(const i of n.filter(o=>!r.get(o.hash)))for(const o of s(i))o.isCustom?t.appendChild(o.el):e.appendChild(o.el)}function bD({orig:n,dest:e,brush:t,piece:s,modifiers:r,customSvg:i,label:o},l,u,d){var h,f;return[d.width,d.height,u,n,e,t,l&&"-",s&&gge(s),r&&Ige(r),i&&`custom-${xD(i.html)},${(f=(h=i.center)===null||h===void 0?void 0:h[0])!==null&&f!==void 0?f:"o"}`,o&&`label-${xD(o.text)}`].filter(m=>m).join(",")}function gge(n){return[n.color,n.role,n.scale].filter(e=>e).join(",")}function Ige(n){return[n.lineWidth,n.hilite&&"*"].filter(e=>e).join(",")}function xD(n){let e=0;for(let t=0;t<n.length;t++)e=(e<<5)-e+n.charCodeAt(t)>>>0;return e.toString()}function yge(n,{shape:e,current:t,hash:s},r,i,o){var l,u;const d=If(gf(Ln(e.orig),n.orientation),o),h=e.dest?If(gf(Ln(e.dest),n.orientation),o):d,f=e.brush&&P5(r[e.brush],e.modifiers),m=i.get(e.dest),I=[];if(f){const y=Js(os("g"),{cgHash:s});I.push({el:y}),d[0]!==h[0]||d[1]!==h[1]?y.appendChild(xge(e,f,d,h,t,GI(e.dest,i))):y.appendChild(bge(r[e.brush],d,t,o))}if(e.label){const y=e.label;(l=y.fill)!==null&&l!==void 0||(y.fill=e.brush&&r[e.brush].color);const N=e.brush?void 0:"tr";I.push({el:wge(y,s,d,h,m,N),isCustom:!0})}if(e.customSvg){const y=(u=e.customSvg.center)!==null&&u!==void 0?u:"orig",[N,w]=y==="label"?z5(d,h,m).map(v=>v-.5):y==="dest"?h:d,T=Js(os("g"),{transform:`translate(${N},${w})`,cgHash:s});T.innerHTML=`<svg width="1" height="1" viewBox="0 0 100 100">${e.customSvg.html}</svg>`,I.push({el:T,isCustom:!0})}return I}function bge(n,e,t,s){const r=Age(),i=(s.width+s.height)/(4*Math.max(s.width,s.height));return Js(os("circle"),{stroke:n.color,"stroke-width":r[t?0:1],fill:"none",opacity:F5(n,t),cx:e[0],cy:e[1],r:i-r[1]/2})}function xge(n,e,t,s,r,i){var o;function l(h){var f;const m=Sge(i&&!r),I=s[0]-t[0],y=s[1]-t[1],N=Math.atan2(y,I),w=Math.cos(N)*m,T=Math.sin(N)*m;return Js(os("line"),{stroke:h?"white":e.color,"stroke-width":Tge(e,r)+(h?.04:0),"stroke-linecap":"round","marker-end":`url(#arrowhead-${h?"hilite":e.key})`,opacity:!((f=n.modifiers)===null||f===void 0)&&f.hilite?1:F5(e,r),x1:t[0],y1:t[1],x2:s[0]-w,y2:s[1]-T})}if(!(!((o=n.modifiers)===null||o===void 0)&&o.hilite))return l(!1);const u=os("g"),d=Js(os("g"),{filter:"url(#cg-filter-blur)"});return d.appendChild(vge(t,s)),d.appendChild(l(!0)),u.appendChild(d),u.appendChild(l(!1)),u}function Nge(n){const e=Js(os("marker"),{id:"arrowhead-"+n.key,orient:"auto",overflow:"visible",markerWidth:4,markerHeight:4,refX:n.key==="hilite"?1.86:2.05,refY:2});return e.appendChild(Js(os("path"),{d:"M0,0 V4 L3,2 Z",fill:n.color})),e.setAttribute("cgKey",n.key),e}function wge(n,e,t,s,r,i){var o;const u=.4*.75**n.text.length,d=z5(t,s,r),h=i==="tr"?.4:0,f=Js(os("g"),{transform:`translate(${d[0]+h},${d[1]-h})`,cgHash:e});f.appendChild(Js(os("circle"),{r:.4/2,"fill-opacity":i?1:.8,"stroke-opacity":i?1:.7,"stroke-width":.03,fill:(o=n.fill)!==null&&o!==void 0?o:"#666",stroke:"white"}));const m=Js(os("text"),{"font-size":u,"font-family":"Noto Sans","text-anchor":"middle",fill:"white",y:.13*.75**n.text.length});return m.innerHTML=n.text,f.appendChild(m),f}function gf(n,e){return e==="white"?n:[7-n[0],7-n[1]]}function GI(n,e){return(n&&e.has(n)&&e.get(n).size>1)===!0}function os(n){return document.createElementNS("http://www.w3.org/2000/svg",n)}function Js(n,e){for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&n.setAttribute(t,e[t]);return n}function P5(n,e){return e?{color:n.color,opacity:Math.round(n.opacity*10)/10,lineWidth:Math.round(e.lineWidth||n.lineWidth),key:[n.key,e.lineWidth].filter(t=>t).join("")}:n}function Age(){return[3/64,4/64]}function Tge(n,e){return(n.lineWidth||10)*(e?.85:1)/64}function F5(n,e){return(n.opacity||1)*(e?.9:1)}function Sge(n){return(n?20:10)/64}function If(n,e){const t=Math.min(1,e.width/e.height),s=Math.min(1,e.height/e.width);return[(n[0]-3.5)*t,(3.5-n[1])*s]}function vge(n,e){const t={from:[Math.floor(Math.min(n[0],e[0])),Math.floor(Math.min(n[1],e[1]))],to:[Math.ceil(Math.max(n[0],e[0])),Math.ceil(Math.max(n[1],e[1]))]};return Js(os("rect"),{x:t.from[0],y:t.from[1],width:t.to[0]-t.from[0],height:t.to[1]-t.from[1],fill:"none",stroke:"none"})}function qI(n,e,t=!0){const s=Math.atan2(e[1]-n[1],e[0]-n[0])+Math.PI;return t?(Math.round(s*8/Math.PI)+16)%16:s}function $ge(n,e){return Math.sqrt([n[0]-e[0],n[1]-e[1]].reduce((t,s)=>t+s*s,0))}function z5(n,e,t){let s=$ge(n,e);const r=qI(n,e,!1);if(t&&(s-=33/64,t.size>1)){s-=10/64;const i=qI(n,e);(t.has((i+1)%16)||t.has((i+15)%16))&&i&1&&(s-=.4)}return[n[0]-Math.cos(r)*s,n[1]-Math.sin(r)*s].map(i=>i+.5)}function _ge(n,e){n.innerHTML="",n.classList.add("cg-wrap");for(const u of wme)n.classList.toggle("orientation-"+u,e.orientation===u);n.classList.toggle("manipulable",!e.viewOnly);const t=ua("cg-container");n.appendChild(t);const s=ua("cg-board");t.appendChild(s);let r,i,o;if(e.drawable.visible&&(r=Js(os("svg"),{class:"cg-shapes",viewBox:"-4 -4 8 8",preserveAspectRatio:"xMidYMid slice"}),r.appendChild(hge()),r.appendChild(os("g")),i=Js(os("svg"),{class:"cg-custom-svgs",viewBox:"-3.5 -3.5 8 8",preserveAspectRatio:"xMidYMid slice"}),i.appendChild(os("g")),o=ua("cg-auto-pieces"),t.appendChild(r),t.appendChild(i),t.appendChild(o)),e.coordinates){const u=e.orientation==="black"?" black":"",d=e.ranksPosition==="left"?" left":"";t.appendChild(ND(Cx,"ranks"+u+d)),t.appendChild(ND(d5,"files"+u))}let l;return e.draggable.enabled&&e.draggable.showGhost&&(l=ua("piece","ghost"),Ox(l,!1),t.appendChild(l)),{board:s,container:t,wrap:n,ghost:l,svg:r,customSvg:i,autoPieces:o}}function ND(n,e){const t=ua("coords",e);let s;for(const r of n)s=ua("coord"),s.textContent=r,t.appendChild(s);return t}function Dge(n,e){if(!n.dropmode.active)return;Io(n),yo(n);const t=n.dropmode.piece;if(t){n.pieces.set("a0",t);const s=Cl(e),r=s&&Ll(s,Ir(n),n.dom.bounds());r&&S5(n,"a0",r)}n.dom.redraw()}function Ege(n,e){const t=n.dom.elements.board;if("ResizeObserver"in window&&new ResizeObserver(e).observe(n.dom.elements.wrap),(n.disableContextMenu||n.drawable.enabled)&&t.addEventListener("contextmenu",r=>r.preventDefault()),n.viewOnly)return;const s=Cge(n);t.addEventListener("touchstart",s,{passive:!1}),t.addEventListener("mousedown",s,{passive:!1})}function kge(n,e){const t=[];if("ResizeObserver"in window||t.push(fc(document.body,"chessground.resize",e)),!n.viewOnly){const s=wD(n,oge,Jme),r=wD(n,lge,ege);for(const o of["touchmove","mousemove"])t.push(fc(document,o,s));for(const o of["touchend","mouseup"])t.push(fc(document,o,r));const i=()=>n.dom.bounds.clear();t.push(fc(document,"scroll",i,{capture:!0,passive:!0})),t.push(fc(window,"resize",i,{passive:!0}))}return()=>t.forEach(s=>s())}function fc(n,e,t,s){return n.addEventListener(e,t,s),()=>n.removeEventListener(e,t,s)}const Cge=n=>e=>{n.draggable.current?mf(n):n.drawable.current?L5(n):e.shiftKey||f5(e)?n.drawable.enabled&&Qme(n,e):n.viewOnly||(n.dropmode.active?Dge(n,e):rge(n,e))},wD=(n,e,t)=>s=>{n.drawable.current?n.drawable.enabled&&t(n,s):n.viewOnly||e(n,s)};function Lge(n){const e=Ir(n),t=kh(n.dom.bounds()),s=n.dom.elements.board,r=n.pieces,i=n.animation.current,o=i?i.plan.anims:new Map,l=i?i.plan.fadings:new Map,u=n.draggable.current,d=Rge(n),h=new Set,f=new Set,m=new Map,I=new Map;let y,N,w,T,v,E,_,L,P,B;N=s.firstChild;const U=n.dom.elements.wrap.getBoundingClientRect(),Z=Math.floor(U.width*window.devicePixelRatio/8)*8/window.devicePixelRatio;for(s.style.cssText+=`font-size: ${Math.floor(Z/20)}px;`;N;){if(y=N.cgKey,M5(N)){if(w=r.get(y),w){let Y=N.firstChild;if(Y!=null&&Y.firstChild)Y.firstChild.nodeValue=w.healthPoints.toString();else{let ae=document.createElement("div");ae.style.cssText="position:absolute;margin: auto; text-align: center; top: 25%; color: #ffd700; text-shadow: 1px 1px 1px #bda622, 1px 2px 0.1em black;";const de=document.createTextNode(w.healthPoints.toString());ae.appendChild(de),N.appendChild(ae)}}if(v=o.get(y),E=l.get(y),T=N.cgPiece,N.cgDragging&&(!u||u.orig!==y)&&(N.classList.remove("dragging"),ki(N,t(Ln(y),e)),N.cgDragging=!1),!E&&N.cgFading&&(N.cgFading=!1,N.classList.remove("fading")),w){if(v&&N.cgAnimating&&T===mc(w)){const Y=Ln(y);Y[0]+=v[2],Y[1]+=v[3],N.classList.add("anim"),ki(N,t(Y,e))}else N.cgAnimating&&(N.cgAnimating=!1,N.classList.remove("anim"),ki(N,t(Ln(y),e)),n.addPieceZIndex&&(N.style.zIndex=D1(Ln(y),e)));T===mc(w)&&(!E||!N.cgFading)?h.add(y):E&&T===mc(E)?(N.classList.add("fading"),N.cgFading=!0):E1(m,T,N)}else E1(m,T,N)}else if(W5(N)){const Y=N.className;d.get(y)===Y?f.add(y):E1(I,Y,N)}N=N.nextSibling}for(const[Y,ae]of d)if(!f.has(Y)){P=I.get(ae),B=P&&P.pop();const de=t(Ln(Y),e);if(B)B.cgKey=Y,ki(B,de);else{const ce=ua("square",ae);ce.cgKey=Y,ki(ce,de),s.insertBefore(ce,s.firstChild)}}for(const[Y,ae]of r)if(v=o.get(Y),!h.has(Y))if(_=m.get(mc(ae)),L=_&&_.pop(),L){L.cgKey=Y,L.cgFading&&(L.classList.remove("fading"),L.cgFading=!1);const de=Ln(Y);n.addPieceZIndex&&(L.style.zIndex=D1(de,e)),v&&(L.cgAnimating=!0,L.classList.add("anim"),de[0]+=v[2],de[1]+=v[3]),ki(L,t(de,e))}else{const de=mc(ae),ce=ua("piece",de),Ie=Ln(Y);ce.cgPiece=de,ce.cgKey=Y,v&&(ce.cgAnimating=!0,Ie[0]+=v[2],Ie[1]+=v[3]),ki(ce,t(Ie,e)),n.addPieceZIndex&&(ce.style.zIndex=D1(Ie,e)),s.appendChild(ce)}for(const Y of m.values())TD(n,Y);for(const Y of I.values())TD(n,Y)}function Oge(n){const e=Ir(n),t=kh(n.dom.bounds()),s=n.dom.elements.wrap.getBoundingClientRect(),r=Math.floor(s.width*window.devicePixelRatio/8)*8/window.devicePixelRatio;let i=n.dom.elements.board.firstChild;for(;i;)(M5(i)&&!i.cgAnimating||W5(i))&&(i.style.cssText+=`font-size: ${Math.floor(r/20)}px;`,ki(i,t(Ln(i.cgKey),e))),i=i.nextSibling}function AD(n){var e,t;const s=n.dom.elements.wrap.getBoundingClientRect(),r=n.dom.elements.container,i=s.height/s.width,o=Math.floor(s.width*window.devicePixelRatio/8)*8/window.devicePixelRatio,l=o*i;r.style.width=o+"px",r.style.height=l+"px",n.dom.bounds.clear(),(e=n.addDimensionsCssVarsTo)===null||e===void 0||e.style.setProperty("--cg-width",o+"px"),(t=n.addDimensionsCssVarsTo)===null||t===void 0||t.style.setProperty("--cg-height",l+"px")}const M5=n=>n.tagName==="PIECE",W5=n=>n.tagName==="SQUARE";function TD(n,e){for(const t of e)n.dom.elements.board.removeChild(t)}function D1(n,e){const s=n[1];return`${e?3+7-s:3+s}`}const mc=n=>`${n.color} ${n.role}`;function Rge(n){var e,t,s;const r=new Map;if(n.lastMove&&n.highlight.lastMove)for(const l of n.lastMove)ta(r,l,"last-move");if(n.check&&n.highlight.check&&ta(r,n.check,"check"),n.selected&&(ta(r,n.selected,"selected"),n.movable.showDests)){const l=(e=n.movable.dests)===null||e===void 0?void 0:e.get(n.selected);if(l)for(const d of l)ta(r,d,"move-dest"+(n.pieces.has(d)?" oc":""));const u=(s=(t=n.premovable.customDests)===null||t===void 0?void 0:t.get(n.selected))!==null&&s!==void 0?s:n.premovable.dests;if(u)for(const d of u)ta(r,d,"premove-dest"+(n.pieces.has(d)?" oc":""))}const i=n.premovable.current;if(i)for(const l of i)ta(r,l,"current-premove");else n.predroppable.current&&ta(r,n.predroppable.current.key,"current-premove");const o=n.exploding;if(o)for(const l of o.keys)ta(r,l,"exploding"+o.stage);return n.highlight.custom&&n.highlight.custom.forEach((l,u)=>{ta(r,u,l)}),r}function ta(n,e,t){const s=n.get(e);s?n.set(e,`${s} ${t}`):n.set(e,t)}function E1(n,e,t){const s=n.get(e);s?s.push(t):n.set(e,[t])}function Vge(n,e,t){const s=new Map,r=[];for(const l of n)s.set(l.hash,!1);let i=e.firstElementChild,o;for(;i;)o=i.getAttribute("cgHash"),s.has(o)?s.set(o,!0):r.push(i),i=i.nextElementSibling;for(const l of r)e.removeChild(l);for(const l of n)s.get(l.hash)||e.appendChild(t(l))}function Pge(n,e){const s=n.drawable.autoShapes.filter(r=>r.piece).map(r=>({shape:r,hash:Mge(r),current:!1}));Vge(s,e,r=>zge(n,r,n.dom.bounds()))}function Fge(n){var e;const t=Ir(n),s=kh(n.dom.bounds());let r=(e=n.dom.elements.autoPieces)===null||e===void 0?void 0:e.firstChild;for(;r;)p5(r,s(Ln(r.cgKey),t),r.cgScale),r=r.nextSibling}function zge(n,{shape:e,hash:t},s){var r,i,o;const l=e.orig,u=(r=e.piece)===null||r===void 0?void 0:r.role,d=(i=e.piece)===null||i===void 0?void 0:i.color,h=(o=e.piece)===null||o===void 0?void 0:o.scale,f=ua("piece",`${u} ${d}`);return f.setAttribute("cgHash",t),f.cgKey=l,f.cgScale=h,p5(f,kh(s)(Ln(l),Ir(n)),h),f}const Mge=n=>{var e,t,s;return[n.orig,(e=n.piece)===null||e===void 0?void 0:e.role,(t=n.piece)===null||t===void 0?void 0:t.color,(s=n.piece)===null||s===void 0?void 0:s.scale].join(",")};function Wge(n,e){const t=dge();E5(t,e||{});function s(){const r="dom"in t?t.dom.unbind:void 0,i=_ge(n,t),o=Ame(()=>i.board.getBoundingClientRect()),l=h=>{Lge(d),i.autoPieces&&Pge(d,i.autoPieces),!h&&i.svg&&pge(d,i.svg,i.customSvg)},u=()=>{AD(d),Oge(d),i.autoPieces&&Fge(d)},d=t;return d.dom={elements:i,bounds:o,redraw:Bge(l),redrawNow:l,unbind:r},d.drawable.prevSvgHash="",AD(d),l(!1),Ege(d,u),r||(d.dom.unbind=kge(d,u)),d.events.insert&&d.events.insert(i),d}return cge(s(),s)}function Bge(n){let e=!1;return()=>{e||(e=!0,requestAnimationFrame(()=>{n(),e=!1}))}}class Hge{constructor(e,t,s,r){Mt(this,"game");Mt(this,"board");Mt(this,"boardState");Mt(this,"props");Mt(this,"emit");Mt(this,"aiAgent");Mt(this,"debugMsg");this.boardState=t,this.props=s,this.emit=r,this.game=new Cz,this.board=Wge(e),this.resetBoard(),this.aiAgent=new Nme,this.debugMsg=zc("")}updateGameState({updateFen:e=!0}={}){this.boardState.historyViewerState.isEnabled||(e&&this.board.set({fen:this.game.boardToString()}),this.board.state.turnColor=this.getTurnColor(),this.board.state.movable.free?(this.board.state.movable.color="both",this.board.state.movable.dests=new Map):(this.board.state.movable.color=this.props.playerColor||this.board.state.turnColor,this.board.state.movable.dests=T_(this.game))),this.emitEvents()}forbidMoves(){this.board.state.movable.color=void 0}emitEvents(){this.game.isGameOver()&&this.emit("checkmate",this.board.state.turnColor)}async changeTurn(e,t,s){let r;this.move({from:e,to:t,promotion:r})}resetBoard(){this.setConfig(this.props.boardConfig,!0)}undoLastMove(){}toggleOrientation(){this.board.toggleOrientation()}hideMoves(){this.boardState.showThreats=!1,this.board.setShapes([])}drawMove(e,t,s){this.board.setShapes([{orig:e,dest:t,brush:s}])}async move(e){if(typeof e=="object"){let s=x_(e.from),r=x_(e.to);if(this.game.makeAction(s,r),this.game.isGameOver())return this.game.reset(),this.resetBoard(),A_(this.board,this.game),!0;A_(this.board,this.game),this.emit("move",e),this.updateGameState({updateFen:!1});var t=this.game.boardToString();return this.debugMsg.value="boardToString: "+t+`
`,this.debugMsg.value+=`dump:
`+this.game.dump()+`
`,this.debugMsg.value+="gameOver: "+this.game.isGameOver()+`
`,!0}else return!1}getTurnColor(){return this.game.currentPlayer()==Re.PLAYER_1?"white":"black"}getPossibleMoves(){return T_(this.game)}getCurrentTurnNumber(){return this.game.moveNumber()}getCurrentPlyNumber(){return 2*this.getCurrentTurnNumber()-(this.getTurnColor()==="black"?1:2)}getLastMove(){}getHistory(e=!1){return[]}getFen(){return this.game.boardToString()}getBoardPosition(){return[]}getPgn(){return this.game.boardToString()}getIsGameOver(){return this.game.isGameOver()}setPosition(e){this.game.boardFromString(e),this.boardState.historyViewerState={isEnabled:!1},this.updateGameState()}putPiece(e,t){return!1}removePiece(e){}clearBoard(){}setShapes(e){this.board.setShapes(e)}loadPgn(e){}getPgnInfo(){return{}}destroy(){}setPgnInfo(e){return{White:"Deep Blue",Black:"Kasparov, Garry"}}setConfig(e,t=!1){var i;if(t&&(e=ZE(Pz,e),this.board.state.selected=void 0),(i=e.movable)!=null&&i.events&&"after"in e.movable.events){const o=e.movable.events.after;e.movable.events.after=o?async(...l)=>{await this.changeTurn(...l),o(...l)}:this.changeTurn.bind(this)}const{fen:s,...r}=e;this.board.set(r),s&&this.setPosition(s),this.board.redrawAll()}viewHistory(e){}stopViewingHistory(){this.boardState.historyViewerState.isEnabled&&this.viewHistory(this.getCurrentPlyNumber())}viewStart(){this.viewHistory(0)}viewNext(){this.boardState.historyViewerState.isEnabled&&this.viewHistory(this.boardState.historyViewerState.plyViewing+1)}viewPrevious(){const e=this.boardState.historyViewerState.isEnabled?this.boardState.historyViewerState.plyViewing:this.getCurrentPlyNumber();this.viewHistory(e-1)}}const Uge={class:"main-board"},Gge={class:"debug"},qge=Il({__name:"TheChessboard",props:{boardConfig:{default:()=>({})},playerColor:{},reactiveConfig:{type:Boolean,default:!1}},emits:["boardCreated","check","checkmate","stalemate","draw","promotion","move"],setup(n,{emit:e}){const t=n,s=e,r=zc(null),i=zc(""),o=hu({showThreats:!1,promotionDialogState:{isEnabled:!1},historyViewerState:{isEnabled:!1}});return TE(()=>{if(r.value==null)throw new Error("vue3-chessboard: Failed to mount board.");const l=new Hge(r.value,o,t,s);if(i.value=l.debugMsg.value,ru(l.debugMsg,u=>{i.value=u}),s("boardCreated",l),t.reactiveConfig){let u=Vp(t.boardConfig);ru(hu(t.boardConfig),d=>{l.setConfig(QE(u,d)),u=Vp(d)})}}),(l,u)=>(qi(),Jo("section",{class:Du(["main-wrap",{disabledBoard:o.promotionDialogState.isEnabled,viewingHistory:o.historyViewerState.isEnabled}])},[Cs("div",Uge,[o.promotionDialogState.isEnabled?(qi(),hy(Dz,{key:0,state:o.promotionDialogState,onPromotionSelected:u[0]||(u[0]=d=>o.promotionDialogState={isEnabled:!1})},null,8,["state"])):UF("",!0),Cs("div",{ref_key:"boardElement",ref:r},null,512)]),Cs("div",Gge,YD(i.value),1)],2))}});const Wx=(n,e)=>{const t=n.__vccOpts||n;for(const[s,r]of e)t[s]=r;return t},Kge={class:"menu-navbar"},jge=Il({__name:"Menu",setup(n){const e=zc(!1),t=()=>{e.value=!e.value};return(s,r)=>{const i=$E("router-link");return qi(),Jo("nav",Kge,[Cs("div",{class:"menu-toggle",onClick:t},r[0]||(r[0]=[Cs("span",null,null,-1),Cs("span",null,null,-1),Cs("span",null,null,-1)])),Cs("ul",{class:Du({"show-menu":e.value})},[Cs("li",null,[rs(i,{to:"/nichess2"},{default:gp(()=>r[1]||(r[1]=[xp("Game")])),_:1})]),Cs("li",null,[rs(i,{to:"/nichess2/rules"},{default:gp(()=>r[2]||(r[2]=[xp("Rules")])),_:1})]),Cs("li",null,[rs(i,{to:"/nichess2/about"},{default:gp(()=>r[3]||(r[3]=[xp("About")])),_:1})])],2)])}}});const Yge=Wx(jge,[["__scopeId","data-v-6a5957ba"]]),Xge=Il({__name:"Game",setup(n){let e;const t={coordinates:!0},s=void 0;return(r,i)=>(qi(),hy(ca(qge),{class:"chessboard-container","board-config":t,"player-color":ca(s),onBoardCreated:i[0]||(i[0]=o=>Ss(e)?e.value=o:e=o)},null,8,["player-color"]))}});const Zge={},Qge={class:"content"};function Jge(n,e){return qi(),Jo("div",Qge,e[0]||(e[0]=[HF("<h3 data-v-f6177069>Pawn</h3><p data-v-f6177069>Health points: 40</p><p data-v-f6177069>Ability points: 120</p><p data-v-f6177069>The pawn moves forward one square, except when attacking a piece diagonally. It can move two squares forward from its starting position. Pawns are the only pieces that attack differently from how they move.</p><p data-v-f6177069>When a pawn reaches the last row, it transforms into a pirate.</p><p data-v-f6177069>Note: Unlike in chess, there is no en passant rule in this game.</p><br data-v-f6177069><h3 data-v-f6177069>Knight</h3><p data-v-f6177069>Health points: 120</p><p data-v-f6177069>Ability points: 10</p><p data-v-f6177069>The knight moves in an L-shape: two squares in one direction and then one square perpendicular to that direction. Knights are the only pieces that can jump over other pieces.</p><h3 data-v-f6177069>Knight-Pawn ability</h3><p data-v-f6177069>When placed 1 square behind an allied pawn, if the square in front of the pawn is occupied by an enemy piece, knight can throw the allied pawn and destroy both pieces.</p><br data-v-f6177069><h3 data-v-f6177069>Maenad</h3><p data-v-f6177069>Health points: 60</p><p data-v-f6177069>Ability points: 40</p><p data-v-f6177069>The maenad moves diagonally any number of squares and also one square in any other direction.</p><br data-v-f6177069><h3 data-v-f6177069>Pirate</h3><p data-v-f6177069>Health points: 60</p><p data-v-f6177069>Ability points: 60</p><p data-v-f6177069>The pirate moves horizontally or vertically any number of squares. Pirates can move across the board without jumping over other pieces.</p><h3 data-v-f6177069>Pirate-Pirate ability</h3><p data-v-f6177069>When placed 1 square horizontally or vertically to an allied pirate, pirate can throw the allied pirate and destroy the first enemy piece in its path. Neighbouring enemy pieces will take 30 damage.</p><br data-v-f6177069><h3 data-v-f6177069>Queen</h3><p data-v-f6177069>Health points: 20</p><p data-v-f6177069>Ability points: 120</p><p data-v-f6177069>The queen moves any number of squares in any direction: horizontally, vertically, or diagonally. Queens have the most versatile movement of all the pieces.</p><h3 data-v-f6177069>Queen-Maenad ability</h3><p data-v-f6177069>When placed 1 square diagonally to an allied maenad, queen can throw the maenad and destroy the first enemy piece in its path. Neighbouring enemy pieces will take 30 damage.</p><br data-v-f6177069><h3 data-v-f6177069>King</h3><p data-v-f6177069>Health points: 10</p><p data-v-f6177069>Ability points: 120</p><p data-v-f6177069>The king moves one square in any direction: horizontally, vertically, or diagonally. The game is over when the king loses its health points.</p><h4 data-v-f6177069>Castling</h4><p data-v-f6177069>Castling is a special move that allows the king to move two squares horizontally towards the pirate and then moving the pirate to the square that the king passed over. The king and the pirate must be in their original positions, and there must be no pieces between them.</p><p data-v-f6177069>Note: Unlike in chess, it does not matter whether the square the king passes over is attacked by an enemy piece.</p><p data-v-f6177069>Note: Unlike in chess, it does not matter whether the pieces have moved before.</p><br data-v-f6177069>",42)]))}const e0e=Wx(Zge,[["render",Jge],["__scopeId","data-v-f6177069"]]);const t0e={},n0e={class:"content"};function s0e(n,e){return qi(),Jo("div",n0e,e[0]||(e[0]=[Cs("h3",null,"Source",-1),Cs("a",{href:"https://github.com/nichess-game",target:"_blank",rel:"noopener noreferrer",style:{color:"lightblue"}},"https://github.com/nichess-game",-1)]))}const r0e=Wx(t0e,[["render",s0e],["__scopeId","data-v-b7ac19db"]]),i0e=Il({__name:"App",setup(n){return(e,t)=>{const s=$E("router-view");return qi(),Jo(ci,null,[rs(ca(Yge)),rs(s)],64)}}});/*!
  * vue-router v4.5.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */const Yl=typeof document<"u";function B5(n){return typeof n=="object"||"displayName"in n||"props"in n||"__vccOpts"in n}function a0e(n){return n.__esModule||n[Symbol.toStringTag]==="Module"||n.default&&B5(n.default)}const an=Object.assign;function k1(n,e){const t={};for(const s in e){const r=e[s];t[s]=wi(r)?r.map(n):n(r)}return t}const Rc=()=>{},wi=Array.isArray,H5=/#/g,o0e=/&/g,l0e=/\//g,u0e=/=/g,c0e=/\?/g,U5=/\+/g,d0e=/%5B/g,h0e=/%5D/g,G5=/%5E/g,p0e=/%60/g,q5=/%7B/g,f0e=/%7C/g,K5=/%7D/g,m0e=/%20/g;function Bx(n){return encodeURI(""+n).replace(f0e,"|").replace(d0e,"[").replace(h0e,"]")}function g0e(n){return Bx(n).replace(q5,"{").replace(K5,"}").replace(G5,"^")}function KI(n){return Bx(n).replace(U5,"%2B").replace(m0e,"+").replace(H5,"%23").replace(o0e,"%26").replace(p0e,"`").replace(q5,"{").replace(K5,"}").replace(G5,"^")}function I0e(n){return KI(n).replace(u0e,"%3D")}function y0e(n){return Bx(n).replace(H5,"%23").replace(c0e,"%3F")}function b0e(n){return n==null?"":y0e(n).replace(l0e,"%2F")}function ad(n){try{return decodeURIComponent(""+n)}catch{}return""+n}const x0e=/\/$/,N0e=n=>n.replace(x0e,"");function C1(n,e,t="/"){let s,r={},i="",o="";const l=e.indexOf("#");let u=e.indexOf("?");return l<u&&l>=0&&(u=-1),u>-1&&(s=e.slice(0,u),i=e.slice(u+1,l>-1?l:e.length),r=n(i)),l>-1&&(s=s||e.slice(0,l),o=e.slice(l,e.length)),s=S0e(s??e,t),{fullPath:s+(i&&"?")+i+o,path:s,query:r,hash:ad(o)}}function w0e(n,e){const t=e.query?n(e.query):"";return e.path+(t&&"?")+t+(e.hash||"")}function SD(n,e){return!e||!n.toLowerCase().startsWith(e.toLowerCase())?n:n.slice(e.length)||"/"}function A0e(n,e,t){const s=e.matched.length-1,r=t.matched.length-1;return s>-1&&s===r&&$u(e.matched[s],t.matched[r])&&j5(e.params,t.params)&&n(e.query)===n(t.query)&&e.hash===t.hash}function $u(n,e){return(n.aliasOf||n)===(e.aliasOf||e)}function j5(n,e){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(const t in n)if(!T0e(n[t],e[t]))return!1;return!0}function T0e(n,e){return wi(n)?vD(n,e):wi(e)?vD(e,n):n===e}function vD(n,e){return wi(e)?n.length===e.length&&n.every((t,s)=>t===e[s]):n.length===1&&n[0]===e}function S0e(n,e){if(n.startsWith("/"))return n;if(!n)return e;const t=e.split("/"),s=n.split("/"),r=s[s.length-1];(r===".."||r===".")&&s.push("");let i=t.length-1,o,l;for(o=0;o<s.length;o++)if(l=s[o],l!==".")if(l==="..")i>1&&i--;else break;return t.slice(0,i).join("/")+"/"+s.slice(o).join("/")}const _a={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0};var od;(function(n){n.pop="pop",n.push="push"})(od||(od={}));var Vc;(function(n){n.back="back",n.forward="forward",n.unknown=""})(Vc||(Vc={}));function v0e(n){if(!n)if(Yl){const e=document.querySelector("base");n=e&&e.getAttribute("href")||"/",n=n.replace(/^\w+:\/\/[^\/]+/,"")}else n="/";return n[0]!=="/"&&n[0]!=="#"&&(n="/"+n),N0e(n)}const $0e=/^[^#]+#/;function _0e(n,e){return n.replace($0e,"#")+e}function D0e(n,e){const t=document.documentElement.getBoundingClientRect(),s=n.getBoundingClientRect();return{behavior:e.behavior,left:s.left-t.left-(e.left||0),top:s.top-t.top-(e.top||0)}}const wg=()=>({left:window.scrollX,top:window.scrollY});function E0e(n){let e;if("el"in n){const t=n.el,s=typeof t=="string"&&t.startsWith("#"),r=typeof t=="string"?s?document.getElementById(t.slice(1)):document.querySelector(t):t;if(!r)return;e=D0e(r,n)}else e=n;"scrollBehavior"in document.documentElement.style?window.scrollTo(e):window.scrollTo(e.left!=null?e.left:window.scrollX,e.top!=null?e.top:window.scrollY)}function $D(n,e){return(history.state?history.state.position-e:-1)+n}const jI=new Map;function k0e(n,e){jI.set(n,e)}function C0e(n){const e=jI.get(n);return jI.delete(n),e}let L0e=()=>location.protocol+"//"+location.host;function Y5(n,e){const{pathname:t,search:s,hash:r}=e,i=n.indexOf("#");if(i>-1){let l=r.includes(n.slice(i))?n.slice(i).length:1,u=r.slice(l);return u[0]!=="/"&&(u="/"+u),SD(u,"")}return SD(t,n)+s+r}function O0e(n,e,t,s){let r=[],i=[],o=null;const l=({state:m})=>{const I=Y5(n,location),y=t.value,N=e.value;let w=0;if(m){if(t.value=I,e.value=m,o&&o===y){o=null;return}w=N?m.position-N.position:0}else s(I);r.forEach(T=>{T(t.value,y,{delta:w,type:od.pop,direction:w?w>0?Vc.forward:Vc.back:Vc.unknown})})};function u(){o=t.value}function d(m){r.push(m);const I=()=>{const y=r.indexOf(m);y>-1&&r.splice(y,1)};return i.push(I),I}function h(){const{history:m}=window;m.state&&m.replaceState(an({},m.state,{scroll:wg()}),"")}function f(){for(const m of i)m();i=[],window.removeEventListener("popstate",l),window.removeEventListener("beforeunload",h)}return window.addEventListener("popstate",l),window.addEventListener("beforeunload",h,{passive:!0}),{pauseListeners:u,listen:d,destroy:f}}function _D(n,e,t,s=!1,r=!1){return{back:n,current:e,forward:t,replaced:s,position:window.history.length,scroll:r?wg():null}}function R0e(n){const{history:e,location:t}=window,s={value:Y5(n,t)},r={value:e.state};r.value||i(s.value,{back:null,current:s.value,forward:null,position:e.length-1,replaced:!0,scroll:null},!0);function i(u,d,h){const f=n.indexOf("#"),m=f>-1?(t.host&&document.querySelector("base")?n:n.slice(f))+u:L0e()+n+u;try{e[h?"replaceState":"pushState"](d,"",m),r.value=d}catch(I){console.error(I),t[h?"replace":"assign"](m)}}function o(u,d){const h=an({},e.state,_D(r.value.back,u,r.value.forward,!0),d,{position:r.value.position});i(u,h,!0),s.value=u}function l(u,d){const h=an({},r.value,e.state,{forward:u,scroll:wg()});i(h.current,h,!0);const f=an({},_D(s.value,u,null),{position:h.position+1},d);i(u,f,!1),s.value=u}return{location:s,state:r,push:l,replace:o}}function V0e(n){n=v0e(n);const e=R0e(n),t=O0e(n,e.state,e.location,e.replace);function s(i,o=!0){o||t.pauseListeners(),history.go(i)}const r=an({location:"",base:n,go:s,createHref:_0e.bind(null,n)},e,t);return Object.defineProperty(r,"location",{enumerable:!0,get:()=>e.location.value}),Object.defineProperty(r,"state",{enumerable:!0,get:()=>e.state.value}),r}function P0e(n){return typeof n=="string"||n&&typeof n=="object"}function X5(n){return typeof n=="string"||typeof n=="symbol"}const Z5=Symbol("");var DD;(function(n){n[n.aborted=4]="aborted",n[n.cancelled=8]="cancelled",n[n.duplicated=16]="duplicated"})(DD||(DD={}));function _u(n,e){return an(new Error,{type:n,[Z5]:!0},e)}function na(n,e){return n instanceof Error&&Z5 in n&&(e==null||!!(n.type&e))}const ED="[^/]+?",F0e={sensitive:!1,strict:!1,start:!0,end:!0},z0e=/[.+*?^${}()[\]/\\]/g;function M0e(n,e){const t=an({},F0e,e),s=[];let r=t.start?"^":"";const i=[];for(const d of n){const h=d.length?[]:[90];t.strict&&!d.length&&(r+="/");for(let f=0;f<d.length;f++){const m=d[f];let I=40+(t.sensitive?.25:0);if(m.type===0)f||(r+="/"),r+=m.value.replace(z0e,"\\$&"),I+=40;else if(m.type===1){const{value:y,repeatable:N,optional:w,regexp:T}=m;i.push({name:y,repeatable:N,optional:w});const v=T||ED;if(v!==ED){I+=10;try{new RegExp(`(${v})`)}catch(_){throw new Error(`Invalid custom RegExp for param "${y}" (${v}): `+_.message)}}let E=N?`((?:${v})(?:/(?:${v}))*)`:`(${v})`;f||(E=w&&d.length<2?`(?:/${E})`:"/"+E),w&&(E+="?"),r+=E,I+=20,w&&(I+=-8),N&&(I+=-20),v===".*"&&(I+=-50)}h.push(I)}s.push(h)}if(t.strict&&t.end){const d=s.length-1;s[d][s[d].length-1]+=.7000000000000001}t.strict||(r+="/?"),t.end?r+="$":t.strict&&!r.endsWith("/")&&(r+="(?:/|$)");const o=new RegExp(r,t.sensitive?"":"i");function l(d){const h=d.match(o),f={};if(!h)return null;for(let m=1;m<h.length;m++){const I=h[m]||"",y=i[m-1];f[y.name]=I&&y.repeatable?I.split("/"):I}return f}function u(d){let h="",f=!1;for(const m of n){(!f||!h.endsWith("/"))&&(h+="/"),f=!1;for(const I of m)if(I.type===0)h+=I.value;else if(I.type===1){const{value:y,repeatable:N,optional:w}=I,T=y in d?d[y]:"";if(wi(T)&&!N)throw new Error(`Provided param "${y}" is an array but it is not repeatable (* or + modifiers)`);const v=wi(T)?T.join("/"):T;if(!v)if(w)m.length<2&&(h.endsWith("/")?h=h.slice(0,-1):f=!0);else throw new Error(`Missing required param "${y}"`);h+=v}}return h||"/"}return{re:o,score:s,keys:i,parse:l,stringify:u}}function W0e(n,e){let t=0;for(;t<n.length&&t<e.length;){const s=e[t]-n[t];if(s)return s;t++}return n.length<e.length?n.length===1&&n[0]===40+40?-1:1:n.length>e.length?e.length===1&&e[0]===40+40?1:-1:0}function Q5(n,e){let t=0;const s=n.score,r=e.score;for(;t<s.length&&t<r.length;){const i=W0e(s[t],r[t]);if(i)return i;t++}if(Math.abs(r.length-s.length)===1){if(kD(s))return 1;if(kD(r))return-1}return r.length-s.length}function kD(n){const e=n[n.length-1];return n.length>0&&e[e.length-1]<0}const B0e={type:0,value:""},H0e=/[a-zA-Z0-9_]/;function U0e(n){if(!n)return[[]];if(n==="/")return[[B0e]];if(!n.startsWith("/"))throw new Error(`Invalid path "${n}"`);function e(I){throw new Error(`ERR (${t})/"${d}": ${I}`)}let t=0,s=t;const r=[];let i;function o(){i&&r.push(i),i=[]}let l=0,u,d="",h="";function f(){d&&(t===0?i.push({type:0,value:d}):t===1||t===2||t===3?(i.length>1&&(u==="*"||u==="+")&&e(`A repeatable param (${d}) must be alone in its segment. eg: '/:ids+.`),i.push({type:1,value:d,regexp:h,repeatable:u==="*"||u==="+",optional:u==="*"||u==="?"})):e("Invalid state to consume buffer"),d="")}function m(){d+=u}for(;l<n.length;){if(u=n[l++],u==="\\"&&t!==2){s=t,t=4;continue}switch(t){case 0:u==="/"?(d&&f(),o()):u===":"?(f(),t=1):m();break;case 4:m(),t=s;break;case 1:u==="("?t=2:H0e.test(u)?m():(f(),t=0,u!=="*"&&u!=="?"&&u!=="+"&&l--);break;case 2:u===")"?h[h.length-1]=="\\"?h=h.slice(0,-1)+u:t=3:h+=u;break;case 3:f(),t=0,u!=="*"&&u!=="?"&&u!=="+"&&l--,h="";break;default:e("Unknown state");break}}return t===2&&e(`Unfinished custom RegExp for param "${d}"`),f(),o(),r}function G0e(n,e,t){const s=M0e(U0e(n.path),t),r=an(s,{record:n,parent:e,children:[],alias:[]});return e&&!r.record.aliasOf==!e.record.aliasOf&&e.children.push(r),r}function q0e(n,e){const t=[],s=new Map;e=RD({strict:!1,end:!0,sensitive:!1},e);function r(f){return s.get(f)}function i(f,m,I){const y=!I,N=LD(f);N.aliasOf=I&&I.record;const w=RD(e,f),T=[N];if("alias"in f){const _=typeof f.alias=="string"?[f.alias]:f.alias;for(const L of _)T.push(LD(an({},N,{components:I?I.record.components:N.components,path:L,aliasOf:I?I.record:N})))}let v,E;for(const _ of T){const{path:L}=_;if(m&&L[0]!=="/"){const P=m.record.path,B=P[P.length-1]==="/"?"":"/";_.path=m.record.path+(L&&B+L)}if(v=G0e(_,m,w),I?I.alias.push(v):(E=E||v,E!==v&&E.alias.push(v),y&&f.name&&!OD(v)&&o(f.name)),J5(v)&&u(v),N.children){const P=N.children;for(let B=0;B<P.length;B++)i(P[B],v,I&&I.children[B])}I=I||v}return E?()=>{o(E)}:Rc}function o(f){if(X5(f)){const m=s.get(f);m&&(s.delete(f),t.splice(t.indexOf(m),1),m.children.forEach(o),m.alias.forEach(o))}else{const m=t.indexOf(f);m>-1&&(t.splice(m,1),f.record.name&&s.delete(f.record.name),f.children.forEach(o),f.alias.forEach(o))}}function l(){return t}function u(f){const m=Y0e(f,t);t.splice(m,0,f),f.record.name&&!OD(f)&&s.set(f.record.name,f)}function d(f,m){let I,y={},N,w;if("name"in f&&f.name){if(I=s.get(f.name),!I)throw _u(1,{location:f});w=I.record.name,y=an(CD(m.params,I.keys.filter(E=>!E.optional).concat(I.parent?I.parent.keys.filter(E=>E.optional):[]).map(E=>E.name)),f.params&&CD(f.params,I.keys.map(E=>E.name))),N=I.stringify(y)}else if(f.path!=null)N=f.path,I=t.find(E=>E.re.test(N)),I&&(y=I.parse(N),w=I.record.name);else{if(I=m.name?s.get(m.name):t.find(E=>E.re.test(m.path)),!I)throw _u(1,{location:f,currentLocation:m});w=I.record.name,y=an({},m.params,f.params),N=I.stringify(y)}const T=[];let v=I;for(;v;)T.unshift(v.record),v=v.parent;return{name:w,path:N,params:y,matched:T,meta:j0e(T)}}n.forEach(f=>i(f));function h(){t.length=0,s.clear()}return{addRoute:i,resolve:d,removeRoute:o,clearRoutes:h,getRoutes:l,getRecordMatcher:r}}function CD(n,e){const t={};for(const s of e)s in n&&(t[s]=n[s]);return t}function LD(n){const e={path:n.path,redirect:n.redirect,name:n.name,meta:n.meta||{},aliasOf:n.aliasOf,beforeEnter:n.beforeEnter,props:K0e(n),children:n.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in n?n.components||null:n.component&&{default:n.component}};return Object.defineProperty(e,"mods",{value:{}}),e}function K0e(n){const e={},t=n.props||!1;if("component"in n)e.default=t;else for(const s in n.components)e[s]=typeof t=="object"?t[s]:t;return e}function OD(n){for(;n;){if(n.record.aliasOf)return!0;n=n.parent}return!1}function j0e(n){return n.reduce((e,t)=>an(e,t.meta),{})}function RD(n,e){const t={};for(const s in n)t[s]=s in e?e[s]:n[s];return t}function Y0e(n,e){let t=0,s=e.length;for(;t!==s;){const i=t+s>>1;Q5(n,e[i])<0?s=i:t=i+1}const r=X0e(n);return r&&(s=e.lastIndexOf(r,s-1)),s}function X0e(n){let e=n;for(;e=e.parent;)if(J5(e)&&Q5(n,e)===0)return e}function J5({record:n}){return!!(n.name||n.components&&Object.keys(n.components).length||n.redirect)}function Z0e(n){const e={};if(n===""||n==="?")return e;const s=(n[0]==="?"?n.slice(1):n).split("&");for(let r=0;r<s.length;++r){const i=s[r].replace(U5," "),o=i.indexOf("="),l=ad(o<0?i:i.slice(0,o)),u=o<0?null:ad(i.slice(o+1));if(l in e){let d=e[l];wi(d)||(d=e[l]=[d]),d.push(u)}else e[l]=u}return e}function VD(n){let e="";for(let t in n){const s=n[t];if(t=I0e(t),s==null){s!==void 0&&(e+=(e.length?"&":"")+t);continue}(wi(s)?s.map(i=>i&&KI(i)):[s&&KI(s)]).forEach(i=>{i!==void 0&&(e+=(e.length?"&":"")+t,i!=null&&(e+="="+i))})}return e}function Q0e(n){const e={};for(const t in n){const s=n[t];s!==void 0&&(e[t]=wi(s)?s.map(r=>r==null?null:""+r):s==null?s:""+s)}return e}const J0e=Symbol(""),PD=Symbol(""),Hx=Symbol(""),eP=Symbol(""),YI=Symbol("");function gc(){let n=[];function e(s){return n.push(s),()=>{const r=n.indexOf(s);r>-1&&n.splice(r,1)}}function t(){n=[]}return{add:e,list:()=>n.slice(),reset:t}}function Oa(n,e,t,s,r,i=o=>o()){const o=s&&(s.enterCallbacks[r]=s.enterCallbacks[r]||[]);return()=>new Promise((l,u)=>{const d=m=>{m===!1?u(_u(4,{from:t,to:e})):m instanceof Error?u(m):P0e(m)?u(_u(2,{from:e,to:m})):(o&&s.enterCallbacks[r]===o&&typeof m=="function"&&o.push(m),l())},h=i(()=>n.call(s&&s.instances[r],e,t,d));let f=Promise.resolve(h);n.length<3&&(f=f.then(d)),f.catch(m=>u(m))})}function L1(n,e,t,s,r=i=>i()){const i=[];for(const o of n)for(const l in o.components){let u=o.components[l];if(!(e!=="beforeRouteEnter"&&!o.instances[l]))if(B5(u)){const h=(u.__vccOpts||u)[e];h&&i.push(Oa(h,t,s,o,l,r))}else{let d=u();i.push(()=>d.then(h=>{if(!h)throw new Error(`Couldn't resolve component "${l}" at "${o.path}"`);const f=a0e(h)?h.default:h;o.mods[l]=h,o.components[l]=f;const I=(f.__vccOpts||f)[e];return I&&Oa(I,t,s,o,l,r)()}))}}return i}function FD(n){const e=da(Hx),t=da(eP),s=pi(()=>{const u=ca(n.to);return e.resolve(u)}),r=pi(()=>{const{matched:u}=s.value,{length:d}=u,h=u[d-1],f=t.matched;if(!h||!f.length)return-1;const m=f.findIndex($u.bind(null,h));if(m>-1)return m;const I=zD(u[d-2]);return d>1&&zD(h)===I&&f[f.length-1].path!==I?f.findIndex($u.bind(null,u[d-2])):m}),i=pi(()=>r.value>-1&&r1e(t.params,s.value.params)),o=pi(()=>r.value>-1&&r.value===t.matched.length-1&&j5(t.params,s.value.params));function l(u={}){if(s1e(u)){const d=e[ca(n.replace)?"replace":"push"](ca(n.to)).catch(Rc);return n.viewTransition&&typeof document<"u"&&"startViewTransition"in document&&document.startViewTransition(()=>d),d}return Promise.resolve()}return{route:s,href:pi(()=>s.value.href),isActive:i,isExactActive:o,navigate:l}}function e1e(n){return n.length===1?n[0]:n}const t1e=Il({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:FD,setup(n,{slots:e}){const t=hu(FD(n)),{options:s}=da(Hx),r=pi(()=>({[MD(n.activeClass,s.linkActiveClass,"router-link-active")]:t.isActive,[MD(n.exactActiveClass,s.linkExactActiveClass,"router-link-exact-active")]:t.isExactActive}));return()=>{const i=e.default&&e1e(e.default(t));return n.custom?i:YE("a",{"aria-current":t.isExactActive?n.ariaCurrentValue:null,href:t.href,onClick:t.navigate,class:r.value},i)}}}),n1e=t1e;function s1e(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)&&!n.defaultPrevented&&!(n.button!==void 0&&n.button!==0)){if(n.currentTarget&&n.currentTarget.getAttribute){const e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}function r1e(n,e){for(const t in e){const s=e[t],r=n[t];if(typeof s=="string"){if(s!==r)return!1}else if(!wi(r)||r.length!==s.length||s.some((i,o)=>i!==r[o]))return!1}return!0}function zD(n){return n?n.aliasOf?n.aliasOf.path:n.path:""}const MD=(n,e,t)=>n??e??t,i1e=Il({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(n,{attrs:e,slots:t}){const s=da(YI),r=pi(()=>n.route||s.value),i=da(PD,0),o=pi(()=>{let d=ca(i);const{matched:h}=r.value;let f;for(;(f=h[d])&&!f.components;)d++;return d}),l=pi(()=>r.value.matched[o.value]);Ip(PD,pi(()=>o.value+1)),Ip(J0e,l),Ip(YI,r);const u=zc();return ru(()=>[u.value,l.value,n.name],([d,h,f],[m,I,y])=>{h&&(h.instances[f]=d,I&&I!==h&&d&&d===m&&(h.leaveGuards.size||(h.leaveGuards=I.leaveGuards),h.updateGuards.size||(h.updateGuards=I.updateGuards))),d&&h&&(!I||!$u(h,I)||!m)&&(h.enterCallbacks[f]||[]).forEach(N=>N(d))},{flush:"post"}),()=>{const d=r.value,h=n.name,f=l.value,m=f&&f.components[h];if(!m)return WD(t.default,{Component:m,route:d});const I=f.props[h],y=I?I===!0?d.params:typeof I=="function"?I(d):I:null,w=YE(m,an({},y,e,{onVnodeUnmounted:T=>{T.component.isUnmounted&&(f.instances[h]=null)},ref:u}));return WD(t.default,{Component:w,route:d})||w}}});function WD(n,e){if(!n)return null;const t=n(e);return t.length===1?t[0]:t}const a1e=i1e;function o1e(n){const e=q0e(n.routes,n),t=n.parseQuery||Z0e,s=n.stringifyQuery||VD,r=n.history,i=gc(),o=gc(),l=gc(),u=M6(_a);let d=_a;Yl&&n.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const h=k1.bind(null,he=>""+he),f=k1.bind(null,b0e),m=k1.bind(null,ad);function I(he,_e){let ke,ze;return X5(he)?(ke=e.getRecordMatcher(he),ze=_e):ze=he,e.addRoute(ze,ke)}function y(he){const _e=e.getRecordMatcher(he);_e&&e.removeRoute(_e)}function N(){return e.getRoutes().map(he=>he.record)}function w(he){return!!e.getRecordMatcher(he)}function T(he,_e){if(_e=an({},_e||u.value),typeof he=="string"){const Q=C1(t,he,_e.path),ue=e.resolve({path:Q.path},_e),Ee=r.createHref(Q.fullPath);return an(Q,ue,{params:m(ue.params),hash:ad(Q.hash),redirectedFrom:void 0,href:Ee})}let ke;if(he.path!=null)ke=an({},he,{path:C1(t,he.path,_e.path).path});else{const Q=an({},he.params);for(const ue in Q)Q[ue]==null&&delete Q[ue];ke=an({},he,{params:f(Q)}),_e.params=f(_e.params)}const ze=e.resolve(ke,_e),at=he.hash||"";ze.params=h(m(ze.params));const xt=w0e(s,an({},he,{hash:g0e(at),path:ze.path})),j=r.createHref(xt);return an({fullPath:xt,hash:at,query:s===VD?Q0e(he.query):he.query||{}},ze,{redirectedFrom:void 0,href:j})}function v(he){return typeof he=="string"?C1(t,he,u.value.path):an({},he)}function E(he,_e){if(d!==he)return _u(8,{from:_e,to:he})}function _(he){return B(he)}function L(he){return _(an(v(he),{replace:!0}))}function P(he){const _e=he.matched[he.matched.length-1];if(_e&&_e.redirect){const{redirect:ke}=_e;let ze=typeof ke=="function"?ke(he):ke;return typeof ze=="string"&&(ze=ze.includes("?")||ze.includes("#")?ze=v(ze):{path:ze},ze.params={}),an({query:he.query,hash:he.hash,params:ze.path!=null?{}:he.params},ze)}}function B(he,_e){const ke=d=T(he),ze=u.value,at=he.state,xt=he.force,j=he.replace===!0,Q=P(ke);if(Q)return B(an(v(Q),{state:typeof Q=="object"?an({},at,Q.state):at,force:xt,replace:j}),_e||ke);const ue=ke;ue.redirectedFrom=_e;let Ee;return!xt&&A0e(s,ze,ke)&&(Ee=_u(16,{to:ue,from:ze}),Fe(ze,ze,!0,!1)),(Ee?Promise.resolve(Ee):Y(ue,ze)).catch(Se=>na(Se)?na(Se,2)?Se:Pe(Se):fe(Se,ue,ze)).then(Se=>{if(Se){if(na(Se,2))return B(an({replace:j},v(Se.to),{state:typeof Se.to=="object"?an({},at,Se.to.state):at,force:xt}),_e||ue)}else Se=de(ue,ze,!0,j,at);return ae(ue,ze,Se),Se})}function U(he,_e){const ke=E(he,_e);return ke?Promise.reject(ke):Promise.resolve()}function Z(he){const _e=Ze.values().next().value;return _e&&typeof _e.runWithContext=="function"?_e.runWithContext(he):he()}function Y(he,_e){let ke;const[ze,at,xt]=l1e(he,_e);ke=L1(ze.reverse(),"beforeRouteLeave",he,_e);for(const Q of ze)Q.leaveGuards.forEach(ue=>{ke.push(Oa(ue,he,_e))});const j=U.bind(null,he,_e);return ke.push(j),Qe(ke).then(()=>{ke=[];for(const Q of i.list())ke.push(Oa(Q,he,_e));return ke.push(j),Qe(ke)}).then(()=>{ke=L1(at,"beforeRouteUpdate",he,_e);for(const Q of at)Q.updateGuards.forEach(ue=>{ke.push(Oa(ue,he,_e))});return ke.push(j),Qe(ke)}).then(()=>{ke=[];for(const Q of xt)if(Q.beforeEnter)if(wi(Q.beforeEnter))for(const ue of Q.beforeEnter)ke.push(Oa(ue,he,_e));else ke.push(Oa(Q.beforeEnter,he,_e));return ke.push(j),Qe(ke)}).then(()=>(he.matched.forEach(Q=>Q.enterCallbacks={}),ke=L1(xt,"beforeRouteEnter",he,_e,Z),ke.push(j),Qe(ke))).then(()=>{ke=[];for(const Q of o.list())ke.push(Oa(Q,he,_e));return ke.push(j),Qe(ke)}).catch(Q=>na(Q,8)?Q:Promise.reject(Q))}function ae(he,_e,ke){l.list().forEach(ze=>Z(()=>ze(he,_e,ke)))}function de(he,_e,ke,ze,at){const xt=E(he,_e);if(xt)return xt;const j=_e===_a,Q=Yl?history.state:{};ke&&(ze||j?r.replace(he.fullPath,an({scroll:j&&Q&&Q.scroll},at)):r.push(he.fullPath,at)),u.value=he,Fe(he,_e,ke,j),Pe()}let ce;function Ie(){ce||(ce=r.listen((he,_e,ke)=>{if(!je.listening)return;const ze=T(he),at=P(ze);if(at){B(an(at,{replace:!0,force:!0}),ze).catch(Rc);return}d=ze;const xt=u.value;Yl&&k0e($D(xt.fullPath,ke.delta),wg()),Y(ze,xt).catch(j=>na(j,12)?j:na(j,2)?(B(an(v(j.to),{force:!0}),ze).then(Q=>{na(Q,20)&&!ke.delta&&ke.type===od.pop&&r.go(-1,!1)}).catch(Rc),Promise.reject()):(ke.delta&&r.go(-ke.delta,!1),fe(j,ze,xt))).then(j=>{j=j||de(ze,xt,!1),j&&(ke.delta&&!na(j,8)?r.go(-ke.delta,!1):ke.type===od.pop&&na(j,20)&&r.go(-1,!1)),ae(ze,xt,j)}).catch(Rc)}))}let be=gc(),ye=gc(),we;function fe(he,_e,ke){Pe(he);const ze=ye.list();return ze.length?ze.forEach(at=>at(he,_e,ke)):console.error(he),Promise.reject(he)}function De(){return we&&u.value!==_a?Promise.resolve():new Promise((he,_e)=>{be.add([he,_e])})}function Pe(he){return we||(we=!he,Ie(),be.list().forEach(([_e,ke])=>he?ke(he):_e()),be.reset()),he}function Fe(he,_e,ke,ze){const{scrollBehavior:at}=n;if(!Yl||!at)return Promise.resolve();const xt=!ke&&C0e($D(he.fullPath,0))||(ze||!ke)&&history.state&&history.state.scroll||null;return gE().then(()=>at(he,_e,xt)).then(j=>j&&E0e(j)).catch(j=>fe(j,he,_e))}const Ue=he=>r.go(he);let Ge;const Ze=new Set,je={currentRoute:u,listening:!0,addRoute:I,removeRoute:y,clearRoutes:e.clearRoutes,hasRoute:w,getRoutes:N,resolve:T,options:n,push:_,replace:L,go:Ue,back:()=>Ue(-1),forward:()=>Ue(1),beforeEach:i.add,beforeResolve:o.add,afterEach:l.add,onError:ye.add,isReady:De,install(he){const _e=this;he.component("RouterLink",n1e),he.component("RouterView",a1e),he.config.globalProperties.$router=_e,Object.defineProperty(he.config.globalProperties,"$route",{enumerable:!0,get:()=>ca(u)}),Yl&&!Ge&&u.value===_a&&(Ge=!0,_(r.location).catch(at=>{}));const ke={};for(const at in _a)Object.defineProperty(ke,at,{get:()=>u.value[at],enumerable:!0});he.provide(Hx,_e),he.provide(eP,dE(ke)),he.provide(YI,u);const ze=he.unmount;Ze.add(he),he.unmount=function(){Ze.delete(he),Ze.size<1&&(d=_a,ce&&ce(),ce=null,u.value=_a,Ge=!1,we=!1),ze()}}};function Qe(he){return he.reduce((_e,ke)=>_e.then(()=>Z(ke)),Promise.resolve())}return je}function l1e(n,e){const t=[],s=[],r=[],i=Math.max(e.matched.length,n.matched.length);for(let o=0;o<i;o++){const l=e.matched[o];l&&(n.matched.find(d=>$u(d,l))?s.push(l):t.push(l));const u=n.matched[o];u&&(e.matched.find(d=>$u(d,u))||r.push(u))}return[t,s,r]}const u1e=[{path:"/nichess2/",name:"Game",component:Xge},{path:"/nichess2/rules",name:"Rules",component:e0e},{path:"/nichess2/about",name:"About",component:r0e}],c1e=o1e({history:V0e(),routes:u1e});Tz(i0e).use(c1e).mount("#app");
